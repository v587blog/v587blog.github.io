<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
    
    <meta name="renderer" content="webkit"/>
    <meta name="force-rendering" content="webkit"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <script>if (/*@cc_on!@*/false || (!!window.MSInputMethodContext && !!document.documentMode)) window.location.href="https://support.dmeng.net/upgrade-your-browser.html?referrer="+encodeURIComponent(window.location.href); </script>
    
    
        <link rel="preload" crossorigin="crossorigin" href="/fonts/roboto/Roboto-Regular.woff2" as="font">
        <link rel="preload" crossorigin="crossorigin" href="/fonts/roboto/Roboto-Bold.woff2" as="font">
    
    
    
        <link rel="shortcut icon" href="/icons/favicon.ico">
    
    
    
<link rel="stylesheet" href="/css/mdui.min.css">
<link rel="stylesheet" href="/css/main.css">
<link rel="stylesheet" href="/css/iconfont.css">

    
    

    
        <script data-ad-client="ca-" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    












          


    
    
    <title>
        
            Mysql5.7中文参考指南 | Hexo
        
    </title>
    
    
<meta name="generator" content="Hexo 4.2.1"></head>
<body class="mdui-drawer-body-left mdui-appbar-with-toolbar mdui-theme-primary-teal mdui-theme-accent-blue">
  
  <header class="mdui-appbar mdui-appbar-fixed">
  <div id="toolbar" class="mdui-toolbar mdui-color-theme">
    <button class="mdui-btn mdui-btn-icon" mdui-drawer="{target: '#sidebar', swipe: true}"><i class="iconfont icon-menu"></i></button>
    <a href="/" class="mdui-typo-headline">Hexo</a>
    <a href="/" class="header-subtitle mdui-typo-headline"></a>
    <div class="mdui-toolbar-spacer"></div>
    <button class="mdui-btn mdui-btn-icon" mdui-dialog="{target: '#search'}" mdui-tooltip="{content: 'search'}"><i class="iconfont icon-search"></i></button>
  </div>
</header>

<div class="mdui-dialog" id="search">
  
    <div class="search-form">
      <input type="search" class="search-form-input" placeholder="请输入关键字" onfocus="listenSearchFunc()">
    </div>
    <div class="search-result" data-resource="/search.xml"></div>
  
</div>

  <aside id="sidebar" class="mdui-drawer">
    <div class="mdui-tab" mdui-tab>
        <a href="#sidebar-tab1" id="sidebartab" class="mdui-ripple mdui-tab-active">站点概览</a>
        <a href="#sidebar-tab2" id="sidebartab" class="mdui-ripple">关于</a>
    </div>

    
    <div id="sidebar-tab1" class="mdui-p-a-2">
        <div class="mdui-list">
            
                
                <a href="/" class="mdui-list-item mdui-ripple">
                    <div class="mdui-list-item-icon">
                        <i class="iconfont icon-home"></i>
                    </div>
                    <div class="mdui-list-item-content">主页</div>
                </a>
            
                
                <a href="/tags/" class="mdui-list-item mdui-ripple">
                    <div class="mdui-list-item-icon">
                        <i class="iconfont icon-bookmark"></i>
                    </div>
                    <div class="mdui-list-item-content">标签</div>
                </a>
            
                
                <a href="/categories/" class="mdui-list-item mdui-ripple">
                    <div class="mdui-list-item-icon">
                        <i class="iconfont icon-folder"></i>
                    </div>
                    <div class="mdui-list-item-content">分类</div>
                </a>
            
                
                <a href="/archives/" class="mdui-list-item mdui-ripple">
                    <div class="mdui-list-item-icon">
                        <i class="iconfont icon-archive"></i>
                    </div>
                    <div class="mdui-list-item-content">归档</div>
                </a>
            
                
                <a href="/tools/" class="mdui-list-item mdui-ripple">
                    <div class="mdui-list-item-icon">
                        <i class="iconfont icon-tools"></i>
                    </div>
                    <div class="mdui-list-item-content">工具箱</div>
                </a>
            
                
                <a href="/about/" class="mdui-list-item mdui-ripple">
                    <div class="mdui-list-item-icon">
                        <i class="iconfont icon-user"></i>
                    </div>
                    <div class="mdui-list-item-content">关于</div>
                </a>
            
            <div class="mdui-list-item mdui-ripple">
                <div class="mdui-list-item-icon">
                    <i class="iconfont icon-moon"></i>
                </div>
                <div class="mdui-list-item-content">夜间模式</div>
                <label class="mdui-switch" id="darkmode">
                  <input type="checkbox" id="nightmode_switch"/>
                  <i class="mdui-switch-icon"></i>
                </label>
            </div>           
        </div>
    </div>

    
    <div id="sidebar-tab2" class="mdui-p-a-2">
        <div class="sidebar-overview">
            <div class="sidebar-avatar">
                
                    <img src="/icons/avatar.gif"/>
                
            </div>
            <div class="sidebar-author-name">John Doe</div>
            <div class="sidebar-description"></div>
        </div>
        <div class="sidebar-links">
            
                
                <div class="mdui-chip">
                    <span class="mdui-chip-icon"><i class="iconfont icon-mail"></i></span>
                    <a href="mailto:xxx@xxx.com" class="mdui-chip-title">E-Mail</a>
                </div>
            
                
                <div class="mdui-chip">
                    <span class="mdui-chip-icon"><i class="iconfont icon-github"></i></span>
                    <a href="https://your.url" target="_blank" rel="noopener" class="mdui-chip-title">GitHub</a>
                </div>
            
                
                <div class="mdui-chip">
                    <span class="mdui-chip-icon"><i class="iconfont icon-steam"></i></span>
                    <a href="https://your.url" target="_blank" rel="noopener" class="mdui-chip-title">Steam</a>
                </div>
            
                
                <div class="mdui-chip">
                    <span class="mdui-chip-icon"><i class="iconfont icon-weibo"></i></span>
                    <a href="https://your.url" target="_blank" rel="noopener" class="mdui-chip-title">Weibo</a>
                </div>
            
        </div>
        <ul class="mdui-list" mdui-collapse="{accordion: true}">
            <li class="mdui-collapse-item">
                <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
                    <div class="mdui-list-item-icon">
                        <i class="iconfont icon-link"></i>
                    </div>
                    <div class="mdui-list-item-content">友情链接</div>
                    <div class="mdui-collapse-item-arrow">
                        <i class="mdui-list-item-icon iconfont icon-angle-down"></i>
                    </div>
                </div>
                <ul class="mdui-collapse-item-body mdui-list mdui-list-dense">
                    
                        <a href="https://garybear.cn/hexo-theme-meadow/" target="_blank" rel="noopener" class="mdui-list-item mdui-ripple">
                            Meadow说明文档
                        </a>
                    
                </ul>
            </li>
        </ul>

    </div>

    <div class="mdui-divider"></div>
    
    
</aside>
  
  <main id="main-contain" class="mdui-container mdui-m-t-5">
    <article id="article" class="mdui-card mdui-p-b-2 mdui-m-b-5">
  <header class="mdui-card-media">
    
    
      <div class="post-header"> 
  <a class="post-header-title" href="/2020/06/29/Mysql5.7%E4%B8%AD%E6%96%87%E5%8F%82%E8%80%83%E6%8C%87%E5%8D%97/">Mysql5.7中文参考指南</a>
  <div class="post-header-meta">
    <span>
      <span class="iconfont icon-calendar"></span>
      发布于:&nbsp;2020-06-29
    </span>
    <span>
      <span class="iconfont icon-calendar-check"></span>
      更新于:&nbsp;2020-06-26
    </span>
    <span>
      <span class="iconfont icon-folder"></span>
      分类于:&nbsp;
    </span>
    
      <span>
        <span class="iconfont icon-eye"></span>
        阅读次数:&nbsp;
        <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span></span>
      </span>
    
  </div>
</div>   
    



    
    
    <div class="mdui-card-menu">
    
      <button class="mdui-btn mdui-btn-icon mdui-text-color-teal" mdui-menu="{target: '#share_menu', align: 'right'}"><i class="iconfont icon-share"></i></button>
      <ul class="mdui-menu" id="share_menu">
        <li class="mdui-menu-item">
          <a href="http://service.weibo.com/share/share.php?appkey=&title=Mysql5.7中文参考指南&url=http://yoursite.com/2020/06/29/Mysql5.7%E4%B8%AD%E6%96%87%E5%8F%82%E8%80%83%E6%8C%87%E5%8D%97/&pic=http://yoursite.com/null&searchPic=false&style=simple" target="_blank" class="mdui-ripple">分享到 Weibo</a>
        </li>
        <li class="mdui-menu-item">
          <a href="https://twitter.com/intent/tweet?text=Mysql5.7中文参考指南&url=http://yoursite.com/2020/06/29/Mysql5.7%E4%B8%AD%E6%96%87%E5%8F%82%E8%80%83%E6%8C%87%E5%8D%97/&via=John Doe" target="_blank" class="mdui-ripple">分享到 Twitter</a>
        </li>
        <li class="mdui-menu-item">
          <a href="https://www.facebook.com/sharer/sharer.php?u=http://yoursite.com/2020/06/29/Mysql5.7%E4%B8%AD%E6%96%87%E5%8F%82%E8%80%83%E6%8C%87%E5%8D%97/" target="_blank" class="mdui-ripple">分享到 Facebook</a>
        </li>
        <li class="mdui-menu-item">
          <a href="https://plus.google.com/share?url=http://yoursite.com/2020/06/29/Mysql5.7%E4%B8%AD%E6%96%87%E5%8F%82%E8%80%83%E6%8C%87%E5%8D%97/" target="_blank" class="mdui-ripple">分享到 Google+</a>
        </li>
        <li class="mdui-menu-item">
          <a href="https://www.linkedin.com/shareArticle?mini=true&url=http://yoursite.com/2020/06/29/Mysql5.7%E4%B8%AD%E6%96%87%E5%8F%82%E8%80%83%E6%8C%87%E5%8D%97/&title=Mysql5.7中文参考指南" target="_blank" class="mdui-ripple">分享到 LinkedIn</a>
        </li>
        <li class="mdui-menu-item">
          <a href="http://connect.qq.com/widget/shareqq/index.html?site=Hexo&title=Mysql5.7中文参考指南&summary=&pics=http://yoursite.com/null&url=http://yoursite.com/2020/06/29/Mysql5.7%E4%B8%AD%E6%96%87%E5%8F%82%E8%80%83%E6%8C%87%E5%8D%97/" target="_blank" class="mdui-ripple">分享到 QQ</a>
        </li>
        <li class="mdui-menu-item">
          <a href="https://telegram.me/share/url?url=http://yoursite.com/2020/06/29/Mysql5.7%E4%B8%AD%E6%96%87%E5%8F%82%E8%80%83%E6%8C%87%E5%8D%97/&text=Mysql5.7中文参考指南" target="_blank" class="mdui-ripple">分享到 Telegram</a>
        </li>
      </ul>
    
  </div>
  </header>
  
  
  
  
  
  <div class="mdui-card-content mdui-typo mdui-p-x-4">
    <h1 id="Mysql5-7中文参考指南精要"><a href="#Mysql5-7中文参考指南精要" class="headerlink" title="Mysql5.7中文参考指南精要"></a>Mysql5.7中文参考指南精要</h1><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>MySQL™软件提供了非常快速，多线程，多用户且健壮的SQL（结构化查询语言）数据库服务器。</p>
<p>MySQL是最流行的开源SQL数据库管理系统，由Oracle Corporation开发，分发和支持。</p>
<ul>
<li><p>MySQL是一个数据库管理系统。</p>
<p>数据库是数据的结构化集合。</p>
</li>
<li><p>MySQL数据库是关系型的。</p>
<p>SQL由ANSI / ISO SQL标准定义。自1986年以来，SQL标准一直在发展，并且存在多个版本。在本手册中，“ SQL-92 ”是指1992年发布的标准，“ SQL：1999 ”是指1999年发布的标准，“ SQL：2003 ”是指标准的当前版本。我们使用 “ SQL标准 ”一词来随时表示SQL标准的当前版本。</p>
</li>
<li><p>MySQL软件是开源的。</p>
</li>
<li><p>MySQL数据库服务器非常快速，可靠，可扩展且易于使用。</p>
</li>
<li><p>MySQL Server在客户端/服务器或嵌入式系统中运行。</p>
</li>
<li><p>可以使用大量的MySQL软件。</p>
</li>
</ul>
<h2 id="内部结构和可移植性"><a href="#内部结构和可移植性" class="headerlink" title="内部结构和可移植性"></a>内部结构和可移植性</h2><ul>
<li>用C和C ++编写。</li>
<li>经过广泛的不同编译器测试。</li>
<li>可在许多不同平台上使用。</li>
<li>为了实现可移植性，请在MySQL 5.5及更高版本中使用<strong>CMake</strong>。先前的系列使用GNU Automake，Autoconf和Libtool。</li>
<li>已通过Purify（商用内存泄漏检测器）以及GPL工具Valgrind进行了测试。</li>
<li>使用具有独立模块的多层服务器设计。</li>
<li>设计为使用内核线程完全多线程，可以轻松使用多个CPU（如果有）。</li>
<li>提供事务性和非事务性存储引擎。</li>
<li>使用<code>MyISAM</code>索引压缩非常快速的B树磁盘表。</li>
<li>使用非常快速的基于线程的内存分配系统。</li>
<li>使用优化的嵌套循环联接执行非常快速的联接。</li>
<li>实现内存中的哈希表，用作临时表。</li>
<li>使用高度优化的类库来实现SQL函数，该类库应尽可能快。通常，查询初始化后根本没有内存分配。</li>
<li>提供服务器作为在客户端/服务器网络环境中使用的单独程序，以及作为可以嵌入（链接）到独立应用程序中的库。此类应用程序可以隔离使用，也可以在没有网络可用的环境中使用。</li>
</ul>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul>
<li>许多数据类型：有符号/无符号整数1，2，3，4，和8个字节长，<a href="https://dev.mysql.com/doc/refman/5.7/en/floating-point-types.html" target="_blank" rel="noopener"><code>FLOAT</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/floating-point-types.html" target="_blank" rel="noopener"><code>DOUBLE</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/char.html" target="_blank" rel="noopener"><code>CHAR</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/char.html" target="_blank" rel="noopener"><code>VARCHAR</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/binary-varbinary.html" target="_blank" rel="noopener"><code>BINARY</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/binary-varbinary.html" target="_blank" rel="noopener"><code>VARBINARY</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/blob.html" target="_blank" rel="noopener"><code>TEXT</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/blob.html" target="_blank" rel="noopener"><code>BLOB</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/datetime.html" target="_blank" rel="noopener"><code>DATE</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/time.html" target="_blank" rel="noopener"><code>TIME</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/datetime.html" target="_blank" rel="noopener"><code>DATETIME</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/datetime.html" target="_blank" rel="noopener"><code>TIMESTAMP</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/year.html" target="_blank" rel="noopener"><code>YEAR</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/set.html" target="_blank" rel="noopener"><code>SET</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/enum.html" target="_blank" rel="noopener"><code>ENUM</code></a>，和开放GIS空间类型。请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/data-types.html" target="_blank" rel="noopener">第11章，<em>数据类型</em></a>。</li>
<li>固定长度和可变长度的字符串类型。</li>
</ul>
<h4 id="语句和函数"><a href="#语句和函数" class="headerlink" title="语句和函数"></a>语句和函数</h4><ul>
<li><p>查询<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>列表和 <code>WHERE</code>子句中的 运算符和函数完全支持 。例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT CONCAT(first_name, ' ', last_name)</span><br><span class="line">    -&gt; FROM citizen</span><br><span class="line">    -&gt; WHERE income/dependents &gt; 10000 AND age &gt; 30;</span><br></pre></td></tr></table></figure>
</li>
<li><p>完全支持SQL <code>GROUP BY</code>和 <code>ORDER BY</code>子句。支持基函数（<a href="https://dev.mysql.com/doc/refman/5.7/en/aggregate-functions.html#function_count" target="_blank" rel="noopener"><code>COUNT()</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/aggregate-functions.html#function_avg" target="_blank" rel="noopener"><code>AVG()</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/aggregate-functions.html#function_std" target="_blank" rel="noopener"><code>STD()</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/aggregate-functions.html#function_sum" target="_blank" rel="noopener"><code>SUM()</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/aggregate-functions.html#function_max" target="_blank" rel="noopener"><code>MAX()</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/aggregate-functions.html#function_min" target="_blank" rel="noopener"><code>MIN()</code></a>，和 <a href="https://dev.mysql.com/doc/refman/5.7/en/aggregate-functions.html#function_group-concat" target="_blank" rel="noopener"><code>GROUP_CONCAT()</code></a>）。</p>
</li>
<li><p>支持标准SQL和ODBC语法，<code>LEFT OUTER JOIN</code>并 <code>RIGHT OUTER JOIN</code>同时支持它们。</p>
</li>
<li><p>支持标准SQL要求的表和列别名。</p>
</li>
<li><p>支持<a href="https://dev.mysql.com/doc/refman/5.7/en/delete.html" target="_blank" rel="noopener"><code>DELETE</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/replace.html" target="_blank" rel="noopener"><code>REPLACE</code></a>，和 <a href="https://dev.mysql.com/doc/refman/5.7/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a>以返回更改（受影响）的行数，或返回通过连接到服务器时设置标志，而不是匹配的行的数量。</p>
</li>
<li><p>支持特定于MySQL的<a href="https://dev.mysql.com/doc/refman/5.7/en/show.html" target="_blank" rel="noopener"><code>SHOW</code></a> 语句，该语句检索有关数据库，存储引擎，表和索引的信息。支持 <code>INFORMATION_SCHEMA</code>数据库，根据标准SQL实现。</p>
</li>
<li><p>一条<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>语句，显示优化器如何解析查询。</p>
</li>
<li><p>函数名称与表或列名称的独立性。例如，<code>ABS</code>是一个有效的列名。唯一的限制是，对于函数调用，函数名称和其后的“ <code>(</code>”之间不允许有空格 。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/keywords.html" target="_blank" rel="noopener">第9.3节“关键字和保留字”</a>。</p>
</li>
<li><p>您可以在同一条语句中引用来自不同数据库的表。</p>
</li>
</ul>
<h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><ul>
<li>拥有一个非常灵活和安全权限和密码系统，并且可以进行基于主机的验证。</li>
<li>连接服务器时，通过对所有密码通信进行加密来实现密码安全。</li>
</ul>
<h4 id="可扩展性和限制"><a href="#可扩展性和限制" class="headerlink" title="可扩展性和限制"></a>可扩展性和限制</h4><ul>
<li>支持大型数据库。我们将MySQL Server与包含5000万条记录的数据库一起使用。我们也知道使用MySQL Server的用户有200,000个表和大约5,000,000,000行。</li>
<li>每个表最多支持64个索引。每个索引可以包含1到16列或部分列。<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html" target="_blank" rel="noopener"><code>InnoDB</code></a>表的最大索引宽度为767字节或3072字节。请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-limits.html" target="_blank" rel="noopener">第14.23节“ InnoDB限制”</a>。<a href="https://dev.mysql.com/doc/refman/5.7/en/myisam-storage-engine.html" target="_blank" rel="noopener"><code>MyISAM</code></a>表的最大索引宽度为 1000字节。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/myisam-storage-engine.html" target="_blank" rel="noopener">第15.2节“ MyISAM存储引擎”</a>。索引可使用的柱的前缀<a href="https://dev.mysql.com/doc/refman/5.7/en/char.html" target="_blank" rel="noopener"><code>CHAR</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/char.html" target="_blank" rel="noopener"><code>VARCHAR</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/blob.html" target="_blank" rel="noopener"><code>BLOB</code></a>，或 <a href="https://dev.mysql.com/doc/refman/5.7/en/blob.html" target="_blank" rel="noopener"><code>TEXT</code></a>列类型。</li>
</ul>
<h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><ul>
<li>客户端可以使用多种协议连接到MySQL Server：<ul>
<li>客户端可以在任何平台上使用TCP / IP套接字进行连接。</li>
<li>在Windows系统上，如果服务器在<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_named_pipe" target="_blank" rel="noopener"><code>named_pipe</code></a>启用系统变量的情况下启动，则客户端可以使用命名管道进行连接 。如果在<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_shared_memory" target="_blank" rel="noopener"><code>shared_memory</code></a>启用系统变量的情况下启动，Windows服务器也支持共享内存连接 。客户端可以使用该<a href="https://dev.mysql.com/doc/refman/5.7/en/connection-options.html#option_general_protocol" target="_blank" rel="noopener"><code>--protocol=memory</code></a>选项通过共享内存进行连接 。</li>
<li>在Unix系统上，客户端可以使用Unix域套接字文件进行连接。</li>
</ul>
</li>
<li>MySQL客户端程序可以用多种语言编写。用C编写的客户端库可用于用C或C ++编写的客户端，或提供C绑定的任何语言的客户端。</li>
<li>提供了C，C ++，Eiffel，Java，Perl，PHP，Python，Ruby和Tcl的API，使MySQL客户端可以用多种语言编写。请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/connectors-apis.html" target="_blank" rel="noopener">第27章，<em>连接器和API</em></a>。</li>
<li>连接器/ ODBC（MyODBC）接口为使用ODBC（开放数据库连接）连接的客户端程序提供MySQL支持。例如，您可以使用MS Access连接到MySQL服务器。客户端可以在Windows或Unix上运行。连接器/ ODBC源可用。支持所有ODBC 2.5功能，以及许多其他功能。参见《 <a href="https://dev.mysql.com/doc/connector-odbc/en/" target="_blank" rel="noopener">MySQL Connector / ODBC开发人员指南》</a>。</li>
<li>Connector / J接口为使用JDBC连接的Java客户端程序提供MySQL支持。客户端可以在Windows或Unix上运行。连接器/ J源可用。参见《 <a href="https://dev.mysql.com/doc/connector-j/5.1/en/" target="_blank" rel="noopener">MySQL Connector / J 5.1开发人员指南》</a>。</li>
<li>MySQL Connector / NET使开发人员可以轻松创建需要与MySQL安全，高性能数据连接的.NET应用程序。它实现了必需的ADO.NET接口，并集成到ADO.NET感知工具中。开发人员可以使用他们选择的.NET语言来构建应用程序。MySQL Connector / NET是用100％纯C＃编写的完全托管的ADO.NET驱动程序。参见《 <a href="https://dev.mysql.com/doc/connector-net/en/" target="_blank" rel="noopener">MySQL Connector / NET开发人员指南》</a>。</li>
</ul>
<h4 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h4><ul>
<li>服务器可以用多种语言向客户端提供错误消息。</li>
<li>几个不同的字符集，包括全面支持 <code>latin1</code>（CP1252） ，<code>german</code>， <code>big5</code>，<code>ujis</code>一些Unicode字符集等。例如，在表名和列名中允许使用斯堪的纳维亚字符“ <code>å</code>”， “ <code>ä</code>”和 “ <code>ö</code>”。</li>
<li>所有数据都保存在所选字符集中。</li>
<li>排序和比较是根据默认字符集和排序规则完成的。可以在启动MySQL服务器时更改此要查看非常高级的排序示例，请查看Czech排序代码。MySQL Server支持许多不同的字符集，可以在编译时和运行时指定它们。</li>
<li>服务器时区可以动态更改，并且各个客户端可以指定自己的时区。</li>
</ul>
<h4 id="客户端和工具"><a href="#客户端和工具" class="headerlink" title="客户端和工具"></a>客户端和工具</h4><ul>
<li>MySQL包括几个客户端程序和实用程序。这些既包括命令行程序（例如 <a href="https://dev.mysql.com/doc/refman/5.7/en/mysqldump.html" target="_blank" rel="noopener"><strong>mysqldump</strong></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/mysqladmin.html" target="_blank" rel="noopener"><strong>mysqladmin）</strong></a>，又包括图形程序（例如 <a href="https://dev.mysql.com/doc/refman/5.7/en/workbench.html" target="_blank" rel="noopener">MySQL Workbench）</a>。</li>
<li>MySQL Server内置了对SQL语句的支持，以检查，优化和修复表。这些语句可通过 <a href="https://dev.mysql.com/doc/refman/5.7/en/mysqlcheck.html" target="_blank" rel="noopener"><strong>mysqlcheck</strong></a>客户端<a href="https://dev.mysql.com/doc/refman/5.7/en/mysqlcheck.html" target="_blank" rel="noopener"><strong>从命令行使用</strong></a>。MySQL还包括 <a href="https://dev.mysql.com/doc/refman/5.7/en/myisamchk.html" target="_blank" rel="noopener"><strong>myisamchk</strong></a>，这是一个非常快的命令行实用程序，用于在<code>MyISAM</code> 表上执行这些操作。</li>
<li>可以使用<code>--help</code> 或<code>-?</code>选项调用MySQL程序以获得在线帮助。</li>
</ul>
<h2 id="MySQL历史"><a href="#MySQL历史" class="headerlink" title="MySQL历史"></a>MySQL历史</h2><p>MySQL以共同创始人Monty Widenius的女儿My命名。</p>
<p>MySQL Dolphin（我们的徽标）的名称是“ Sakila ” ，它是从用户在我们的“ 命名海豚 ”竞赛中建议的大量名称中选择的。获胜者的名字是由来自非洲斯威士兰的开源软件开发商Ambrose Twebaze提交的。根据Ambrose的说法，女性名字Sakila起源于斯威士兰的本地语言SiSwati。Sakila还是坦桑尼亚阿鲁沙的一个小镇的名称，靠近安布罗斯的原籍国乌干达。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p><strong>目录</strong></p>
<ul>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/optimize-overview.html" target="_blank" rel="noopener">8.1优化概述</a></p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/statement-optimization.html" target="_blank" rel="noopener">8.2优化SQL语句</a></p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/optimization-indexes.html" target="_blank" rel="noopener">8.3优化和索引</a></p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizing-database-structure.html" target="_blank" rel="noopener">8.4优化数据库结构</a></p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb.html" target="_blank" rel="noopener">8.5优化InnoDB表</a></p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizing-myisam.html" target="_blank" rel="noopener">8.6优化MyISAM表</a></p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizing-memory-tables.html" target="_blank" rel="noopener">8.7优化内存表</a></p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/execution-plan-information.html" target="_blank" rel="noopener">8.8了解查询执行计划</a></p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/controlling-optimizer.html" target="_blank" rel="noopener">8.9控制查询优化器</a></p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/buffering-caching.html" target="_blank" rel="noopener">8.10缓冲和缓存</a></p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/locking-issues.html" target="_blank" rel="noopener">8.11优化锁定操作</a></p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizing-server.html" target="_blank" rel="noopener">8.12优化MySQL服务器</a></p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/optimize-benchmarking.html" target="_blank" rel="noopener">8.13评估效果（基准测试）</a></p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/thread-information.html" target="_blank" rel="noopener">8.14检查线程信息</a></p>
</li>
</ul>
<p>本章说明如何优化MySQL性能并提供示例。优化涉及多个级别的配置，调整和测量性能。根据您的工作角色（开发人员，DBA或两者的组合），您可以在单个SQL语句，整个应用程序，单个数据库服务器或多个联网数据库服务器的级别进行优化。有时，您可以主动并提前计划性能，而有时，您可能会在问题发生后对配置或代码问题进行故障排除。优化CPU和内存使用率还可以提高可伸缩性，从而使数据库能够处理更多负载而不会降低速度。</p>
<h2 id="8-1优化概述"><a href="#8-1优化概述" class="headerlink" title="8.1优化概述"></a>8.1优化概述</h2><p>数据库性能取决于数据库级别的几个因素，例如表，查询和配置设置。这些软件构造导致在硬件级别执行CPU和I / O操作，您必须将这些操作最小化并使其尽可能高效。在研究数据库性能时，首先要学习软件方面的高级规则和准则，并使用时钟时间来衡量性能。成为专家后，您将了解有关内部情况的更多信息，并开始测量诸如CPU周期和I / O操作之类的东西。</p>
<p>典型的用户旨在从其现有的软件和硬件配置中获得最佳的数据库性能。高级用户寻找机会改进MySQL软件本身，或开发自己的存储引擎和硬件设备以扩展MySQL生态系统。</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/optimize-overview.html#optimize-database-level" target="_blank" rel="noopener">在数据库级别进行优化</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/optimize-overview.html#optimize-hardware-level" target="_blank" rel="noopener">在硬件级别进行优化</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/optimize-overview.html#optimize-portability-performance" target="_blank" rel="noopener">平衡可移植性和性能</a></li>
</ul>
<h3 id="在数据库级别进行优化"><a href="#在数据库级别进行优化" class="headerlink" title="在数据库级别进行优化"></a>在数据库级别进行优化</h3><p>使数据库应用程序快速运行的最重要因素是其基本设计：</p>
<ul>
<li><p>表格的结构是否正确？特别是，这些列是否具有正确的数据类型，并且每个表是否都具有对应任务类型的适当列？例如，执行频繁更新的应用程序通常具有许多表而具有很少的列，而分析大量数据的应用程序通常具有很少的表而具有很多列。</p>
</li>
<li><p>是否使用了正确的 <a href="https://dev.mysql.com/doc/refman/5.7/en/optimization-indexes.html" target="_blank" rel="noopener">索引</a>以提高查询效率？</p>
</li>
<li><p>您是否为每个表使用了适当的存储引擎，并利用了所使用的每个存储引擎的优势和功能？例如，需要事务性存储引擎那就选择<code>InnoDB</code>，需要非事务性存储引擎 且 更看重性能或可伸缩性 ，那么就选择<code>MyISAM</code>。</p>
<p>注意</p>
<p><code>InnoDB</code>是创建表的默认存储引擎。实际上，高级 <code>InnoDB</code>性能特性意味着 <code>InnoDB</code>表通常要比简单<code>MyISAM</code>表好，尤其是对于繁忙的数据库。</p>
</li>
<li><p>每个表都使用适当的行格式吗？该如何选择取决于表使用的存储引擎。特别是，压缩表使用较少的磁盘空间，因此需要较少的磁盘I / O来读写数据。压缩适用于带有<code>InnoDB</code>表的所有工作负载 以及只读 <code>MyISAM</code>表。</p>
</li>
<li><p>应用程序是否使用适当的 <a href="https://dev.mysql.com/doc/refman/5.7/en/locking-issues.html" target="_blank" rel="noopener">锁策略</a>？例如，通过在可能的情况下允许共享访问，以便数据库操作可以同时运行，并在适当的时候请求独占访问，以使关键操作获得最高优先级。同样，存储引擎的选择很重要。该<code>InnoDB</code>存储引擎处理大部分锁问题，而不需要您的参与，让您的代码在数据库有更好的并发，并且减少试验和调整的成本。</p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/buffering-caching.html" target="_blank" rel="noopener">用于缓存的</a> 所有<a href="https://dev.mysql.com/doc/refman/5.7/en/buffering-caching.html" target="_blank" rel="noopener">内存区域</a>大小是否正确？也就是说，足够大以容纳经常访问的数据，但又不能太大以至于它们会使物理内存过载并导致分页。要配置的主要内存区域是<code>InnoDB</code>缓冲池，<code>MyISAM</code>键高速缓存和MySQL查询高速缓存。</p>
</li>
</ul>
<h3 id="在硬件级别进行优化"><a href="#在硬件级别进行优化" class="headerlink" title="在硬件级别进行优化"></a>在硬件级别进行优化</h3><p>随着数据库变得越来越繁忙，任何数据库应用程序最终都会达到硬件极限。DBA必须评估是否有可能调整应用程序或重新配置服务器以避免这些 <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_bottleneck" target="_blank" rel="noopener">瓶颈</a>，或者是否需要更多的硬件资源。系统瓶颈通常来自以下来源：</p>
<ul>
<li>磁盘搜寻。磁盘查找数据需要花费时间。对于现代磁盘，此操作的平均时间通常小于10毫秒，因此理论上我们可以执行约100秒钟的搜索。这段时间随着新磁盘的使用而缓慢改善，并且很难为单个表进行优化。优化寻道时间的方法是将数据分发到多个磁盘上。</li>
<li>磁盘读写。当磁盘位于正确的位置时，我们需要读取或写入数据。使用现代磁盘，一个磁盘至少可以提供10–20MB / s的吞吐量。与查找相比，优化起来更容易，因为您可以从多个磁盘并行读取。</li>
<li>CPU周期。当数据位于主存储器中时，我们必须对其进行处理以获得结果。与内存量相比，拥有较大的表是最常见的限制因素。但是对于小桌子，速度通常不是问题。</li>
<li>内存带宽。当CPU需要的数据超出CPU缓存的容量时，主内存带宽将成为瓶颈。对于大多数系统来说，这是一个不常见的瓶颈，但要意识到这一点。</li>
</ul>
<h3 id="平衡可移植性和性能"><a href="#平衡可移植性和性能" class="headerlink" title="平衡可移植性和性能"></a>平衡可移植性和性能</h3><p>要在可移植性MySQL程序中使用面向性能的SQL扩展，可以在<code>/*! */</code>注释定界符中的语句中包装特定于MySQL的关键字。其他SQL Server忽略注释的关键字。有关编写注释的信息，请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/comments.html" target="_blank" rel="noopener">第9.6节“注释语法”</a>。</p>
<h2 id="8-2优化SQL语句"><a href="#8-2优化SQL语句" class="headerlink" title="8.2优化SQL语句"></a>8.2优化SQL语句</h2><ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/select-optimization.html" target="_blank" rel="noopener">8.2.1优化SELECT语句</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/subquery-optimization.html" target="_blank" rel="noopener">8.2.2优化子查询，派生表和视图引用</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/information-schema-optimization.html" target="_blank" rel="noopener">8.2.3优化INFORMATION_SCHEMA查询</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/data-change-optimization.html" target="_blank" rel="noopener">8.2.4优化数据更改语句</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/permission-optimization.html" target="_blank" rel="noopener">8.2.5优化数据库特权</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/miscellaneous-optimization-tips.html" target="_blank" rel="noopener">8.2.6其他优化技巧</a></li>
</ul>
<p>数据库应用程序的核心逻辑是通过SQL语句执行的，无论是通过解释程序直接发出还是通过API在后台提交。本节中的调整准则有助于加快各种MySQL应用程序的速度。该指南涵盖了读写数据的SQL操作，一般SQL操作的幕后开销以及在特定方案（例如数据库监视）中使用的操作。</p>
<h3 id="8-2-1优化SELECT语句"><a href="#8-2-1优化SELECT语句" class="headerlink" title="8.2.1优化SELECT语句"></a>8.2.1优化SELECT语句</h3><ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/where-optimization.html" target="_blank" rel="noopener">8.2.1.1 WHERE子句优化</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/range-optimization.html" target="_blank" rel="noopener">8.2.1.2范围优化</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/index-merge-optimization.html" target="_blank" rel="noopener">8.2.1.3索引合并优化</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/condition-pushdown-optimization.html" target="_blank" rel="noopener">8.2.1.4发动机状态下推优化</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/index-condition-pushdown-optimization.html" target="_blank" rel="noopener">8.2.1.5索引条件下推优化</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/nested-loop-joins.html" target="_blank" rel="noopener">8.2.1.6嵌套循环联接算法</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/nested-join-optimization.html" target="_blank" rel="noopener">8.2.1.7嵌套联接优化</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/outer-join-optimization.html" target="_blank" rel="noopener">8.2.1.8外部联接优化</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/outer-join-simplification.html" target="_blank" rel="noopener">8.2.1.9外部联接简化</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/mrr-optimization.html" target="_blank" rel="noopener">8.2.1.10多范围读取优化</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/bnl-bka-optimization.html" target="_blank" rel="noopener">8.2.1.11块嵌套循环和批处理密钥访问联接</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/condition-filtering.html" target="_blank" rel="noopener">8.2.1.12条件过滤</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/is-null-optimization.html" target="_blank" rel="noopener">8.2.1.13 IS NULL优化</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/order-by-optimization.html" target="_blank" rel="noopener">8.2.1.14优化排序</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/group-by-optimization.html" target="_blank" rel="noopener">8.2.1.15按优化分组</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/distinct-optimization.html" target="_blank" rel="noopener">8.2.1.16 DISTINCT优化</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/limit-optimization.html" target="_blank" rel="noopener">8.2.1.17 LIMIT查询优化</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/function-optimization.html" target="_blank" rel="noopener">8.2.1.18函数调用优化</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/row-constructor-optimization.html" target="_blank" rel="noopener">8.2.1.19行构造器表达式优化</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/table-scan-avoidance.html" target="_blank" rel="noopener">8.2.1.20避免全表扫描</a></li>
</ul>
<p>查询以<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a> 语句的形式执行数据库中的所有查找操作。无论是实现动态网页的亚秒级响应时间，还是缩短时间以生成大量的夜间报告，调整这些语句都是当务之急。</p>
<p>此外<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>语句，进行查询调谐技术也适用于结构，如 <a href="https://dev.mysql.com/doc/refman/5.7/en/create-table-select.html" target="_blank" rel="noopener"><code>CREATE TABLE...AS SELECT</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/insert-select.html" target="_blank" rel="noopener"><code>INSERT INTO...SELECT</code></a>和<code>WHERE</code>在条款 <a href="https://dev.mysql.com/doc/refman/5.7/en/delete.html" target="_blank" rel="noopener"><code>DELETE</code></a>的语句。这些语句还有其他性能方面的考虑，因为它们将写操作与面向读取的查询操作结合在一起。</p>
<p>NDB Cluster支持联接下推优化，从而将符合条件的联接完整地发送到NDB Cluster数据节点，在该节点中可以将其分发并并行执行。有关此优化的更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-cluster-options-variables.html#ndb_join_pushdown-conditions" target="_blank" rel="noopener">NDB下推连接的条件</a>。</p>
<p>优化查询的主要考虑因素是：</p>
<ul>
<li><p>为了使慢速<code>SELECT ... WHERE</code>查询更快，首先要检查的是是否可以添加 <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_index" target="_blank" rel="noopener">索引</a>。在<code>WHERE</code>子句中使用的列上设置索引，以加快评估，过滤和最终检索结果的速度。为避免浪费磁盘空间，请构建一小组索引，以加快应用程序中使用的许多相关查询的速度。</p>
<p>对于使用<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_join" target="_blank" rel="noopener">联接</a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_foreign_key" target="_blank" rel="noopener">外键之类的</a>功能引用不同表的查询，索引尤其重要 。您可以使用该<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>语句来确定用于的索引 <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-indexes.html" target="_blank" rel="noopener">第8.3.1节“ MySQL如何使用索引”</a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/using-explain.html" target="_blank" rel="noopener">第8.8.1节“使用EXPLAIN优化查询”</a>。</p>
</li>
<li><p>隔离和调整查询中花费过多时间的任何部分，例如函数调用。根据查询的结构方式，可以对结果集中的每一行调用一次函数，甚至可以对表中的每一行调用一次函数，从而极大地提高了效率。</p>
</li>
<li><p>最小化 查询中<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_full_table_scan" target="_blank" rel="noopener">全表扫描</a>的次数 ，特别是对于大表。</p>
</li>
<li><p>通过<a href="https://dev.mysql.com/doc/refman/5.7/en/analyze-table.html" target="_blank" rel="noopener"><code>ANALYZE TABLE</code></a>定期使用该语句来使表统计信息保持最新 ，因此优化器具有构造有效执行计划所需的信息。</p>
</li>
<li><p>了解特定于每个表的存储引擎的调整技术，索引技术和配置参数。双方<code>InnoDB</code>并 <code>MyISAM</code>有两套准则的实现和维持查询高性能。有关详细信息，请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-queries.html" target="_blank" rel="noopener">第8.5.6节“优化InnoDB查询”</a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/optimizing-queries-myisam.html" target="_blank" rel="noopener">第8.6.1节“优化MyISAM查询”</a>。</p>
</li>
<li><p>您可以<code>InnoDB</code>使用<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-ro-txn.html" target="_blank" rel="noopener">第8.5.3节“优化InnoDB只读事务”中</a>的技术<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-ro-txn.html" target="_blank" rel="noopener">优化</a>表的 单查询事务 。</p>
</li>
<li><p>避免以难以理解的方式转换查询，尤其是在优化程序自动执行某些相同转换的情况下。</p>
</li>
<li><p>如果使用基本准则之一不能轻松解决性能问题，请通过阅读<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>计划并调整索引，<code>WHERE</code>子句，连接子句等来调查特定查询的内部详细信息 。（当您达到一定的专业水平时，阅读 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>计划可能是每个查询的第一步。）</p>
</li>
<li><p>调整MySQL用于缓存的内存区域的大小和属性。通过有效地使用 <code>InnoDB</code> <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_buffer_pool" target="_blank" rel="noopener">缓冲池</a>， <code>MyISAM</code>键高速缓存和MySQL查询高速缓存，重复查询的运行速度更快，因为第二次及以后都从内存中检索了结果。</p>
</li>
<li><p>即使对于使用缓存区域快速运行的查询，您仍可能会进一步优化，以使它们需要更少的缓存，从而使您的应用程序更具可伸缩性。可伸缩性意味着您的应用程序可以处理更多的并发用户，更大的请求等，而不会导致性能大幅下降。</p>
</li>
<li><p>处理锁定问题，其中其他会话同时访问表可能会影响查询速度。</p>
</li>
</ul>
<h4 id="8-2-1-1-WHERE子句优化"><a href="#8-2-1-1-WHERE子句优化" class="headerlink" title="8.2.1.1 WHERE子句优化"></a>8.2.1.1 WHERE子句优化</h4><p>注意</p>
<p>由于正在进行MySQL优化程序的工作，因此此处未记录MySQL执行的所有优化。</p>
<p>您可能会想重写查询以使算术运算更快，同时又牺牲了可读性。由于MySQL自动进行类似的优化，因此您通常可以避免这项工作，而将查询保留为更易于理解和维护的形式。MySQL执行的一些优化如下：</p>
<ul>
<li><p>删除不必要的括号：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   ((a AND b) AND c OR (((a AND b) AND (c AND d))))</span><br><span class="line">-&gt; (a AND b AND c) OR (a AND b AND c AND d)</span><br></pre></td></tr></table></figure>
</li>
<li><p>恒定折叠：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   (a&lt;b AND b=c) AND a=5</span><br><span class="line">-&gt; b&gt;5 AND b=c AND a=5</span><br></pre></td></tr></table></figure>
</li>
<li><p>恒定条件消除：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   (b&gt;=5 AND b=5) OR (b=6 AND 5=5) OR (b=7 AND 5=6)</span><br><span class="line">-&gt; b=5 OR b=6</span><br></pre></td></tr></table></figure>
</li>
<li><p>索引使用的常量表达式仅计算一次。</p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/aggregate-functions.html#function_count" target="_blank" rel="noopener"><code>COUNT(*)</code></a>上没有一个单一的表<code>WHERE</code>是从该表信息直接检索<code>MyISAM</code> 和<code>MEMORY</code>表。<code>NOT NULL</code>当仅与一个表一起使用时，对于任何表达式也可以执行此操作。</p>
</li>
<li><p>早期检测无效的常量表达式。MySQL快速检测到某些 <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>语句是不可能的，并且不返回任何行。</p>
</li>
<li><p><code>HAVING``WHERE</code>如果您不使用<code>GROUP BY</code>或汇总功能（<a href="https://dev.mysql.com/doc/refman/5.7/en/aggregate-functions.html#function_count" target="_blank" rel="noopener"><code>COUNT()</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/aggregate-functions.html#function_min" target="_blank" rel="noopener"><code>MIN()</code></a>等），则与合并 。</p>
</li>
<li><p>对于联接中的每个表，<code>WHERE</code>构造一个更简单 <code>WHERE</code>的表以获得表的快速 评估，并尽快跳过行。</p>
</li>
<li><p>在查询中的任何其他表之前，首先读取所有常量表。常量表可以是以下任意一个：</p>
<ul>
<li>空表或具有一行的表。</li>
<li>与a 或 索引<code>WHERE</code> 上的子句一起使用的表，其中所有索引部分都与常量表达式进行比较，并定义为。 <code>PRIMARY KEY``UNIQUE``NOT NULL</code></li>
</ul>
<p>以下所有表均用作常量表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> primary_key=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1,t2</span><br><span class="line">  <span class="keyword">WHERE</span> t1.primary_key=<span class="number">1</span> <span class="keyword">AND</span> t2.primary_key=t1.id;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过尝试所有可能的方法，找到用于联接表的最佳联接组合。如果<code>ORDER BY</code>and <code>GROUP BY</code>子句中的所有列 都来自同一表，则在连接时优先使用该表。</p>
</li>
<li><p>如果有一个<code>ORDER BY</code>子句和另一个<code>GROUP BY</code>子句，或者如果 <code>ORDER BY</code>或<code>GROUP BY</code> 包含联接队列中第一个表以外的表中的列，则会创建一个临时表。</p>
</li>
<li><p>如果使用<code>SQL_SMALL_RESULT</code> 修饰符，MySQL将使用内存中的临时表。</p>
</li>
<li><p>查询每个表索引，并使用最佳索引，除非优化程序认为使用表扫描更有效。一次使用扫描是基于最佳索引是否跨越了表的30％以上，但是固定百分比不再决定使用索引还是扫描。现在，优化器更加复杂，其估计基于其他因素，例如表大小，行数和I / O块大小。</p>
</li>
<li><p>在某些情况下，MySQL甚至可以在不查询数据文件的情况下从索引中读取行。如果索引中使用的所有列都是数字，则仅索引树用于解析查询。</p>
</li>
<li><p>在输出每一行之前，<code>HAVING</code>将跳过不匹配该子句的那些行 。</p>
</li>
</ul>
<p>快速查询的一些示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> tbl_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MIN</span>(key_part1),<span class="keyword">MAX</span>(key_part1) <span class="keyword">FROM</span> tbl_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(key_part2) <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> key_part1=<span class="keyword">constant</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> key_part1,key_part2,... <span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> key_part1 <span class="keyword">DESC</span>, key_part2 <span class="keyword">DESC</span>, ... <span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>假设索引列是数字，MySQL仅使用索引树来解析以下查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> key_part1,key_part2 <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> key_part1=val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> key_part1=val1 <span class="keyword">AND</span> key_part2=val2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> key_part2 <span class="keyword">FROM</span> tbl_name <span class="keyword">GROUP</span> <span class="keyword">BY</span> key_part1;</span><br></pre></td></tr></table></figure>

<p>以下查询使用索引来按排序顺序检索行，而无需单独的排序遍历：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> key_part1,key_part2,... ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> key_part1 <span class="keyword">DESC</span>, key_part2 <span class="keyword">DESC</span>, ... ;</span><br></pre></td></tr></table></figure>

<h4 id="8-2-1-2范围优化"><a href="#8-2-1-2范围优化" class="headerlink" title="8.2.1.2范围优化"></a>8.2.1.2范围优化</h4><p>的<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_range" target="_blank" rel="noopener"><code>range</code></a>访问方法使用单个索引来检索包含一个或若干个索引值的时间间隔内表行的子集。它可以用于单部分或多部分索引。以下各节描述了优化器使用范围访问的条件。</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/range-optimization.html#range-access-single-part" target="_blank" rel="noopener">单部分索引的范围访问方法</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/range-optimization.html#range-access-multi-part" target="_blank" rel="noopener">多部分索引的范围访问方法</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/range-optimization.html#equality-range-optimization" target="_blank" rel="noopener">多值比较的等距范围优化</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/range-optimization.html#row-constructor-range-optimization" target="_blank" rel="noopener">行构造函数表达式的范围优化</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/range-optimization.html#range-optimization-memory-use" target="_blank" rel="noopener">限制内存使用以进行范围优化</a></li>
</ul>
<h5 id="单部分索引的范围访问方法"><a href="#单部分索引的范围访问方法" class="headerlink" title="单部分索引的范围访问方法"></a>单部分索引的范围访问方法</h5><p>对于单部分索引，索引值间隔可以方便地由条款中的相应条件 <code>WHERE</code>表示，称为 范围条件， 而不是“ 间隔”。”</p>
<p>单部分索引的范围条件的定义如下：</p>
<ul>
<li>对于这两种<code>BTREE</code>和 <code>HASH</code>索引，使用时具有恒定值的关键部分的比较是一个范围条件 <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_equal" target="_blank" rel="noopener"><code>=</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_equal-to" target="_blank" rel="noopener"><code>&lt;=&gt;</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_in" target="_blank" rel="noopener"><code>IN()</code></a>，<a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_is-null" target="_blank" rel="noopener"><code>IS NULL</code></a>，或<a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_is-not-null" target="_blank" rel="noopener"><code>IS NOT NULL</code></a>运营商。</li>
<li>另外，对于<code>BTREE</code>索引，当使用具有恒定值的关键部分的比较是一个范围条件 <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_greater-than" target="_blank" rel="noopener"><code>&gt;</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_less-than" target="_blank" rel="noopener"><code>&lt;</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_greater-than-or-equal" target="_blank" rel="noopener"><code>&gt;=</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_less-than-or-equal" target="_blank" rel="noopener"><code>&lt;=</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_between" target="_blank" rel="noopener"><code>BETWEEN</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_not-equal" target="_blank" rel="noopener"><code>!=</code></a>，或 <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_not-equal" target="_blank" rel="noopener"><code>&lt;&gt;</code></a> 运营商，或者<a href="https://dev.mysql.com/doc/refman/5.7/en/string-comparison-functions.html#operator_like" target="_blank" rel="noopener"><code>LIKE</code></a> 比较，如果参数 <a href="https://dev.mysql.com/doc/refman/5.7/en/string-comparison-functions.html#operator_like" target="_blank" rel="noopener"><code>LIKE</code></a>是一个常数字符串不与通配符开始。</li>
<li>对于所有索引类型，多个范围条件组合<a href="https://dev.mysql.com/doc/refman/5.7/en/logical-operators.html#operator_or" target="_blank" rel="noopener"><code>OR</code></a>或 <a href="https://dev.mysql.com/doc/refman/5.7/en/logical-operators.html#operator_and" target="_blank" rel="noopener"><code>AND</code></a>形成一个范围条件。</li>
</ul>
<p>前面的描述中的“ 恒定值 ”表示以下之一：</p>
<ul>
<li>查询字符串中的常量</li>
<li>来自同一联接 的<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_const" target="_blank" rel="noopener"><code>const</code></a> 或<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_system" target="_blank" rel="noopener"><code>system</code></a>表的 列</li>
<li>不相关子查询的结果</li>
<li>任何完全由上述类型的子表达式组成的表达式</li>
</ul>
<p>以下是该<code>WHERE</code>子句中具有范围条件的查询示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1</span><br><span class="line">  <span class="keyword">WHERE</span> key_col &gt; <span class="number">1</span></span><br><span class="line">  <span class="keyword">AND</span> key_col &lt; <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1</span><br><span class="line">  <span class="keyword">WHERE</span> key_col = <span class="number">1</span></span><br><span class="line">  <span class="keyword">OR</span> key_col <span class="keyword">IN</span> (<span class="number">15</span>,<span class="number">18</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1</span><br><span class="line">  <span class="keyword">WHERE</span> key_col <span class="keyword">LIKE</span> <span class="string">'ab%'</span></span><br><span class="line">  <span class="keyword">OR</span> key_col <span class="keyword">BETWEEN</span> <span class="string">'bar'</span> <span class="keyword">AND</span> <span class="string">'foo'</span>;</span><br></pre></td></tr></table></figure>

<p>在优化程序常数传播阶段，某些非常数值可以转换为常数。</p>
<p>MySQL尝试从<code>WHERE</code>子句中为每个可能的索引提取范围条件 。在提取过程中，删除了不能用于构建范围条件的条件，合并了产生重叠范围的条件，并删除了产生空范围的条件。</p>
<p>考虑下面的语句，其中 <code>key1</code>是索引列， <code>nonkey</code>而没有索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span></span><br><span class="line">  (key1 &lt; <span class="string">'abc'</span> <span class="keyword">AND</span> (key1 <span class="keyword">LIKE</span> <span class="string">'abcde%'</span> <span class="keyword">OR</span> key1 <span class="keyword">LIKE</span> <span class="string">'%b'</span>)) <span class="keyword">OR</span></span><br><span class="line">  (key1 &lt; <span class="string">'bar'</span> <span class="keyword">AND</span> nonkey = <span class="number">4</span>) <span class="keyword">OR</span></span><br><span class="line">  (key1 &lt; <span class="string">'uux'</span> <span class="keyword">AND</span> key1 &gt; <span class="string">'z'</span>);</span><br></pre></td></tr></table></figure>

<p>密钥的提取过程<code>key1</code>如下：</p>
<ol>
<li><p>从原始<code>WHERE</code>子句开始：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(key1 &lt; 'abc' AND (key1 LIKE 'abcde%' OR key1 LIKE '%b')) OR</span><br><span class="line">(key1 &lt; 'bar' AND nonkey = 4) OR</span><br><span class="line">(key1 &lt; 'uux' AND key1 &gt; 'z')</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除<code>nonkey = 4</code>，<code>key1 LIKE &#39;%b&#39;</code>因为它们不能用于范围扫描。删除它们的正确方法是将它们替换为<code>TRUE</code>，这样在进行范围扫描时我们不会丢失任何匹配的行。用<code>TRUE</code>产量代替它们：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(key1 &lt; 'abc' AND (key1 LIKE 'abcde%' OR TRUE)) OR</span><br><span class="line">(key1 &lt; 'bar' AND TRUE) OR</span><br><span class="line">(key1 &lt; 'uux' AND key1 &gt; 'z')</span><br></pre></td></tr></table></figure>
</li>
<li><p>崩溃条件始终为true或false：</p>
<ul>
<li><code>(key1 LIKE &#39;abcde%&#39; OR TRUE)</code> 永远是真的</li>
<li><code>(key1 &lt; &#39;uux&#39; AND key1 &gt; &#39;z&#39;)</code> 永远是假的</li>
</ul>
<p>用常量替换这些条件将产生：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(key1 &lt; &#39;abc&#39; AND TRUE) OR (key1 &lt; &#39;bar&#39; AND TRUE) OR (FALSE)</span><br></pre></td></tr></table></figure>

<p>去除不必要的<code>TRUE</code>和 <code>FALSE</code>常数的产率：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(key1 &lt; &#39;abc&#39;) OR (key1 &lt; &#39;bar&#39;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>将重叠的间隔合并为一个会产生用于范围扫描的最终条件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(key1 &lt; &#39;bar&#39;)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>一般而言（如前面的示例所示），范围扫描所使用的条件比该<code>WHERE</code>子句的限制要少。MySQL执行附加检查以过滤出满足范围条件但不包括full <code>WHERE</code>子句的行。</p>
<p>范围条件提取算法可以处理 任意深度的嵌套 <a href="https://dev.mysql.com/doc/refman/5.7/en/logical-operators.html#operator_and" target="_blank" rel="noopener"><code>AND</code></a>/ <a href="https://dev.mysql.com/doc/refman/5.7/en/logical-operators.html#operator_or" target="_blank" rel="noopener"><code>OR</code></a>构造，并且其输出不取决于条件在<code>WHERE</code>子句中出现的顺序 。</p>
<p>MySQL不支持<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_range" target="_blank" rel="noopener"><code>range</code></a>为空间索引的访问方法合并多个范围 。要解决此限制，可以将a <a href="https://dev.mysql.com/doc/refman/5.7/en/union.html" target="_blank" rel="noopener"><code>UNION</code></a>与相同的<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>语句一起 使用，只是将每个空间谓词放在不同的中 <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>。</p>
<h5 id="多部分索引的范围访问方法"><a href="#多部分索引的范围访问方法" class="headerlink" title="多部分索引的范围访问方法"></a>多部分索引的范围访问方法</h5><p>多部分索引的范围条件是单部分索引的范围条件的扩展。多部分索引上的范围条件将索引行限制在一个或几个键元组间隔内。使用从索引开始的顺序，在一组键元组上定义键元组间隔。</p>
<p>例如，考虑定义为的多部分索引 ，并按键顺序列出以下一组键元组： <code>key1(*key_part1*, *key_part2*, *key_part3*)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">key_part1  key_part2  key_part3</span><br><span class="line">  NULL       1          &#39;abc&#39;</span><br><span class="line">  NULL       1          &#39;xyz&#39;</span><br><span class="line">  NULL       2          &#39;foo&#39;</span><br><span class="line">   1         1          &#39;abc&#39;</span><br><span class="line">   1         1          &#39;xyz&#39;</span><br><span class="line">   1         2          &#39;abc&#39;</span><br><span class="line">   2         1          &#39;aaa&#39;</span><br></pre></td></tr></table></figure>

<p>条件<code>*key_part1* = 1</code>定义了此间隔：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1,-inf,-inf) &lt;&#x3D; (key_part1,key_part2,key_part3) &lt; (1,+inf,+inf)</span><br></pre></td></tr></table></figure>

<p>该间隔覆盖了先前数据集中的第4，第5和第6个元组，并且可以由范围访问方法使用。</p>
<p>相反，该条件 <code>*key_part3* = &#39;abc&#39;</code>未定义单个间隔，并且不能被范围访问方法使用。</p>
<p>以下描述更详细地说明了范围条件如何作用于多部分索引。</p>
<ul>
<li><p>对于<code>HASH</code>索引，可以使用包含相同值的每个间隔。这意味着只能针对以下形式的条件生成间隔：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    key_part1 cmp const1</span><br><span class="line">AND key_part2 cmp const2</span><br><span class="line">AND ...</span><br><span class="line">AND key_partN cmp constN;</span><br></pre></td></tr></table></figure>

<p>这里<em>const1*， *const2</em>…是常数，<em>cmp<em>是一个 <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_equal" target="_blank" rel="noopener"><code>=</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_equal-to" target="_blank" rel="noopener"><code>&lt;=&gt;</code></a>或者<a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_is-null" target="_blank" rel="noopener"><code>IS NULL</code></a>比较运营商，以及条件覆盖所有指数部分。（也就是说，</em>N</em> 有条件，<em>N</em>-part索引的每个部分都有一个 条件。）例如，以下是三部分<code>HASH</code>索引的范围条件 ：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key_part1 = 1 AND key_part2 IS NULL AND key_part3 = 'foo'</span><br></pre></td></tr></table></figure>

<p>有关定义为常量的定义，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/range-optimization.html#range-access-single-part" target="_blank" rel="noopener">单部分索引的范围访问方法</a>。</p>
</li>
<li><p>对于一个<code>BTREE</code>索引，以一定间隔可能是可用于条件组合 <a href="https://dev.mysql.com/doc/refman/5.7/en/logical-operators.html#operator_and" target="_blank" rel="noopener"><code>AND</code></a>，其中每个状态具有恒定值使用一个关键部分进行比较 <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_equal" target="_blank" rel="noopener"><code>=</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_equal-to" target="_blank" rel="noopener"><code>&lt;=&gt;</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_is-null" target="_blank" rel="noopener"><code>IS NULL</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_greater-than" target="_blank" rel="noopener"><code>&gt;</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_less-than" target="_blank" rel="noopener"><code>&lt;</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_greater-than-or-equal" target="_blank" rel="noopener"><code>&gt;=</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_less-than-or-equal" target="_blank" rel="noopener"><code>&lt;=</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_not-equal" target="_blank" rel="noopener"><code>!=</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_not-equal" target="_blank" rel="noopener"><code>&lt;&gt;</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_between" target="_blank" rel="noopener"><code>BETWEEN</code></a>，或 （其中 <a href="https://dev.mysql.com/doc/refman/5.7/en/string-comparison-functions.html#operator_like" target="_blank" rel="noopener"><code>LIKE &#39;*pattern*&#39;</code></a><code>&#39;*pattern*&#39;</code> 不以通配符开头）。只要可以确定包含所有与条件匹配的行的单个键元组，就可以使用一个间隔（如果使用<a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_not-equal" target="_blank" rel="noopener"><code>&lt;&gt;</code></a> 或，<a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_not-equal" target="_blank" rel="noopener"><code>!=</code></a> 则使用两个间隔 ）。</p>
<p>只要比较运算符为，或<a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_equal" target="_blank" rel="noopener"><code>=</code></a>， 优化器就会尝试使用其他关键部分来确定间隔 。如果操作是 ， ， ， ， ， ， ，或者 ，优化器使用它，但认为没有更多的关键部分。对于以下表达式，优化器使用 第一个比较中的值。它也使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_equal-to" target="_blank" rel="noopener"><code>&lt;=&gt;</code></a><a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_is-null" target="_blank" rel="noopener"><code>IS NULL</code></a><a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_greater-than" target="_blank" rel="noopener"><code>&gt;</code></a><a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_less-than" target="_blank" rel="noopener"><code>&lt;</code></a><a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_greater-than-or-equal" target="_blank" rel="noopener"><code>&gt;=</code></a><a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_less-than-or-equal" target="_blank" rel="noopener"><code>&lt;=</code></a><a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_not-equal" target="_blank" rel="noopener"><code>!=</code></a><a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_not-equal" target="_blank" rel="noopener"><code>&lt;&gt;</code></a><a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_between" target="_blank" rel="noopener"><code>BETWEEN</code></a><a href="https://dev.mysql.com/doc/refman/5.7/en/string-comparison-functions.html#operator_like" target="_blank" rel="noopener"><code>LIKE</code></a><a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_equal" target="_blank" rel="noopener"><code>=</code></a><a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_greater-than-or-equal" target="_blank" rel="noopener"><code>&gt;=</code></a> 根据第二次比较，但不考虑其他关键部分，并且不将第三次比较用于区间构造：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key_part1 = 'foo' AND key_part2 &gt;= 10 AND key_part3 &gt; 10</span><br></pre></td></tr></table></figure>

<p>单个间隔为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">('foo',10,-inf) &lt; (key_part1,key_part2,key_part3) &lt; ('foo',+inf,+inf)</span><br></pre></td></tr></table></figure>

<p>创建的间隔可能包含比初始条件更多的行。例如，前面的时间间隔包含<code>(&#39;foo&#39;, 11, 0)</code>不满足原始条件的值。</p>
</li>
<li><p>如果将覆盖间隔中包含的行集合的条件与组合<a href="https://dev.mysql.com/doc/refman/5.7/en/logical-operators.html#operator_or" target="_blank" rel="noopener"><code>OR</code></a>，则它们将形成覆盖间隔中的并 集中包含的行集合的条件。如果条件与组合 <a href="https://dev.mysql.com/doc/refman/5.7/en/logical-operators.html#operator_and" target="_blank" rel="noopener"><code>AND</code></a>，则它们将形成一个条件，该条件覆盖其间隔的交点内包含的一组行。例如，对于由两部分组成的索引的这种情况：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(key_part1 = 1 AND key_part2 &lt; 2) OR (key_part1 &gt; 5)</span><br></pre></td></tr></table></figure>

<p>间隔为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(1,-inf) &lt; (key_part1,key_part2) &lt; (1,2)</span><br><span class="line">(5,-inf) &lt; (key_part1,key_part2)</span><br></pre></td></tr></table></figure>

<p>在此示例中，第一行的间隔使用一个关键部分作为左边界，使用两个关键部分作为右边界。第二行的间隔仅使用一个关键部分。输出中的<code>key_len</code>列<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>表示所使用的密钥前缀的最大长度。</p>
<p>在某些情况下，<code>key_len</code>可能表明已使用了关键部件，但这可能不是您期望的。假设 <em>key_part1</em>和 <em>key_part2</em>可以是 <code>NULL</code>。然后，该 <code>key_len</code>列显示以下条件的两个关键零件长度：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key_part1 &gt;= 1 AND key_part2 &lt; 2</span><br></pre></td></tr></table></figure>

<p>但是，实际上，条件已转换为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key_part1 &gt;= 1 AND key_part2 IS NOT NULL</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>有关如何执行优化以合并或消除单部分索引上范围条件的间隔的描述，请参见单部分索引的 <a href="https://dev.mysql.com/doc/refman/5.7/en/range-optimization.html#range-access-single-part" target="_blank" rel="noopener">范围访问方法</a>。对多部分索引的范围条件执行类似的步骤。</p>
<h5 id="多值比较的等距范围优化"><a href="#多值比较的等距范围优化" class="headerlink" title="多值比较的等距范围优化"></a>多值比较的等距范围优化</h5><p>考虑以下表达式，其中 <em>col_name</em>是索引列：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">col_name IN(val1, ..., valN)</span><br><span class="line">col_name = val1 OR ... OR col_name = valN</span><br></pre></td></tr></table></figure>

<p>如果<em>col_name</em>等于多个值中的任何一个，则每个表达式为true 。这些比较是相等范围比较（其中“ range ”是单个值）。优化器估算相等范围比较的读取合格行的成本，如下所示：</p>
<ul>
<li>如果在上有唯一索引 <em>col_name</em>，则每个范围的行估计为1，因为最多一行可以具有给定值。</li>
<li>否则，任何索引 <em>col_name</em>都不是唯一的，优化器可以使用对索引或索引统计的深入估算来估计每个范围的行数。</li>
</ul>
<p>使用索引潜水时，优化器在范围的每个末端进行潜水，并将范围中的行数用作估计值。例如，表达式 <code>*col_name* IN (10, 20, 30)</code>具有三个相等范围，并且优化器对每个范围进行两次下潜以生成行估计。每对潜水都会得出具有给定值的行数的估计值。</p>
<p>索引潜水可提供准确的行估计，但是随着表达式中比较值数量的增加，优化器将花费更长的时间来生成行估计。使用索引统计数据的准确性不及使用索引潜水的准确性，但允许对大型值列表进行更快的行估计。</p>
<p>使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_eq_range_index_dive_limit" target="_blank" rel="noopener"><code>eq_range_index_dive_limit</code></a> 系统变量，您可以配置优化程序从一种行估计策略切换到另一种行估计策略的值的数量。要允许使用索引潜水进行最多<em>N</em> 等于范围的比较，请设置 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_eq_range_index_dive_limit" target="_blank" rel="noopener"><code>eq_range_index_dive_limit</code></a> 为<em>N</em>+1。要禁用统计信息，并且始终使用索引潜水而不管 <em>N</em>，将其设置 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_eq_range_index_dive_limit" target="_blank" rel="noopener"><code>eq_range_index_dive_limit</code></a> 为0。</p>
<p>要更新表索引统计信息以获得最佳估计值，请使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/analyze-table.html" target="_blank" rel="noopener"><code>ANALYZE TABLE</code></a>。</p>
<p>即使在本应使用索引潜水的条件下，对于满足所有这些条件的查询也将跳过它们：</p>
<ul>
<li>存在单索引<code>FORCE INDEX</code>索引提示。这样的想法是，如果强制使用索引，那么执行潜入索引的额外开销将无济于事。</li>
<li>索引不是唯一索引，不是 <code>FULLTEXT</code>索引。</li>
<li>没有子查询。</li>
<li>没有<code>DISTINCT</code>，<code>GROUP BY</code>或<code>ORDER BY</code>子句存在。</li>
</ul>
<p>这些跳水条件仅适用于单表查询。对于多表查询（联接），不会跳过索引潜水。</p>
<h5 id="行构造函数表达式的范围优化"><a href="#行构造函数表达式的范围优化" class="headerlink" title="行构造函数表达式的范围优化"></a>行构造函数表达式的范围优化</h5><p>优化器可以将范围扫描访问方法应用于以下形式的查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> ( col_1, col_2 ) <span class="keyword">IN</span> (( <span class="string">'a'</span>, <span class="string">'b'</span> ), ( <span class="string">'c'</span>, <span class="string">'d'</span> ));</span><br></pre></td></tr></table></figure>

<p>以前，要使用范围扫描，必须将查询编写为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> ( col_1 = <span class="string">'a'</span> <span class="keyword">AND</span> col_2 = <span class="string">'b'</span> )</span><br><span class="line"><span class="keyword">OR</span> ( col_1 = <span class="string">'c'</span> <span class="keyword">AND</span> col_2 = <span class="string">'d'</span> );</span><br></pre></td></tr></table></figure>

<p>为了使优化器使用范围扫描，查询必须满足以下条件：</p>
<ul>
<li>仅使用<a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_in" target="_blank" rel="noopener"><code>IN()</code></a>谓词，不使用<a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_not-in" target="_blank" rel="noopener"><code>NOT IN()</code></a>。</li>
<li>在<a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_in" target="_blank" rel="noopener"><code>IN()</code></a>谓词的左侧 ，行构造器仅包含列引用。</li>
<li>在<a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_in" target="_blank" rel="noopener"><code>IN()</code></a>谓词的右侧 ，行构造器仅包含运行时常量，这些常量是在执行期间绑定到常量的文字或本地列引用。</li>
<li>在<a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_in" target="_blank" rel="noopener"><code>IN()</code></a>谓词的右侧 ，有多个行构造函数。</li>
</ul>
<p>有关优化器和行构造器的更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/row-constructor-optimization.html" target="_blank" rel="noopener">第8.2.1.19节“行构造器表达式优化”。</a></p>
<h5 id="限制内存使用以进行范围优化"><a href="#限制内存使用以进行范围优化" class="headerlink" title="限制内存使用以进行范围优化"></a>限制内存使用以进行范围优化</h5><p>要控制范围优化器可用的内存，请使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_range_optimizer_max_mem_size" target="_blank" rel="noopener"><code>range_optimizer_max_mem_size</code></a> 系统变量：</p>
<ul>
<li><p>值0表示“ 无限制”。”</p>
</li>
<li><p>值大于0时，优化器将在考虑范围访问方法时跟踪消耗的内存。如果将要超过指定的限制，则将放弃范围访问方法，而应考虑其他方法，包括全表扫描。这可能不是最佳选择。如果发生这种情况，则会发生以下警告（ <em>N</em>当前 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_range_optimizer_max_mem_size" target="_blank" rel="noopener"><code>range_optimizer_max_mem_size</code></a> 值为）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Warning    3170    Memory capacity of N bytes for</span><br><span class="line">                   &#39;range_optimizer_max_mem_size&#39; exceeded. Range</span><br><span class="line">                   optimization was not done for this query.</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于<a href="https://dev.mysql.com/doc/refman/5.7/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/delete.html" target="_blank" rel="noopener"><code>DELETE</code></a>语句，如果优化器退回到全表扫描并且<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_sql_safe_updates" target="_blank" rel="noopener"><code>sql_safe_updates</code></a>启用了 系统变量，则会发生错误而不是警告，因为实际上，没有键用于确定要修改的行。有关更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-tips.html#safe-updates" target="_blank" rel="noopener">使用安全更新模式（–safe-updates）</a>。</p>
</li>
</ul>
<p>对于超出可用范围优化内存的单个查询，并且对于该查询，优化器将退回至次优计划，增加 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_range_optimizer_max_mem_size" target="_blank" rel="noopener"><code>range_optimizer_max_mem_size</code></a> 值可以提高性能。</p>
<p>若要估计处理范围表达式所需的内存量，请使用以下准则：</p>
<ul>
<li><p>对于诸如以下的简单查询，其中有一个用于范围访问方法的候选关键字，与组合<a href="https://dev.mysql.com/doc/refman/5.7/en/logical-operators.html#operator_or" target="_blank" rel="noopener"><code>OR</code></a> 使用的每个谓词大约使用230个字节：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> t</span><br><span class="line"><span class="keyword">WHERE</span> a=<span class="number">1</span> <span class="keyword">OR</span> a=<span class="number">2</span> <span class="keyword">OR</span> a=<span class="number">3</span> <span class="keyword">OR</span> .. . a=N;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类似地，对于以下查询，每个谓词组合<a href="https://dev.mysql.com/doc/refman/5.7/en/logical-operators.html#operator_and" target="_blank" rel="noopener"><code>AND</code></a> 使用大约125个字节：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> t</span><br><span class="line"><span class="keyword">WHERE</span> a=<span class="number">1</span> <span class="keyword">AND</span> b=<span class="number">1</span> <span class="keyword">AND</span> c=<span class="number">1</span> ... N;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于带有<a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_in" target="_blank" rel="noopener"><code>IN()</code></a> 谓词的查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> t</span><br><span class="line"><span class="keyword">WHERE</span> a <span class="keyword">IN</span> (<span class="number">1</span>,<span class="number">2</span>, ..., M) <span class="keyword">AND</span> b <span class="keyword">IN</span> (<span class="number">1</span>,<span class="number">2</span>, ..., N);</span><br></pre></td></tr></table></figure>

<p><a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_in" target="_blank" rel="noopener"><code>IN()</code></a>列表 中的每个文字值都 算作与组合的谓词<a href="https://dev.mysql.com/doc/refman/5.7/en/logical-operators.html#operator_or" target="_blank" rel="noopener"><code>OR</code></a>。如果有两个<a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_in" target="_blank" rel="noopener"><code>IN()</code></a> 列表，则与组合的谓词 <a href="https://dev.mysql.com/doc/refman/5.7/en/logical-operators.html#operator_or" target="_blank" rel="noopener"><code>OR</code></a>数量是每个列表中文字值数量的乘积。因此，<a href="https://dev.mysql.com/doc/refman/5.7/en/logical-operators.html#operator_or" target="_blank" rel="noopener"><code>OR</code></a>在前一种情况下组合的谓词数 为 <em>M</em>× <em>N</em>。</p>
</li>
</ul>
<p>在5.7.11之前，与每个谓词组合的字节数<a href="https://dev.mysql.com/doc/refman/5.7/en/logical-operators.html#operator_or" target="_blank" rel="noopener"><code>OR</code></a>更高，大约为700字节。</p>
<h4 id="8-2-1-3索引合并优化"><a href="#8-2-1-3索引合并优化" class="headerlink" title="8.2.1.3索引合并优化"></a>8.2.1.3索引合并优化</h4><p>该指数合并与多址接入方式检索行 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_range" target="_blank" rel="noopener"><code>range</code></a>扫描并合并他们的结果为一体。此访问方法仅合并来自单个表的索引扫描，而不合并多个表的扫描。合并可以产生其基础扫描的并集，相交或相交。</p>
<p>可能使用索引合并的示例查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> key1 = <span class="number">10</span> <span class="keyword">OR</span> key2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> (key1 = <span class="number">10</span> <span class="keyword">OR</span> key2 = <span class="number">20</span>) <span class="keyword">AND</span> non_key = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1, t2</span><br><span class="line">  <span class="keyword">WHERE</span> (t1.key1 <span class="keyword">IN</span> (<span class="number">1</span>,<span class="number">2</span>) <span class="keyword">OR</span> t1.key2 <span class="keyword">LIKE</span> <span class="string">'value%'</span>)</span><br><span class="line">  <span class="keyword">AND</span> t2.key1 = t1.some_col;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1, t2</span><br><span class="line">  <span class="keyword">WHERE</span> t1.key1 = <span class="number">1</span></span><br><span class="line">  <span class="keyword">AND</span> (t2.key1 = t1.some_col <span class="keyword">OR</span> t2.key2 = t1.some_col2);</span><br></pre></td></tr></table></figure>

<p>注意</p>
<p>索引合并优化算法具有以下已知限制：</p>
<ul>
<li><p>如果您的查询包含<code>WHERE</code> 带有深度<a href="https://dev.mysql.com/doc/refman/5.7/en/logical-operators.html#operator_and" target="_blank" rel="noopener"><code>AND</code></a>/ <a href="https://dev.mysql.com/doc/refman/5.7/en/logical-operators.html#operator_or" target="_blank" rel="noopener"><code>OR</code></a> 嵌套的复杂子句， 而MySQL没有选择最佳计划，请尝试使用以下身份转换来分发术语：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(x AND y) OR z =&gt; (x OR z) AND (y OR z)</span><br><span class="line">(x OR y) AND z =&gt; (x AND z) OR (y AND z)</span><br></pre></td></tr></table></figure>
</li>
<li><p>索引合并不适用于全文索引。</p>
</li>
</ul>
<p>在<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>输出中，索引合并方法出现 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_index_merge" target="_blank" rel="noopener"><code>index_merge</code></a>在 <code>type</code>列中。在这种情况下，该 <code>key</code>列包含使用的索引列表，并<code>key_len</code>包含这些索引的最长键部分的列表。</p>
<p>索引合并访问方法具有几种算法，这些算法显示在输出<code>Extra</code>字段中 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>：</p>
<ul>
<li><code>Using intersect(...)</code></li>
<li><code>Using union(...)</code></li>
<li><code>Using sort_union(...)</code></li>
</ul>
<p>以下各节将更详细地描述这些算法。优化程序根据各种可用选项的成本估算，在可能的索引合并算法和其他访问方法之间进行选择。</p>
<p>索引合并的使用是受价值 <code>index_merge</code>， <code>index_merge_intersection</code>， <code>index_merge_union</code>，和 <code>index_merge_sort_union</code>该旗 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_optimizer_switch" target="_blank" rel="noopener"><code>optimizer_switch</code></a>系统变量。请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/switchable-optimizations.html" target="_blank" rel="noopener">第8.9.2节“可切换的优化”</a>。默认情况下，所有这些标志均为<code>on</code>。要仅启用某些算法，请将设置<code>index_merge</code>为 <code>off</code>，并仅启用应允许的其他算法。</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/index-merge-optimization.html#index-merge-intersection" target="_blank" rel="noopener">索引合并路口访问算法</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/index-merge-optimization.html#index-merge-union" target="_blank" rel="noopener">索引合并联合访问算法</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/index-merge-optimization.html#index-merge-sort-union" target="_blank" rel="noopener">索引合并排序联合访问算法</a></li>
</ul>
<h5 id="索引合并路口访问算法"><a href="#索引合并路口访问算法" class="headerlink" title="索引合并路口访问算法"></a>索引合并路口访问算法</h5><p>当<code>WHERE</code>子句在与键组合在一起的不同键上转换为多个范围条件 <a href="https://dev.mysql.com/doc/refman/5.7/en/logical-operators.html#operator_and" target="_blank" rel="noopener"><code>AND</code></a>，并且每个条件是以下条件之一时，此访问算法适用 ：</p>
<ul>
<li><p><em>N</em>此形式 的-part表达式，其中索引具有完全相同的 <em>N</em>部分（即，所有索引部分均被覆盖）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key_part1 = const1 AND key_part2 = const2 ... AND key_partN = constN</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>InnoDB</code>表 主键上的任何范围条件 。</p>
</li>
</ul>
<p>例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> innodb_table</span><br><span class="line">  <span class="keyword">WHERE</span> primary_key &lt; <span class="number">10</span> <span class="keyword">AND</span> key_col1 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> key1_part1 = <span class="number">1</span> <span class="keyword">AND</span> key1_part2 = <span class="number">2</span> <span class="keyword">AND</span> key2 = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>索引合并交集算法对所有使用的索引执行同时扫描，并生成从合并索引扫描中接收到的行序列的交集。</p>
<p>如果查询中使用的所有列都被使用的索引覆盖，则不会检索完整的表行（ 在这种情况下，<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>输出包含 <code>Using index</code>在<code>Extra</code>字段中）。这是此类查询的示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> key1 = <span class="number">1</span> <span class="keyword">AND</span> key2 = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>如果使用的索引未覆盖查询中使用的所有列，则仅在满足所有使用的键的范围条件时才检索完整行。</p>
<p>如果合并的条件之一是<code>InnoDB</code>表主键上的条件，则该条件不用于行检索，而是用于过滤出使用其他条件检索的行。</p>
<h5 id="索引合并联合访问算法"><a href="#索引合并联合访问算法" class="headerlink" title="索引合并联合访问算法"></a>索引合并联合访问算法</h5><p>此算法的标准类似于索引合并交集算法的标准。当表的<code>WHERE</code> 子句在与键组合在一起的不同键上转换为多个范围条件<a href="https://dev.mysql.com/doc/refman/5.7/en/logical-operators.html#operator_or" target="_blank" rel="noopener"><code>OR</code></a>，并且每个条件为以下条件之一时，该算法适用：</p>
<ul>
<li><p><em>N</em>此形式 的-part表达式，其中索引具有完全相同的 <em>N</em>部分（即，所有索引部分均被覆盖）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key_part1 = const1 AND key_part2 = const2 ... AND key_partN = constN</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>InnoDB</code>表 主键上的任何范围条件 。</p>
</li>
<li><p>索引合并交集算法适用的条件。</p>
</li>
</ul>
<p>例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1</span><br><span class="line">  <span class="keyword">WHERE</span> key1 = <span class="number">1</span> <span class="keyword">OR</span> key2 = <span class="number">2</span> <span class="keyword">OR</span> key3 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> innodb_table</span><br><span class="line">  <span class="keyword">WHERE</span> (key1 = <span class="number">1</span> <span class="keyword">AND</span> key2 = <span class="number">2</span>)</span><br><span class="line">     <span class="keyword">OR</span> (key3 = <span class="string">'foo'</span> <span class="keyword">AND</span> key4 = <span class="string">'bar'</span>) <span class="keyword">AND</span> key5 = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<h5 id="索引合并排序联合访问算法"><a href="#索引合并排序联合访问算法" class="headerlink" title="索引合并排序联合访问算法"></a>索引合并排序联合访问算法</h5><p>当将<code>WHERE</code>子句转换为由组合的多个范围条件 时，此访问算法适用 <a href="https://dev.mysql.com/doc/refman/5.7/en/logical-operators.html#operator_or" target="_blank" rel="noopener"><code>OR</code></a>，但索引合并并集算法不适用。</p>
<p>例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> key_col1 &lt; <span class="number">10</span> <span class="keyword">OR</span> key_col2 &lt; <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> (key_col1 &gt; <span class="number">10</span> <span class="keyword">OR</span> key_col2 = <span class="number">20</span>) <span class="keyword">AND</span> nonkey_col = <span class="number">30</span>;</span><br></pre></td></tr></table></figure>

<p>sort-union算法和union算法之间的区别在于，sort-union算法必须首先获取所有行的行ID，然后对它们进行排序，然后再返回任何行。</p>
<h4 id="8-2-1-4发动机状态下推优化"><a href="#8-2-1-4发动机状态下推优化" class="headerlink" title="8.2.1.4发动机状态下推优化"></a>8.2.1.4发动机状态下推优化</h4><p>对于NDB群集，此优化可以消除在群集的数据节点和发出查询的MySQL服务器之间通过网络发送不匹配的行的需求，并且可以将查询的使用速度提高5到10倍（在某些情况下）可以但不使用条件下推的地方。</p>
<p>假设NDB群集表定义如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (</span><br><span class="line">    a <span class="built_in">INT</span>,</span><br><span class="line">    b <span class="built_in">INT</span>,</span><br><span class="line">    <span class="keyword">KEY</span>(a)</span><br><span class="line">) <span class="keyword">ENGINE</span>=NDB;</span><br></pre></td></tr></table></figure>

<p>条件下推可用于查询，例如此处显示的查询，其中包括未索引列和常量之间的比较：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a, b <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> b = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>条件下推的使用可以在以下输出中看到 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT a,b FROM t1 WHERE b = 10\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: t1</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 10</span><br><span class="line">        Extra: Using where <span class="keyword">with</span> pushed condition</span><br></pre></td></tr></table></figure>

<p>但是，条件下推<em>不能</em>与以下两个查询之一一起使用：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a,b <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">SELECT</span> a,b <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> b + <span class="number">1</span> = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>条件下推不适用于第一个查询，因为column上存在索引<code>a</code>。（索引访问方法将更有效，因此将优先选择条件下推。）条件下推不能用于第二个查询，因为涉及非索引列的比较 <code>b</code>是间接的。（但是，如果<code>b + 1 = 10</code>要<code>b = 9</code>在 <code>WHERE</code>条款中减少到条件，则可以应用条件下推。）</p>
<p>使用<code>&gt;</code>或 <code>&lt;</code>运算符将索引列与常量进行比较时，也可以使用条件下推：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT a, b FROM t1 WHERE a &lt; 2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: t1</span><br><span class="line">         type: range</span><br><span class="line">possible_keys: a</span><br><span class="line">          key: a</span><br><span class="line">      key_len: 5</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 2</span><br><span class="line">        Extra: Using where <span class="keyword">with</span> pushed condition</span><br></pre></td></tr></table></figure>

<p>条件下推的其他受支持比较包括：</p>
<ul>
<li><p><code>*column* [NOT] LIKE *pattern*</code></p>
<p><em>pattern</em>必须是包含要匹配模式的字符串文字；有关语法，请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/string-comparison-functions.html" target="_blank" rel="noopener">第12.7.1节“字符串比较函数和运算符”</a>。</p>
</li>
<li><p><code>*column* IS [NOT] NULL</code></p>
</li>
<li><p><code>*column* IN (*value_list*)</code></p>
<p>中的每个项目都<em>value_list</em> 必须是恒定的文字值。</p>
</li>
<li><p><code>*column* BETWEEN *constant1* AND *constant2*</code></p>
<p><em>constant1</em>并且 <em>constant2</em>每个值都必须是恒定的文字值。</p>
</li>
</ul>
<p>在上述列表中的所有情况下，都有可能将条件转换为列与常量之间的一个或多个直接比较的形式。</p>
<p>默认情况下，引擎状态下推处于启用状态。要在服务器启动时禁用它，请设置 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_optimizer_switch" target="_blank" rel="noopener"><code>optimizer_switch</code></a>系统变量。例如，在<code>my.cnf</code>文件中，使用以下几行：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">optimizer_switch</span>=engine_condition_pushdown=<span class="literal">off</span></span><br></pre></td></tr></table></figure>

<p>在运行时，禁用条件下推，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> optimizer_switch=<span class="string">'engine_condition_pushdown=off'</span>;</span><br></pre></td></tr></table></figure>

<p><strong>局限性。</strong>  引擎状态下推受以下限制：</p>
<ul>
<li>条件下推仅受<a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-cluster.html" target="_blank" rel="noopener"><code>NDB</code></a>存储引擎支持 。</li>
<li>列只能与常量进行比较；但是，这包括计算结果为常数的表达式。</li>
<li>比较中使用的列不能是<a href="https://dev.mysql.com/doc/refman/5.7/en/blob.html" target="_blank" rel="noopener"><code>BLOB</code></a>或 <a href="https://dev.mysql.com/doc/refman/5.7/en/blob.html" target="_blank" rel="noopener"><code>TEXT</code></a>类型的任何列 。此排除范围也扩展到<a href="https://dev.mysql.com/doc/refman/5.7/en/json.html" target="_blank" rel="noopener"><code>JSON</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/bit-type.html" target="_blank" rel="noopener"><code>BIT</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/enum.html" target="_blank" rel="noopener"><code>ENUM</code></a>列。</li>
<li>要与列进行比较的字符串值必须使用与列相同的排序规则。</li>
<li>不直接支持联接；涉及多个表的条件将在可能的情况下分别推送。使用扩展<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>输出来确定实际按下了哪些条件。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-extended.html" target="_blank" rel="noopener">第8.8.3节“扩展的EXPLAIN输出格式”</a>。</li>
</ul>
<h4 id="8-2-1-5索引条件下推优化"><a href="#8-2-1-5索引条件下推优化" class="headerlink" title="8.2.1.5索引条件下推优化"></a>8.2.1.5索引条件下推优化</h4><p>索引条件下推（ICP）是MySQL使用索引从表中检索行的情况的优化。如果没有ICP，则存储引擎将遍历索引以在基表中定位行，并将其返回给MySQL服务器，该MySQL服务器将评估<code>WHERE</code>行的条件。启用ICP后，如果<code>WHERE</code>可以仅使用索引中的列来评估部分 条件，则MySQL服务器会将这部分条件压入<code>WHERE</code>条件下降到存储引擎。然后，存储引擎通过使用索引条目来评估推送的索引条件，并且只有在满足此条件的情况下，才从表中读取行。ICP可以减少存储引擎必须访问基表的次数以及MySQL服务器必须访问存储引擎的次数。</p>
<p>索引条件下推优化的适用性取决于以下条件：</p>
<ul>
<li>ICP用于 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_range" target="_blank" rel="noopener"><code>range</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_ref" target="_blank" rel="noopener"><code>ref</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_eq_ref" target="_blank" rel="noopener"><code>eq_ref</code></a>，和 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_ref_or_null" target="_blank" rel="noopener"><code>ref_or_null</code></a>访问方法时，有一个需要访问的全部表行。</li>
<li>ICP可用于<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html" target="_blank" rel="noopener"><code>InnoDB</code></a> 和<a href="https://dev.mysql.com/doc/refman/5.7/en/myisam-storage-engine.html" target="_blank" rel="noopener"><code>MyISAM</code></a>表，包括分区表<code>InnoDB</code>和 <code>MyISAM</code>表。</li>
<li>对于<code>InnoDB</code>表，ICP仅用于二级索引。ICP的目标是减少全行读取的次数，从而减少I / O操作。对于 <code>InnoDB</code>聚集索引，完整的记录已被读入<code>InnoDB</code> 缓冲区。在这种情况下使用ICP不会减少I / O。</li>
<li>在虚拟生成的列上创建的二级索引不支持ICP。<code>InnoDB</code> 支持虚拟生成的列上的二级索引。</li>
<li>不能将引用子查询的条件下推。</li>
<li>涉及存储功能的条件不能下推。存储引擎无法调用存储的功能。</li>
<li>触发条件不能下推。（有关触发条件的信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/subquery-optimization-with-exists.html" target="_blank" rel="noopener">第8.2.2.3节“使用EXISTS策略优化子查询”）</a>。</li>
</ul>
<p>要了解此优化的工作原理，请首先考虑在不使用“索引条件下推”的情况下如何进行索引扫描：</p>
<ol>
<li>获取下一行，首先读取索引元组，然后使用索引元组查找并读取整个表行。</li>
<li>测试<code>WHERE</code>适用于此表的部分条件。根据测试结果接受或拒绝该行。</li>
</ol>
<p>使用“索引条件下推”，扫描将像这样进行：</p>
<ol>
<li>获取下一行的索引元组（而不是整个表行）。</li>
<li>测试<code>WHERE</code>适用于此表的部分条件，并且只能使用索引列进行检查。如果不满足条件，请转到下一行的索引元组。</li>
<li>如果满足条件，请使用索引元组来定位和读取整个表行。</li>
<li>测试<code>WHERE</code> 适用于此表的条件的其余部分。根据测试结果接受或拒绝该行。</li>
</ol>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>当使用“索引条件下推”时，输出将显示 <code>Using index condition</code>在 <code>Extra</code>列中。它不会显示，<code>Using index</code> 因为在必须读取整个表行时，该方法不适用。</p>
<p>假设一个表包含有关人员及其地址的信息，并且该表的索引定义为 <code>INDEX (zipcode, lastname, firstname)</code>。如果我们知道一个人的<code>zipcode</code>价值，但不确定姓氏，可以这样搜索：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> people</span><br><span class="line">  <span class="keyword">WHERE</span> zipcode=<span class="string">'95054'</span></span><br><span class="line">  <span class="keyword">AND</span> lastname <span class="keyword">LIKE</span> <span class="string">'%etrunia%'</span></span><br><span class="line">  <span class="keyword">AND</span> address <span class="keyword">LIKE</span> <span class="string">'%Main Street%'</span>;</span><br></pre></td></tr></table></figure>

<p>MySQL可以使用索引扫描具有的人员 <code>zipcode=&#39;95054&#39;</code>。第二部分（<code>lastname LIKE &#39;%etrunia%&#39;</code>）不能用于限制必须扫描的行数，因此，如果没有“索引条件下推”，此查询必须为所有具有的人员检索完整的表行 <code>zipcode=&#39;95054&#39;</code>。</p>
<p>通过“索引条件下推”，MySQL <code>lastname LIKE &#39;%etrunia%&#39;</code>在读取整个表行之前会检查该 部分。这样可以避免读取与<code>zipcode</code>条件而不是 <code>lastname</code>条件匹配的索引元组对应的完整行 。</p>
<p>默认情况下，索引条件下推处于启用状态。可以<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_optimizer_switch" target="_blank" rel="noopener"><code>optimizer_switch</code></a>通过设置<code>index_condition_pushdown</code>标志使用系统变量 进行控制 ：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> optimizer_switch = <span class="string">'index_condition_pushdown=off'</span>;</span><br><span class="line"><span class="keyword">SET</span> optimizer_switch = <span class="string">'index_condition_pushdown=on'</span>;</span><br></pre></td></tr></table></figure>

<p>请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/switchable-optimizations.html" target="_blank" rel="noopener">第8.9.2节“可切换的优化”</a>。</p>
<h4 id="8-2-1-6嵌套循环联接算法"><a href="#8-2-1-6嵌套循环联接算法" class="headerlink" title="8.2.1.6嵌套循环联接算法"></a>8.2.1.6嵌套循环联接算法</h4><ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/nested-loop-joins.html#nested-loop-join-algorithm" target="_blank" rel="noopener">嵌套循环联接算法</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/nested-loop-joins.html#block-nested-loop-join-algorithm" target="_blank" rel="noopener">块嵌套循环加入算法</a></li>
</ul>
<h5 id="嵌套循环联接算法"><a href="#嵌套循环联接算法" class="headerlink" title="嵌套循环联接算法"></a>嵌套循环联接算法</h5><p>一个简单的嵌套循环联接（NLJ）算法一次从一个循环中的第一个表中读取行，然后将每一行传递给一个嵌套循环，该循环处理联接中的下一个表。重复此过程的次数与要连接的表的次数相同。</p>
<p>假设将使用以下联接类型执行三个表<code>t1</code>，<code>t2</code>和 之间的 <code>t3</code>联接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Table   Join Type</span><br><span class="line">t1      range</span><br><span class="line">t2      ref</span><br><span class="line">t3      ALL</span><br></pre></td></tr></table></figure>

<p>如果使用简单的NLJ算法，则按以下方式处理联接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for each row in t1 matching range &#123;</span><br><span class="line">  for each row in t2 matching reference key &#123;</span><br><span class="line">    for each row in t3 &#123;</span><br><span class="line">      if row satisfies join conditions, send to client</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为NLJ算法一次将行从外循环传递到内循环，所以它通常读取多次在内循环中处理的表。</p>
<h5 id="块嵌套循环加入算法"><a href="#块嵌套循环加入算法" class="headerlink" title="块嵌套循环加入算法"></a>块嵌套循环加入算法</h5><p>块嵌套循环（BNL）嵌套算法使用对在外部循环中读取的行的缓冲来减少必须读取内部循环中的表的次数。例如，如果将10行读入缓冲区并将缓冲区传递到下一个内部循环，则可以将内部循环中读取的每一行与缓冲区中的所有10行进行比较。这将内部表必须读取的次数减少了一个数量级。</p>
<p>MySQL连接缓冲具有以下特征：</p>
<ul>
<li>当连接的类型为<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_all" target="_blank" rel="noopener"><code>ALL</code></a>或时 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_index" target="_blank" rel="noopener"><code>index</code></a>（换句话说，无法使用可能的键，并且分别对数据行或索引行进行完全扫描 时），可以使用连接缓冲 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_range" target="_blank" rel="noopener"><code>range</code></a>。缓冲的使用也适用于外部联接，如<a href="https://dev.mysql.com/doc/refman/5.7/en/bnl-bka-optimization.html" target="_blank" rel="noopener">第8.2.1.11节“阻止嵌套循环和批处理键访问联接”中所述</a>。</li>
<li>连接缓冲区永远不会分配给第一个非恒定表，即使它的类型是 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_all" target="_blank" rel="noopener"><code>ALL</code></a>或 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_index" target="_blank" rel="noopener"><code>index</code></a>。</li>
<li>联接中只有感兴趣的列存储在其联接缓冲区中，而不是整个行。</li>
<li>的<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_join_buffer_size" target="_blank" rel="noopener"><code>join_buffer_size</code></a> 系统变量来确定每个的大小联接缓冲液用于处理查询。</li>
<li>为每个可以缓冲的连接分配一个缓冲区，因此可以使用多个连接缓冲区来处理给定查询。</li>
<li>在执行连接之前分配连接缓冲区，并在查询完成后释放连接缓冲区。</li>
</ul>
<p>对于先前为NLJ算法（无缓冲）描述的示例连接，使用连接缓冲按如下方式进行连接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">for each row in t1 matching range &#123;</span><br><span class="line">  for each row in t2 matching reference key &#123;</span><br><span class="line">    store used columns from t1, t2 in join buffer</span><br><span class="line">    if buffer is full &#123;</span><br><span class="line">      for each row in t3 &#123;</span><br><span class="line">        for each t1, t2 combination in join buffer &#123;</span><br><span class="line">          if row satisfies join conditions, send to client</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      empty join buffer</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if buffer is not empty &#123;</span><br><span class="line">  for each row in t3 &#123;</span><br><span class="line">    for each t1, t2 combination in join buffer &#123;</span><br><span class="line">      if row satisfies join conditions, send to client</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<em>S</em>是每个所存储的大小 <code>t1</code>，<code>t2</code>在组合联接缓冲液和<em>C</em>在缓冲器中的组合的数量，次表的数量<code>t3</code>被扫描的是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(S * C)&#x2F;join_buffer_size + 1</span><br></pre></td></tr></table></figure>

<p>数<code>t3</code>扫描降低为价值<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_join_buffer_size" target="_blank" rel="noopener"><code>join_buffer_size</code></a> 时增加，最高可达点 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_join_buffer_size" target="_blank" rel="noopener"><code>join_buffer_size</code></a>是大到足以容纳所有上一行组合。那时，通过增大它无法获得任何速度。</p>
<h4 id="8-2-1-7嵌套联接优化"><a href="#8-2-1-7嵌套联接优化" class="headerlink" title="8.2.1.7嵌套联接优化"></a>8.2.1.7嵌套联接优化</h4><p>表达联接的语法允许嵌套联接。以下讨论参考<a href="https://dev.mysql.com/doc/refman/5.7/en/join.html" target="_blank" rel="noopener">第13.2.9.2节“ JOIN子句”中</a>描述的<a href="https://dev.mysql.com/doc/refman/5.7/en/join.html" target="_blank" rel="noopener">联接</a>语法 。</p>
<p><em>table_factor</em>与SQL标准相比，的 语法得到了扩展。后者仅接受<em>table_reference</em>，而不接受一对括号内的列表。如果我们将<em>table_reference</em>项目列表中的每个逗号都视为等效于内部联接，则这是一个保守的扩展 。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> (t2, t3, t4)</span><br><span class="line">                 <span class="keyword">ON</span> (t2.a=t1.a <span class="keyword">AND</span> t3.b=t1.b <span class="keyword">AND</span> t4.c=t1.c)</span><br></pre></td></tr></table></figure>

<p>等效于：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> (t2 <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> t3 <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> t4)</span><br><span class="line">                 <span class="keyword">ON</span> (t2.a=t1.a <span class="keyword">AND</span> t3.b=t1.b <span class="keyword">AND</span> t4.c=t1.c)</span><br></pre></td></tr></table></figure>

<p>在MySQL中，<code>CROSS JOIN</code>在语法上等效于<code>INNER JOIN</code>;; 他们可以互相替换。在标准SQL中，它们不是等效的。 <code>INNER JOIN</code>与<code>ON</code>子句一起使用 ；<code>CROSS JOIN</code>否则使用。</p>
<p>通常，在仅包含内部联接操作的联接表达式中可以忽略括号。考虑以下联接表达式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t1 LEFT JOIN (t2 LEFT JOIN t3 ON t2.b=t3.b OR t2.b IS NULL)</span><br><span class="line">   ON t1.a=t2.a</span><br></pre></td></tr></table></figure>

<p>在除去括号和左侧的分组操作之后，该join表达式将转换为该表达式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(t1 LEFT JOIN t2 ON t1.a=t2.a) LEFT JOIN t3</span><br><span class="line">    ON t2.b=t3.b OR t2.b IS NULL</span><br></pre></td></tr></table></figure>

<p>但是，这两种表达方式并不相等。看到这一点，假设表<code>t1</code>， <code>t2</code>以及<code>t3</code>具有以下状态：</p>
<ul>
<li>表格<code>t1</code>包含行 <code>(1)</code>，<code>(2)</code></li>
<li>表<code>t2</code>包含行 <code>(1,101)</code></li>
<li>表<code>t3</code>包含行 <code>(101)</code></li>
</ul>
<p>在这种情况下，第一个表达式返回结果集包括行<code>(1,1,101,101)</code>， <code>(2,NULL,NULL,NULL)</code>，而第二表达式返回的行<code>(1,1,101,101)</code>， <code>(2,NULL,NULL,101)</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT *</span><br><span class="line">       FROM t1</span><br><span class="line">            LEFT JOIN</span><br><span class="line">            (t2 LEFT JOIN t3 ON t2.b=t3.b OR t2.b IS NULL)</span><br><span class="line">            ON t1.a=t2.a;</span><br><span class="line">+<span class="comment">------+------+------+------+</span></span><br><span class="line">| a    | a    | b    | b    |</span><br><span class="line">+<span class="comment">------+------+------+------+</span></span><br><span class="line">|    1 |    1 |  101 |  101 |</span><br><span class="line">|    2 | NULL | NULL | NULL |</span><br><span class="line">+<span class="comment">------+------+------+------+</span></span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT *</span><br><span class="line">       FROM (t1 LEFT JOIN t2 ON t1.a=t2.a)</span><br><span class="line">            LEFT JOIN t3</span><br><span class="line">            ON t2.b=t3.b OR t2.b IS NULL;</span><br><span class="line">+<span class="comment">------+------+------+------+</span></span><br><span class="line">| a    | a    | b    | b    |</span><br><span class="line">+<span class="comment">------+------+------+------+</span></span><br><span class="line">|    1 |    1 |  101 |  101 |</span><br><span class="line">|    2 | NULL | NULL |  101 |</span><br><span class="line">+<span class="comment">------+------+------+------+</span></span><br></pre></td></tr></table></figure>

<p>在以下示例中，将外部联接操作与内部联接操作一起使用：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t1 LEFT JOIN (t2, t3) ON t1.a=t2.a</span><br></pre></td></tr></table></figure>

<p>该表达式不能转换为以下表达式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t1 LEFT JOIN t2 ON t1.a=t2.a, t3</span><br></pre></td></tr></table></figure>

<p>对于给定的表状态，两个表达式返回不同的行集：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT *</span><br><span class="line">       FROM t1 LEFT JOIN (t2, t3) ON t1.a=t2.a;</span><br><span class="line">+<span class="comment">------+------+------+------+</span></span><br><span class="line">| a    | a    | b    | b    |</span><br><span class="line">+<span class="comment">------+------+------+------+</span></span><br><span class="line">|    1 |    1 |  101 |  101 |</span><br><span class="line">|    2 | NULL | NULL | NULL |</span><br><span class="line">+<span class="comment">------+------+------+------+</span></span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT *</span><br><span class="line">       FROM t1 LEFT JOIN t2 ON t1.a=t2.a, t3;</span><br><span class="line">+<span class="comment">------+------+------+------+</span></span><br><span class="line">| a    | a    | b    | b    |</span><br><span class="line">+<span class="comment">------+------+------+------+</span></span><br><span class="line">|    1 |    1 |  101 |  101 |</span><br><span class="line">|    2 | NULL | NULL |  101 |</span><br><span class="line">+<span class="comment">------+------+------+------+</span></span><br></pre></td></tr></table></figure>

<p>因此，如果我们在使用外部联接运算符的联接表达式中省略括号，则可能会更改原始表达式的结果集。</p>
<p>更确切地说，我们不能忽略左外部联接操作的右操作数和右联接操作的左操作数的括号。换句话说，我们不能忽略外部联接操作的内部表表达式的括号。另一个操作数（外部表的操作数）的括号可以忽略。</p>
<p>下面的表达式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(t1,t2) LEFT JOIN t3 ON P(t2.b,t3.b)</span><br></pre></td></tr></table></figure>

<p>对于任何表<code>t1,t2,t3</code>以及<code>P</code>属性<code>t2.b</code> 和条件上的任何条件 ，该表达式均等效于此表达式 <code>t3.b</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t1, t2 LEFT JOIN t3 ON P(t2.b,t3.b)</span><br></pre></td></tr></table></figure>

<p>每当连接表达式（<em>joined_table</em>）中的连接操作执行顺序不是从左到右时，我们都在谈论嵌套连接。考虑以下查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> (t2 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> t3 <span class="keyword">ON</span> t2.b=t3.b) <span class="keyword">ON</span> t1.a=t2.a</span><br><span class="line">  <span class="keyword">WHERE</span> t1.a &gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> (t2, t3) <span class="keyword">ON</span> t1.a=t2.a</span><br><span class="line">  <span class="keyword">WHERE</span> (t2.b=t3.b <span class="keyword">OR</span> t2.b <span class="keyword">IS</span> <span class="literal">NULL</span>) <span class="keyword">AND</span> t1.a &gt; <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这些查询被认为包含以下嵌套联接：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t2 LEFT JOIN t3 ON t2.b=t3.b</span><br><span class="line">t2, t3</span><br></pre></td></tr></table></figure>

<p>在第一个查询中，嵌套联接是通过左联接操作形成的。在第二个查询中，它是通过内部联接操作形成的。</p>
<p>在第一个查询中，可以省略括号：联接表达式的语法结构将规定联接操作的执行顺序。对于第二个查询，尽管可以在没有括号的情况下明确地解释此处的联接表达式，但是不能省略括号。在我们的扩展语法中，<code>(t2, t3)</code>第二个查询的括号是必需的，尽管从理论上讲可以在没有括号的情况下对其进行解析：由于查询<code>LEFT JOIN</code>并<code>ON</code> 在表达式的左右定界符中扮演着角色，因此查询仍然具有明确的语法结构<code>(t2,t3)</code>。</p>
<p>前面的示例说明了以下几点：</p>
<ul>
<li>对于仅涉及内部联接（而不涉及外部联接）的联接表达式，可以删除括号并从左到右评估联接。实际上，可以按任何顺序评估表。</li>
<li>通常，对于外部联接或与内部联接混合的外部联接，情况并非如此。删除括号可能会改变结果。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> T1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> T2 <span class="keyword">ON</span> P1(T1,T2)</span><br><span class="line">                 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> T3 <span class="keyword">ON</span> P2(T2,T3)</span><br><span class="line">  <span class="keyword">WHERE</span> P(T1,T2,T3)</span><br></pre></td></tr></table></figure>

<p>在这里，<code>P1(T1,T2)</code>和 <code>P2(T3,T3)</code>是一些连接条件（在表达式上），而是<code>P(T1,T2,T3)</code>在table的列上的条件<code>T1,T2,T3</code>。</p>
<p>嵌套循环联接算法将以以下方式执行此查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FOR each row t1 in T1 &#123;</span><br><span class="line">  FOR each row t2 in T2 such that P1(t1,t2) &#123;</span><br><span class="line">    FOR each row t3 in T3 such that P2(t2,t3) &#123;</span><br><span class="line">      IF P(t1,t2,t3) &#123;</span><br><span class="line">         t:&#x3D;t1||t2||t3; OUTPUT t;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>符号<code>t1||t2||t3</code>表示通过连接的行的列构成的行 <code>t1</code>，<code>t2</code>和 <code>t3</code>。在以下某些示例中， <code>NULL</code>出现表名的地方表示该表<code>NULL</code>的每一列都使用一行。例如，<code>t1||t2||NULL</code> 表示通过将行<code>t1</code>和的列<code>t2</code>以及 <code>NULL</code>的每一列 串联而构成的行<code>t3</code>。据说这样的行是 <code>NULL</code>互补的。</p>
<p>现在考虑带有嵌套外部联接的查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> T1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span></span><br><span class="line">              (T2 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> T3 <span class="keyword">ON</span> P2(T2,T3))</span><br><span class="line">              <span class="keyword">ON</span> P1(T1,T2)</span><br><span class="line">  <span class="keyword">WHERE</span> P(T1,T2,T3)</span><br></pre></td></tr></table></figure>

<p>对于此查询，修改嵌套循环模式以获得：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">FOR each row t1 in T1 &#123;</span><br><span class="line">  BOOL f1:&#x3D;FALSE;</span><br><span class="line">  FOR each row t2 in T2 such that P1(t1,t2) &#123;</span><br><span class="line">    BOOL f2:&#x3D;FALSE;</span><br><span class="line">    FOR each row t3 in T3 such that P2(t2,t3) &#123;</span><br><span class="line">      IF P(t1,t2,t3) &#123;</span><br><span class="line">        t:&#x3D;t1||t2||t3; OUTPUT t;</span><br><span class="line">      &#125;</span><br><span class="line">      f2&#x3D;TRUE;</span><br><span class="line">      f1&#x3D;TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    IF (!f2) &#123;</span><br><span class="line">      IF P(t1,t2,NULL) &#123;</span><br><span class="line">        t:&#x3D;t1||t2||NULL; OUTPUT t;</span><br><span class="line">      &#125;</span><br><span class="line">      f1&#x3D;TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  IF (!f1) &#123;</span><br><span class="line">    IF P(t1,NULL,NULL) &#123;</span><br><span class="line">      t:&#x3D;t1||NULL||NULL; OUTPUT t;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常，对于外部联接操作中第一个内部表的任何嵌套循环，都会引入一个标志，该标志在循环前关闭并在循环后检查。当针对外部表中的当前行找到表示内部操作数的表中的匹配项时，将打开该标志。如果在循环周期结束时该标志仍处于关闭状态，则未找到外部表的当前行的匹配项。在这种情况下，该行由<code>NULL</code>内部表的列的值补充 。结果行将传递到输出的最终检查项或下一个嵌套循环，但前提是该行满足所有嵌入式外部联接的联接条件。</p>
<p>在该示例中，嵌入了以下表达式表示的外部联接表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(T2 LEFT JOIN T3 ON P2(T2,T3))</span><br></pre></td></tr></table></figure>

<p>对于具有内部联接的查询，优化器可以选择不同顺序的嵌套循环，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FOR each row t3 in T3 &#123;</span><br><span class="line">  FOR each row t2 in T2 such that P2(t2,t3) &#123;</span><br><span class="line">    FOR each row t1 in T1 such that P1(t1,t2) &#123;</span><br><span class="line">      IF P(t1,t2,t3) &#123;</span><br><span class="line">         t:&#x3D;t1||t2||t3; OUTPUT t;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于具有外部联接的查询，优化器只能选择以下顺序：外部表的循环优先于内部表的循环。因此，对于带有外部联接的查询，只能使用一个嵌套顺序。对于以下查询，优化器将评估两个不同的嵌套。在这两个嵌套中， <code>T1</code>必须在外部循环中进行处理，因为它在外部联接中使用。<code>T2</code>和 <code>T3</code>在内部联接中使用，因此联接必须在内部循环中处理。但是，由于联接是内部联接，<code>T2</code>因此 <code>T3</code>可以按任何顺序进行处理。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * T1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> (T2,T3) <span class="keyword">ON</span> P1(T1,T2) <span class="keyword">AND</span> P2(T1,T3)</span><br><span class="line">  <span class="keyword">WHERE</span> P(T1,T2,T3)</span><br></pre></td></tr></table></figure>

<p>一个嵌套计算<code>T2</code>，然后 <code>T3</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FOR each row t1 in T1 &#123;</span><br><span class="line">  BOOL f1:&#x3D;FALSE;</span><br><span class="line">  FOR each row t2 in T2 such that P1(t1,t2) &#123;</span><br><span class="line">    FOR each row t3 in T3 such that P2(t1,t3) &#123;</span><br><span class="line">      IF P(t1,t2,t3) &#123;</span><br><span class="line">        t:&#x3D;t1||t2||t3; OUTPUT t;</span><br><span class="line">      &#125;</span><br><span class="line">      f1:&#x3D;TRUE</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  IF (!f1) &#123;</span><br><span class="line">    IF P(t1,NULL,NULL) &#123;</span><br><span class="line">      t:&#x3D;t1||NULL||NULL; OUTPUT t;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个嵌套计算<code>T3</code>，则 <code>T2</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FOR each row t1 in T1 &#123;</span><br><span class="line">  BOOL f1:&#x3D;FALSE;</span><br><span class="line">  FOR each row t3 in T3 such that P2(t1,t3) &#123;</span><br><span class="line">    FOR each row t2 in T2 such that P1(t1,t2) &#123;</span><br><span class="line">      IF P(t1,t2,t3) &#123;</span><br><span class="line">        t:&#x3D;t1||t2||t3; OUTPUT t;</span><br><span class="line">      &#125;</span><br><span class="line">      f1:&#x3D;TRUE</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  IF (!f1) &#123;</span><br><span class="line">    IF P(t1,NULL,NULL) &#123;</span><br><span class="line">      t:&#x3D;t1||NULL||NULL; OUTPUT t;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在讨论内部联接的嵌套循环算法时，我们省略了一些细节，这些细节对查询执行性能的影响可能很大。我们没有提到所谓的 “ 下推 ”条件。假设我们的 <code>WHERE</code>条件 <code>P(T1,T2,T3)</code>可以用一个联合公式表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P(T1,T2,T2) &#x3D; C1(T1) AND C2(T2) AND C3(T3).</span><br></pre></td></tr></table></figure>

<p>在这种情况下，MySQL实际上使用以下嵌套循环算法通过内部联接执行查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FOR each row t1 in T1 such that C1(t1) &#123;</span><br><span class="line">  FOR each row t2 in T2 such that P1(t1,t2) AND C2(t2)  &#123;</span><br><span class="line">    FOR each row t3 in T3 such that P2(t2,t3) AND C3(t3) &#123;</span><br><span class="line">      IF P(t1,t2,t3) &#123;</span><br><span class="line">         t:&#x3D;t1||t2||t3; OUTPUT t;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你看，每个合取的<code>C1(T1)</code>， <code>C2(T2)</code>，<code>C3(T3)</code>是最内环的推到最外环的地方进行评估。如果<code>C1(T1)</code>是非常严格的条件，则此条件下推可能会大大减少表中<code>T1</code> 传递给内部循环的行数。结果，查询的执行时间可以大大改善。</p>
<p>对于具有外部联接的查询，<code>WHERE</code> 仅在发现外部表的当前行在内部表中具有匹配项之后，才检查条件。因此，将条件从内部嵌套循环中推出的优化不能直接应用于具有外部联接的查询。在这里，我们必须引入条件下推谓词，该条件下推谓词由遇到匹配时打开的标志保护。</p>
<p>回想一下带有外部联接的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P(T1,T2,T3)&#x3D;C1(T1) AND C(T2) AND C3(T3)</span><br></pre></td></tr></table></figure>

<p>对于该示例，使用受保护的下推条件的嵌套循环算法如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">FOR each row t1 in T1 such that C1(t1) &#123;</span><br><span class="line">  BOOL f1:&#x3D;FALSE;</span><br><span class="line">  FOR each row t2 in T2</span><br><span class="line">      such that P1(t1,t2) AND (f1?C2(t2):TRUE) &#123;</span><br><span class="line">    BOOL f2:&#x3D;FALSE;</span><br><span class="line">    FOR each row t3 in T3</span><br><span class="line">        such that P2(t2,t3) AND (f1&amp;&amp;f2?C3(t3):TRUE) &#123;</span><br><span class="line">      IF (f1&amp;&amp;f2?TRUE:(C2(t2) AND C3(t3))) &#123;</span><br><span class="line">        t:&#x3D;t1||t2||t3; OUTPUT t;</span><br><span class="line">      &#125;</span><br><span class="line">      f2&#x3D;TRUE;</span><br><span class="line">      f1&#x3D;TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    IF (!f2) &#123;</span><br><span class="line">      IF (f1?TRUE:C2(t2) &amp;&amp; P(t1,t2,NULL)) &#123;</span><br><span class="line">        t:&#x3D;t1||t2||NULL; OUTPUT t;</span><br><span class="line">      &#125;</span><br><span class="line">      f1&#x3D;TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  IF (!f1 &amp;&amp; P(t1,NULL,NULL)) &#123;</span><br><span class="line">      t:&#x3D;t1||NULL||NULL; OUTPUT t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常，可以从诸如<code>P1(T1,T2)</code>和的 连接条件中提取下推谓词<code>P(T2,T3)</code>。在这种情况下，下推谓词也由一个标志来保护，该标志防止检查谓词中是否存在<code>NULL</code>由相应外部联接操作生成的-补行。</p>
<p>如果是由<code>WHERE</code>条件谓词引起的，则禁止通过一个键在同一个嵌套联接中从一个内部表访问另一个内部表。</p>
<h4 id="8-2-1-8外部联接优化"><a href="#8-2-1-8外部联接优化" class="headerlink" title="8.2.1.8外部联接优化"></a>8.2.1.8外部联接优化</h4><p>MySQL实现如下： <code>*A* LEFT JOIN *B* *join_specification*</code></p>
<ul>
<li>表<em>B</em>被设置为依赖于表<em>A</em>以及所依赖的所有表 <em>A</em>。</li>
<li>表格<em>A</em>被设置为取决于条件<em>B</em>中使用的所有表格（除外）<code>LEFT JOIN</code>。</li>
<li>该<code>LEFT JOIN</code>条件用于确定如何从table中检索行 <em>B</em>。（换句话说，<code>WHERE</code>不使用该子句中的任何条件。）</li>
<li>执行所有标准的连接优化，不同之处在于始终在表所依赖的所有表之后读取该表。如果存在循环依赖关系，则会发生错误。</li>
<li><code>WHERE</code>执行 所有标准优化。</li>
<li>如果一行中<em>A</em>有匹配该<code>WHERE</code>子句的行，但其中没有一行<em>B</em>与<code>ON</code>条件匹配的行，则将 <em>B</em>生成一个额外的 行，并将所有列都设置为<code>NULL</code>。</li>
<li>如果<code>LEFT JOIN</code>用于查找某张表中不存在的行，并且进行了以下测试：<code>*col_name* IS NULL</code>在该<code>WHERE</code>部分中，<em>col_name</em>声明为的列在哪里 <code>NOT NULL</code>，MySQL在找到后停止搜索更多行（针对特定的键组合）符合<code>LEFT JOIN</code>条件的一行。</li>
</ul>
<p>该<code>RIGHT JOIN</code>实现类似于<code>LEFT JOIN</code>表角色相反的实现。如<a href="https://dev.mysql.com/doc/refman/5.7/en/outer-join-simplification.html" target="_blank" rel="noopener">第8.2.1.9节“简化外部连接”</a>所述，将右连接转换为等效的左连接。</p>
<p>对于<code>LEFT JOIN</code>，如果 <code>WHERE</code>条件对于生成的<code>NULL</code>行始终为false ，则将<code>LEFT JOIN</code>其更改为内部联接。例如， <code>WHERE</code>如果条款是在下面的查询错误的<code>t2.column1</code>是 <code>NULL</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> t2 <span class="keyword">ON</span> (column1) <span class="keyword">WHERE</span> t2.column2=<span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>因此，将查询转换为内部联接是安全的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1, t2 <span class="keyword">WHERE</span> t2.column2=<span class="number">5</span> <span class="keyword">AND</span> t1.column1=t2.column1;</span><br></pre></td></tr></table></figure>



<p>现在，如果这样做会导致更好的查询计划，那么优化器可以先使用表，<code>t2</code>然后使用表<code>t1</code>。要提供有关表连接顺序的提示，请使用<code>STRAIGHT_JOIN</code>；请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener">第13.2.9节“ SELECT语句”</a>。但是，<code>STRAIGHT_JOIN</code>由于它禁用了半联接转换，因此 可能会阻止使用索引。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/semijoins.html" target="_blank" rel="noopener">第8.2.2.1节“使用半联接转换优化子查询，派生表和视图引用”</a>。</p>
<h4 id="8-2-1-9外部联接简化"><a href="#8-2-1-9外部联接简化" class="headerlink" title="8.2.1.9外部联接简化"></a>8.2.1.9外部联接简化</h4><p><code>FROM</code>在许多情况下，查询子句中的 表表达式都得到了简化。</p>
<p>在解析器阶段，具有右外部联接操作的查询将转换为仅包含左联接操作的等效查询。在一般情况下，执行转换时要进行以下右连接：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(T1, ...) RIGHT JOIN (T2, ...) ON P(T1, ..., T2, ...)</span><br></pre></td></tr></table></figure>

<p>成为以下等效的左联接：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(T2, ...) LEFT JOIN (T1, ...) ON P(T1, ..., T2, ...)</span><br></pre></td></tr></table></figure>

<p>形式的所有内部联接表达式<code>T1 INNER JOIN T2 ON P(T1,T2)</code>都由list替换 <code>T1,T2</code>，<code>P(T1,T2)</code>作为<code>WHERE</code>条件（或嵌入联接的联接条件，如果有）的联接而联接。</p>
<p>当优化程序评估外部联接操作的计划时，它仅考虑计划，其中对于每个此类操作，在访问内部表之前访问外部表。由于只有这样的计划才能使用嵌套循环算法执行外部联接，因此优化器的选择受到限制。</p>
<p>考虑这种形式的查询，其中<code>R(T2)</code> 大大缩小了table中匹配行的数量 <code>T2</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * T1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> T2 <span class="keyword">ON</span> P1(T1,T2)</span><br><span class="line">  <span class="keyword">WHERE</span> P(T1,T2) <span class="keyword">AND</span> R(T2)</span><br></pre></td></tr></table></figure>

<p>如果查询以书面形式执行，则优化器别无选择，只能在限制程度<code>T1</code>更高的表之前访问限制程度较小的 表 <code>T2</code>，这可能会产生效率很低的执行计划。</p>
<p>相反，如果<code>WHERE</code>条件为空，则MySQL将查询转换为无外部联接操作的查询。（也就是说，它将外部联接转换为内部联接。）如果条件求值<code>FALSE</code>或<code>UNKNOWN</code>为该<code>NULL</code>操作生成的任何 互补行，则条件被认为是null拒绝 的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T1 LEFT JOIN T2 ON T1.A=T2.A</span><br></pre></td></tr></table></figure>

<p>诸如此类的条件将被拒绝为null，因为它们对于任何<code>NULL</code>补行（ <code>T2</code>列设置为<code>NULL</code>）都无法成立：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T2.B IS NOT NULL</span><br><span class="line">T2.B &gt; 3</span><br><span class="line">T2.C &lt;= T1.C</span><br><span class="line">T2.B &lt; 2 OR T2.C &gt; 1</span><br></pre></td></tr></table></figure>

<p>诸如此类的条件不能为空，因为它们对于<code>NULL</code>-补行可能是正确的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T2.B IS NULL</span><br><span class="line">T1.B &lt; 3 OR T2.B IS NOT NULL</span><br><span class="line">T1.B &lt; 3 OR T2.B &gt; 3</span><br></pre></td></tr></table></figure>

<p>检查外部联接操作的条件是否为空的通用规则很简单：</p>
<ul>
<li>它的形式为<code>A IS NOT NULL</code>，其中哪里 <code>A</code>是任何内部表的属性</li>
<li>这是一个谓词，包含对内部表的引用，该内部表的求值是<code>UNKNOWN</code>何时其参数之一为<code>NULL</code></li>
<li>它是一个包含空值拒绝条件作为连接词的连接词</li>
<li>它是零值拒绝条件的析取</li>
</ul>
<p>对于查询中的一个外部联接操作，条件可以为null拒绝，而对于另一项则不能为null。在此查询中，<code>WHERE</code>第二个外部联接操作的条件为空，但第一个条件的条件为空：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> T1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> T2 <span class="keyword">ON</span> T2.A=T1.A</span><br><span class="line">                 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> T3 <span class="keyword">ON</span> T3.B=T1.B</span><br><span class="line">  <span class="keyword">WHERE</span> T3.C &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>如果<code>WHERE</code>查询中的外部联接操作拒绝该条件为空，则将外部联接操作替换为内部联接操作。</p>
<p>例如，在前面的查询中，第二个外部联接被拒绝为空，并且可以由内部联接代替：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> T1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> T2 <span class="keyword">ON</span> T2.A=T1.A</span><br><span class="line">                 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> T3 <span class="keyword">ON</span> T3.B=T1.B</span><br><span class="line">  <span class="keyword">WHERE</span> T3.C &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>对于原始查询，优化器仅评估与单个表访问顺序兼容的计划 <code>T1,T2,T3</code>。对于重写的查询，它还会考虑访问顺序 <code>T3,T1,T2</code>。</p>
<p>一种外部联接操作的转换可能触发另一种外部联接操作的转换。因此，查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> T1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> T2 <span class="keyword">ON</span> T2.A=T1.A</span><br><span class="line">                 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> T3 <span class="keyword">ON</span> T3.B=T2.B</span><br><span class="line">  <span class="keyword">WHERE</span> T3.C &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>首先转换为查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> T1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> T2 <span class="keyword">ON</span> T2.A=T1.A</span><br><span class="line">                 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> T3 <span class="keyword">ON</span> T3.B=T2.B</span><br><span class="line">  <span class="keyword">WHERE</span> T3.C &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>相当于查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> (T1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> T2 <span class="keyword">ON</span> T2.A=T1.A), T3</span><br><span class="line">  <span class="keyword">WHERE</span> T3.C &gt; <span class="number">0</span> <span class="keyword">AND</span> T3.B=T2.B</span><br></pre></td></tr></table></figure>

<p>其余的外部联接操作也可以由内部联接代替，因为该条件<code>T3.B=T2.B</code> 被拒绝为空。这导致根本没有外部联接的查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> (T1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> T2 <span class="keyword">ON</span> T2.A=T1.A), T3</span><br><span class="line">  <span class="keyword">WHERE</span> T3.C &gt; <span class="number">0</span> <span class="keyword">AND</span> T3.B=T2.B</span><br></pre></td></tr></table></figure>

<p>有时，优化器成功替换了嵌入的外部联接操作，但是无法转换嵌入的外部联接。以下查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> T1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span></span><br><span class="line">              (T2 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> T3 <span class="keyword">ON</span> T3.B=T2.B)</span><br><span class="line">              <span class="keyword">ON</span> T2.A=T1.A</span><br><span class="line">  <span class="keyword">WHERE</span> T3.C &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>转换为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> T1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span></span><br><span class="line">              (T2 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> T3 <span class="keyword">ON</span> T3.B=T2.B)</span><br><span class="line">              <span class="keyword">ON</span> T2.A=T1.A</span><br><span class="line">  <span class="keyword">WHERE</span> T3.C &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>只能将其重写为仍包含嵌入外部联接操作的表单：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> T1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span></span><br><span class="line">              (T2,T3)</span><br><span class="line">              <span class="keyword">ON</span> (T2.A=T1.A <span class="keyword">AND</span> T3.B=T2.B)</span><br><span class="line">  <span class="keyword">WHERE</span> T3.C &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>在查询中转换嵌入式外部联接操作的任何尝试都必须考虑将外部联接嵌入条件的联接 <code>WHERE</code>条件。在此查询中，<code>WHERE</code>嵌入的外部联接的 条件不为空，但嵌入外部联接的联接条件<code>T2.A=T1.A AND T3.C=T1.C</code>为空：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> T1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span></span><br><span class="line">              (T2 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> T3 <span class="keyword">ON</span> T3.B=T2.B)</span><br><span class="line">              <span class="keyword">ON</span> T2.A=T1.A <span class="keyword">AND</span> T3.C=T1.C</span><br><span class="line">  <span class="keyword">WHERE</span> T3.D &gt; <span class="number">0</span> <span class="keyword">OR</span> T1.D &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>因此，查询可以转换为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> T1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span></span><br><span class="line">              (T2, T3)</span><br><span class="line">              <span class="keyword">ON</span> T2.A=T1.A <span class="keyword">AND</span> T3.C=T1.C <span class="keyword">AND</span> T3.B=T2.B</span><br><span class="line">  <span class="keyword">WHERE</span> T3.D &gt; <span class="number">0</span> <span class="keyword">OR</span> T1.D &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="8-2-1-10多范围读取优化"><a href="#8-2-1-10多范围读取优化" class="headerlink" title="8.2.1.10多范围读取优化"></a>8.2.1.10多范围读取优化</h4><p>多范围读取优化具有以下优点：</p>
<ul>
<li>MRR使基于索引元组的数据行可以顺序访问，而不是以随机顺序访问。服务器获取一组满足查询条件的索引元组，并根据数据行ID顺序对它们进行排序，然后使用排序后的元组按顺序检索数据行。这使得数据访问更加高效且成本更低。</li>
<li>MRR支持对需要通过索引元组访问数据行的操作（例如范围索引扫描和使用索引作为联接属性的等联接）进行键访问请求的批处理。MRR在一系列索引范围内进行迭代以获得合格的索引元组。随着这些结果的累积，它们将用于访问相应的数据行。开始读取数据行之前不必获取所有索引元组。</li>
</ul>
<p>在虚拟生成的列上创建的二级索引不支持MRR优化。 <code>InnoDB</code>支持虚拟生成的列上的二级索引。</p>
<p>以下方案说明了MRR优化何时可以发挥优势：</p>
<p>方案A：MRR可用于<code>InnoDB</code>和 <code>MyISAM</code>索引范围扫描和表相等联接的操作。</p>
<ol>
<li>索引元组的一部分累积在缓冲区中。</li>
<li>缓冲区中的元组按其数据行ID排序。</li>
<li>根据排序的索引元组序列访问数据行。</li>
</ol>
<p>方案B：MRR可用于 <a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-cluster.html" target="_blank" rel="noopener"><code>NDB</code></a>表以进行多范围索引扫描，或在按属性执行等值联接时使用。</p>
<ol>
<li>一部分范围（可能是单键范围）累积在提交查询的中心节点上的缓冲区中。</li>
<li>范围被发送到访问数据行的执行节点。</li>
<li>被访问的行被打包到程序包中并发送回中心节点。</li>
<li>收到的带有数据行的数据包将放置在缓冲区中。</li>
<li>从缓冲区读取数据行。</li>
</ol>
<p>使用MRR时<code>Extra</code>，<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>输出中的列 显示 <code>Using MRR</code>。</p>
<p><code>InnoDB``MyISAM</code>如果不需要访问整个表行以产生查询结果，则不要使用MRR。如果可以完全根据索引元组中的信息（通过<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_covering_index" target="_blank" rel="noopener">覆盖索引</a>）产生结果，则为这种情况；MRR没有任何好处。</p>
<p>两个<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_optimizer_switch" target="_blank" rel="noopener"><code>optimizer_switch</code></a>系统变量标志提供了使用MRR优化的接口。该<code>mrr</code>标志控制是否启用MRR。如果<code>mrr</code>启用（<code>on</code>），则该<code>mrr_cost_based</code> 标志控制优化程序是尝试在使用MRR与不使用MRR之间做出基于成本的选择（<code>on</code>）还是在可能的情况下使用MRR（<code>off</code>）。默认情况下，<code>mrr</code> is <code>on</code>和<code>mrr_cost_based</code> is <code>on</code>。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/switchable-optimizations.html" target="_blank" rel="noopener">第8.9.2节“可切换的优化”</a>。</p>
<p>对于MRR，存储引擎将<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_read_rnd_buffer_size" target="_blank" rel="noopener"><code>read_rnd_buffer_size</code></a>系统变量的值 用作可为其缓冲区分配多少内存的准则。引擎最多使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_read_rnd_buffer_size" target="_blank" rel="noopener"><code>read_rnd_buffer_size</code></a>字节，并确定一次处理要处理的范围数。</p>
<h4 id="8-2-1-11块嵌套循环和批处理密钥访问联接"><a href="#8-2-1-11块嵌套循环和批处理密钥访问联接" class="headerlink" title="8.2.1.11块嵌套循环和批处理密钥访问联接"></a>8.2.1.11块嵌套循环和批处理密钥访问联接</h4><p>以下各节讨论基于原始BNL算法，扩展的BNL算法和BKA算法的扩展的连接缓冲区管理。有关半联接策略的信息，请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/semijoins.html" target="_blank" rel="noopener">第8.2.2.1节“使用半联接转换优化子查询，派生表和视图引用”</a></p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/bnl-bka-optimization.html#join-buffer-management" target="_blank" rel="noopener">用于块嵌套循环和批处理密钥访问算法的联接缓冲区管理</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/bnl-bka-optimization.html#bnl-optimization" target="_blank" rel="noopener">外部联接和半联接的块嵌套循环算法</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/bnl-bka-optimization.html#bka-optimization" target="_blank" rel="noopener">批量密钥访问联接</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/bnl-bka-optimization.html#bnl-bka-optimizer-hints" target="_blank" rel="noopener">块嵌套循环和批处理密钥访问算法的优化器提示</a></li>
</ul>
<h5 id="用于块嵌套循环和批处理密钥访问算法的联接缓冲区管理"><a href="#用于块嵌套循环和批处理密钥访问算法的联接缓冲区管理" class="headerlink" title="用于块嵌套循环和批处理密钥访问算法的联接缓冲区管理"></a>用于块嵌套循环和批处理密钥访问算法的联接缓冲区管理</h5><p>MySQL可以使用联接缓冲区来执行内部联接，而无需内部索引访问内部表，还可以执行在子查询展平后出现的外部联接和半联接。此外，当对内部表进行索引访问时，可以有效地使用连接缓冲区。</p>
<p>在存储感兴趣的行列的值时，连接缓冲区管理代码可以更有效地利用连接缓冲区空间：如果行列的值为，则不会在缓冲区中为行列分配其他字节 <code>NULL</code>，并且为的任何值分配最小字节数。该 <a href="https://dev.mysql.com/doc/refman/5.7/en/char.html" target="_blank" rel="noopener"><code>VARCHAR</code></a>类型。</p>
<p>该代码支持两种类型的缓冲区：常规缓冲区和增量缓冲区。假设使用了连接缓冲区<code>B1</code> 来连接表<code>t1</code>， <code>t2</code>并且<code>t3</code>使用连接缓冲区将该操作的结果与表连接 <code>B2</code>：</p>
<ul>
<li>常规连接缓冲区包含每个连接操作数中的列。如果<code>B2</code>是常规联接缓冲区，则<em>r</em>放入的 每一行<code>B2</code>都由<em>r1</em>from <code>B1</code>中的一行的列<em>r2</em>和table中 匹配的行的有趣的列组成<code>t3</code>。</li>
<li>增量连接缓冲区仅包含第二个连接操作数产生的表行中的列。也就是说，它从第一个操作数缓冲区递增到一行。如果<code>B2</code>是增量连接缓冲区，则它包含该行的有趣列以及从 <em>r2</em> 到该行的链接 。 <em>r1</em><code>B1</code></li>
</ul>
<p>增量连接缓冲区始终相对于来自较早连接操作的连接缓冲区是增量的，因此，第一次连接操作中的缓冲区始终是常规缓冲区。在刚才的例子中，缓冲<code>B1</code> 用来连接表<code>t1</code>和 <code>t2</code>必须是常规缓冲区。</p>
<p>用于联接操作的增量缓冲区的每一行仅包含要联接表中一行的有趣列。这些列通过引用第一个连接操作数产生的表中匹配行的有趣列来进行扩充。<em>r</em>只要所有这些行与row匹配，增量缓冲区中的几行就可以引用同一行，该行 的列存储在先前的联接缓冲区中 <em>r</em>。</p>
<p>增量缓冲区使从以前的联接操作所使用的缓冲区中复制列的频率降低。这样可以节省缓冲区空间，因为通常情况下，第一个连接操作数产生的行可以与第二个连接操作数产生的几行匹配。不必从第一个操作数复制一行。由于减少了复制时间，因此增量缓冲区还可以节省处理时间。</p>
<p>系统变量 的<code>block_nested_loop</code>和 <code>batched_key_access</code>标志 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_optimizer_switch" target="_blank" rel="noopener"><code>optimizer_switch</code></a>控制优化器如何使用“块嵌套循环”和“批处理键访问”联接算法。默认情况下，<code>block_nested_loop</code>is <code>on</code>和 <code>batched_key_access</code>is <code>off</code>。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/switchable-optimizations.html" target="_blank" rel="noopener">第8.9.2节“可切换的优化”</a>。优化程序提示也可能适用；请参阅 <a href="https://dev.mysql.com/doc/refman/5.7/en/bnl-bka-optimization.html#bnl-bka-optimizer-hints" target="_blank" rel="noopener">块嵌套循环和批处理密钥访问算法的优化器提示</a>。</p>
<p>有关半联接策略的信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/semijoins.html" target="_blank" rel="noopener">第8.2.2.1节“使用半联接转换优化子查询，派生表和视图引用”</a></p>
<h5 id="外部联接和半联接的块嵌套循环算法"><a href="#外部联接和半联接的块嵌套循环算法" class="headerlink" title="外部联接和半联接的块嵌套循环算法"></a>外部联接和半联接的块嵌套循环算法</h5><p>当使用连接缓冲区执行这些操作时，放入缓冲区的每一行都将提供一个匹配标志。</p>
<p>如果使用联接缓冲区执行外部联接操作，则检查第二个操作数产生的表的每一行是否与联接缓冲区中的每一行匹配。找到匹配项后，将形成一个新的扩展行（原始行加上第二个操作数的列），并通过其余的join操作发送以进行进一步扩展。另外，启用缓冲区中匹配行的匹配标志。在检查了要连接的表的所有行之后，将扫描连接缓冲区。缓冲区中未启用匹配标志的每一行都以<code>NULL</code>补码（<code>NULL</code> 第二个操作数中每一列的值），并通过其余的联接操作发送以进行进一步扩展。</p>
<p>系统变量 的<code>block_nested_loop</code>标志 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_optimizer_switch" target="_blank" rel="noopener"><code>optimizer_switch</code></a>控制优化器如何使用块嵌套循环算法。默认情况下 <code>block_nested_loop</code>为 <code>on</code>。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/switchable-optimizations.html" target="_blank" rel="noopener">第8.9.2节“可切换的优化”</a>。优化程序提示也可能适用；请参阅 <a href="https://dev.mysql.com/doc/refman/5.7/en/bnl-bka-optimization.html#bnl-bka-optimizer-hints" target="_blank" rel="noopener">块嵌套循环和批处理密钥访问算法的优化器提示</a>。</p>
<p>在<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>输出端，为表使用BNL的当被所指<code>Extra</code> 值包含<code>Using join buffer (Block Nested Loop)</code>与所述<code>type</code>值是 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_all" target="_blank" rel="noopener"><code>ALL</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_index" target="_blank" rel="noopener"><code>index</code></a>，或 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_range" target="_blank" rel="noopener"><code>range</code></a>。</p>
<p>在某些情况下，涉及一个或多个子查询与一个或多个左联接的组合，尤其是返回许多行的联接，可能会使用BNL，即使在这种情况下并不理想。这是一个已知问题，已在MySQL 8.0中修复。如果升级MySQL对您来说不是立即可行的，那么您可能希望同时通过设置<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_optimizer_switch" target="_blank" rel="noopener"><code>optimizer_switch=&#39;block_nested_loop=off&#39;</code></a> 或使用<a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-table-level" target="_blank" rel="noopener"><code>NO_BNL</code></a> 优化程序提示来禁用BNL，以 使用一个或多个索引提示让优化程序选择更好的计划（请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/index-hints.html" target="_blank" rel="noopener">第8.9.4节“索引”提示”</a>）或这些的某种组合，以提高此类查询的性能。</p>
<p>有关半联接策略的信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/semijoins.html" target="_blank" rel="noopener">第8.2.2.1节“使用半联接转换优化子查询，派生表和视图引用”</a></p>
<h5 id="批量密钥访问联接"><a href="#批量密钥访问联接" class="headerlink" title="批量密钥访问联接"></a>批量密钥访问联接</h5><p>使用BKA时，的值 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_join_buffer_size" target="_blank" rel="noopener"><code>join_buffer_size</code></a>定义对存储引擎的每个请求中的批量密钥。缓冲区越大，连接操作右侧表的顺序访问就越多，这可以显着提高性能。</p>
<p>要使用BKA，必须将系统变量的 <code>batched_key_access</code>标志 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_optimizer_switch" target="_blank" rel="noopener"><code>optimizer_switch</code></a>设置为<code>on</code>。BKA使用MRR，因此<code>mrr</code>标记也必须为 <code>on</code>。当前，MRR的成本估算过于悲观。因此，也有必要对 <code>mrr_cost_based</code>要 <code>off</code>用于要使用的BKA。以下设置启用BKA：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET optimizer_switch='mrr=on,mrr_cost_based=off,batched_key_access=on';</span><br></pre></td></tr></table></figure>

<p>执行MRR功能有两种方案：</p>
<ul>
<li>第一种方案用于传统的基于磁盘的存储引擎，例如 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html" target="_blank" rel="noopener"><code>InnoDB</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/myisam-storage-engine.html" target="_blank" rel="noopener"><code>MyISAM</code></a>。对于这些引擎，通常将来自连接缓冲区的所有行的键一次提交到MRR接口。特定于引擎的MRR函数对提交的键执行索引查找，从它们中获取行ID（或主键），然后根据BKA算法的请求为所有这些选定的行ID逐个获取行。返回的每一行都有一个关联引用，该关联引用允许访问连接缓冲区中的匹配行。通过MRR函数以最佳方式获取行：按照行ID（主键）顺序获取行。由于读取是按磁盘顺序而不是随机顺序进行的，因此可以提高性能。</li>
<li>第二种情况用于远程存储引擎，例如<a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-cluster.html" target="_blank" rel="noopener"><code>NDB</code></a>。MySQL服务器（SQL节点）将来自连接缓冲区的一部分行的键及其相关联的密钥包发送到NDB Cluster数据节点。作为回报，SQL节点接收匹配行的包（或几个包）以及相应的关联。BKA联接算法采用这些行并构建新的联接行。然后，将一组新的密钥发送到数据节点，并将返回的包中的行用于构建新的联接行。该过程一直持续到将来自联接缓冲区的最后一个键发送到数据节点，并且SQL节点已接收并联接了与这些键匹配的所有行。</li>
</ul>
<p>在第一种情况下，保留了一部分连接缓冲区来存储由索引查找选择并作为参数传递给MRR函数的行ID（主键）。</p>
<p>没有特殊的缓冲区来存储为连接缓冲区中的行构建的键。而是将为缓冲区中的下一行建立键的函数作为参数传递给MRR函数。</p>
<p>在<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>输出中，当<code>Extra</code> 值包含<code>Using join buffer (Batched Key Access)</code>且<code>type</code>值为 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_ref" target="_blank" rel="noopener"><code>ref</code></a>或 时，表示对表使用BKA <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_eq_ref" target="_blank" rel="noopener"><code>eq_ref</code></a>。</p>
<h5 id="块嵌套循环和批处理密钥访问算法的优化器提示"><a href="#块嵌套循环和批处理密钥访问算法的优化器提示" class="headerlink" title="块嵌套循环和批处理密钥访问算法的优化器提示"></a>块嵌套循环和批处理密钥访问算法的优化器提示</h5><p>除了在整个<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_optimizer_switch" target="_blank" rel="noopener"><code>optimizer_switch</code></a>会话范围内使用 系统变量来控制优化器对BNL和BKA算法的使用之外，MySQL还支持优化器提示，以针对每个语句影响优化器。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html" target="_blank" rel="noopener">第8.9.3节“优化器提示”</a>。</p>
<p>若要使用BNL或BKA提示为外部联接的任何内部表启用联接缓冲，必须为外部联接的所有内部表启用联接缓冲。</p>
<h4 id="8-2-1-12条件过滤"><a href="#8-2-1-12条件过滤" class="headerlink" title="8.2.1.12条件过滤"></a>8.2.1.12条件过滤</h4><p>在联接处理中，前缀行是从联接中的一个表传递到下一个表的那些行。通常，优化程序会尝试在连接顺序的早期放置前缀计数较低的表，以防止行组合的数量迅速增加。在某种程度上，优化器可以使用有关从一个表中选择并传递到下一个表的行的条件的信息，它可以更准确地计算行估计并选择最佳执行计划。</p>
<p>如果不使用条件过滤，则表的前缀行数将基于<code>WHERE</code>子句根据优化程序选择的访问方法估算的行数 。条件过滤使优化器可以<code>WHERE</code>在访问方法未考虑的子句中使用其他相关条件 ，从而改善其前缀行数估计。例如，即使可能存在基于索引的访问方法，该方法可用于从联接中的当前表中选择行，但对于表中的表，也可能存在其他条件。<code>WHERE</code> 子句可以过滤（进一步限制）传递给下一张表的合格行的估计值。</p>
<p>仅在以下情况下，条件才有助于过滤估计：</p>
<ul>
<li>它引用当前表。</li>
<li>它取决于连接序列中一个或多个常量值。</li>
<li>访问方法尚未考虑它。</li>
</ul>
<p>在<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>输出中，该 <code>rows</code>列指示所选访问方法的行估计，并且该<code>filtered</code> 列反映条件过滤的效果。 <code>filtered</code>值以百分比表示。最大值为100，这表示未过滤行。值从100减小表示过滤量增加。</p>
<p>前缀行数（估计从当前表通过联接传递到下一个表的行数）是<code>rows</code>和 <code>filtered</code>值的乘积。即，前缀行数是估计的行数，该估计的行数由于估计的滤波效果而减少。例如，如果<code>rows</code>为1000且<code>filtered</code>为20％，则条件过滤会将估算的行数1000减少为前缀行数1000×20％= 1000×.2 = 200。</p>
<p>考虑以下查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line">  <span class="keyword">FROM</span> employee <span class="keyword">JOIN</span> department <span class="keyword">ON</span> employee.dept_no = department.dept_no</span><br><span class="line">  <span class="keyword">WHERE</span> employee.first_name = <span class="string">'John'</span></span><br><span class="line">  <span class="keyword">AND</span> employee.hire_date <span class="keyword">BETWEEN</span> <span class="string">'2018-01-01'</span> <span class="keyword">AND</span> <span class="string">'2018-06-01'</span>;</span><br></pre></td></tr></table></figure>

<p>假设数据集具有以下特征：</p>
<ul>
<li><p>该<code>employee</code>表有1024行。</p>
</li>
<li><p>该<code>department</code>表有12行。</p>
</li>
<li><p>两个表在上都有一个索引<code>dept_no</code>。</p>
</li>
<li><p>该<code>employee</code>表的索引为 <code>first_name</code>。</p>
</li>
<li><p>8行满足以下条件 <code>employee.first_name</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">employee.first_name = 'John'</span><br></pre></td></tr></table></figure>
</li>
<li><p>150行满足以下条件 <code>employee.hire_date</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">employee.hire_date BETWEEN '2018-01-01' AND '2018-06-01'</span><br></pre></td></tr></table></figure>
</li>
<li><p>1行满足以下两个条件：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">employee.first_name = 'John'</span><br><span class="line">AND employee.hire_date BETWEEN '2018-01-01' AND '2018-06-01'</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>没有条件过滤，将 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>产生如下输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+------------+--------+------------------+---------+---------+------+----------+</span><br><span class="line">| id | table      | type   | possible_keys    | key     | ref     | rows | filtered |</span><br><span class="line">+----+------------+--------+------------------+---------+---------+------+----------+</span><br><span class="line">| 1  | employee   | ref    | name,h_date,dept | name    | const   | 8    | 100.00   |</span><br><span class="line">| 1  | department | eq_ref | PRIMARY          | PRIMARY | dept_no | 1    | 100.00   |</span><br><span class="line">+----+------------+--------+------------------+---------+---------+------+----------+</span><br></pre></td></tr></table></figure>

<p>为此<code>employee</code>，<code>name</code>索引上的访问方法将 拾取与名称匹配的8行<code>&#39;John&#39;</code>。没有进行任何过滤（<code>filtered</code>为100％），因此所有行都是下一张表的前缀行：前缀行计数为 <code>rows</code>× <code>filtered</code>= 8×100％= 8。</p>
<p>通过条件过滤，优化器还可以考虑<code>WHERE</code> 访问方法未考虑的子句中的条件。在这种情况下，优化器使用启发式方法估计<a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_between" target="_blank" rel="noopener"><code>BETWEEN</code></a> 条件为的16.31％的过滤效果<code>employee.hire_date</code>。结果，<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>产生如下输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+------------+--------+------------------+---------+---------+------+----------+</span><br><span class="line">| id | table      | type   | possible_keys    | key     | ref     | rows | filtered |</span><br><span class="line">+----+------------+--------+------------------+---------+---------+------+----------+</span><br><span class="line">| 1  | employee   | ref    | name,h_date,dept | name    | const   | 8    | 16.31    |</span><br><span class="line">| 1  | department | eq_ref | PRIMARY          | PRIMARY | dept_no | 1    | 100.00   |</span><br><span class="line">+----+------------+--------+------------------+---------+---------+------+----------+</span><br></pre></td></tr></table></figure>

<p>现在，前缀行计数为<code>rows</code>× <code>filtered</code>= 8×16.31％= 1.3，它更紧密地反映了实际数据集。</p>
<p>通常，优化器不会为最后一个联接表计算条件过滤效果（减少前缀行数），因为没有下一个表可以将行传递给该表。发生以下异常 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>：为了提供更多信息，将为所有联接的表（包括最后一个表）计算过滤效果。</p>
<p>要控制优化器是否考虑其他过滤条件，请使用系统变量的 <code>condition_fanout_filter</code>标志 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_optimizer_switch" target="_blank" rel="noopener"><code>optimizer_switch</code></a>（请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/switchable-optimizations.html" target="_blank" rel="noopener">第8.9.2节“可切换的优化”</a>）。默认情况下，此标志是启用的，但可以禁用它以抑制条件过滤（例如，如果发现特定查询不使用它会产生更好的性能）。</p>
<p>如果优化器高估了条件过滤的效果，则性能可能会比不使用条件过滤的情况差。在这种情况下，这些技术可能会帮助：</p>
<ul>
<li><p>如果未对列进行索引，请对其进行索引，以便优化程序获得有关列值分布的一些信息，并可以改善其行估计。</p>
</li>
<li><p>更改加入顺序。完成此操作的方法包括紧接在和 之后的 <a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html" target="_blank" rel="noopener">联接</a>顺序优化器提示（请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html" target="_blank" rel="noopener">第8.9.3节“优化器提示”</a>） 。 <code>STRAIGHT_JOIN``SELECT``STRAIGHT_JOIN</code></p>
</li>
<li><p>禁用会话的条件过滤：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> optimizer_switch = <span class="string">'condition_fanout_filter=off'</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="8-2-1-13-IS-NULL优化"><a href="#8-2-1-13-IS-NULL优化" class="headerlink" title="8.2.1.13 IS NULL优化"></a>8.2.1.13 IS NULL优化</h4><p>例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> key_col <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> key_col &lt;=&gt; <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> key_col=const1 <span class="keyword">OR</span> key_col=const2 <span class="keyword">OR</span> key_col <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>如果<code>WHERE</code>子句包含声明为的列的 条件，则 该表达式将被优化。如果该列仍然可能产生（例如，如果它来自a右侧的表），则 不会进行此优化。 <em>col_name</em> <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_is-null" target="_blank" rel="noopener"><code>IS NULL</code></a><code>NOT NULL``NULL``LEFT JOIN</code></p>
<p>MySQL还可以优化组合 ，这种形式在已解决的子查询中很常见。 显示 何时使用此优化。 <code>*col_name* = *expr* OR *col_name* IS NULL</code><a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_ref_or_null" target="_blank" rel="noopener"><code>ref_or_null</code></a></p>
<p>此优化可以处理<a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_is-null" target="_blank" rel="noopener"><code>IS NULL</code></a>任何关键部分。</p>
<p>假设在列<code>a</code>和 <code>b</code>表上都有索引，则对查询进行一些优化的示例<code>t2</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> t1.a=expr <span class="keyword">OR</span> t1.a <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1, t2 <span class="keyword">WHERE</span> t1.a=t2.a <span class="keyword">OR</span> t2.a <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1, t2</span><br><span class="line">  <span class="keyword">WHERE</span> (t1.a=t2.a <span class="keyword">OR</span> t2.a <span class="keyword">IS</span> <span class="literal">NULL</span>) <span class="keyword">AND</span> t2.b=t1.b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1, t2</span><br><span class="line">  <span class="keyword">WHERE</span> t1.a=t2.a <span class="keyword">AND</span> (t2.b=t1.b <span class="keyword">OR</span> t2.b <span class="keyword">IS</span> <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1, t2</span><br><span class="line">  <span class="keyword">WHERE</span> (t1.a=t2.a <span class="keyword">AND</span> t2.a <span class="keyword">IS</span> <span class="literal">NULL</span> <span class="keyword">AND</span> ...)</span><br><span class="line">  <span class="keyword">OR</span> (t1.a=t2.a <span class="keyword">AND</span> t2.a <span class="keyword">IS</span> <span class="literal">NULL</span> <span class="keyword">AND</span> ...);</span><br></pre></td></tr></table></figure>

<p><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_ref_or_null" target="_blank" rel="noopener"><code>ref_or_null</code></a>通过首先读取参考键，然后单独搜索具有<code>NULL</code>键值的行来工作。</p>
<p>优化只能处理一个<a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_is-null" target="_blank" rel="noopener"><code>IS NULL</code></a>级别。在以下查询中，MySQL仅在表达式上使用键查找<code>(t1.a=t2.a AND t2.a IS NULL)</code>，而不能在上使用键部分 <code>b</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1, t2</span><br><span class="line">  <span class="keyword">WHERE</span> (t1.a=t2.a <span class="keyword">AND</span> t2.a <span class="keyword">IS</span> <span class="literal">NULL</span>)</span><br><span class="line">  <span class="keyword">OR</span> (t1.b=t2.b <span class="keyword">AND</span> t2.b <span class="keyword">IS</span> <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<h4 id="8-2-1-14优化排序"><a href="#8-2-1-14优化排序" class="headerlink" title="8.2.1.14优化排序"></a>8.2.1.14优化排序</h4><p>一个<code>ORDER BY</code>有和没有 <code>LIMIT</code>可能以不同的顺序返回行，在讨论<a href="https://dev.mysql.com/doc/refman/5.7/en/limit-optimization.html" target="_blank" rel="noopener">第8.2.1.17，“LIMIT查询优化”</a>。</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/order-by-optimization.html#order-by-index-use" target="_blank" rel="noopener">使用索引满足ORDER BY</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/order-by-optimization.html#order-by-filesort" target="_blank" rel="noopener">使用文件排序满足ORDER BY</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/order-by-optimization.html#order-by-optimizer-control" target="_blank" rel="noopener">通过优化影响订单</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/order-by-optimization.html#order-by-diagnostic-information" target="_blank" rel="noopener">ORDER BY执行计划信息可用</a></li>
</ul>
<h5 id="使用索引满足ORDER-BY"><a href="#使用索引满足ORDER-BY" class="headerlink" title="使用索引满足ORDER BY"></a>使用索引满足ORDER BY</h5><p>在某些情况下，MySQL可以使用索引来满足 <code>ORDER BY</code>子句，并避免执行<code>filesort</code> 操作时涉及的额外排序。</p>
<p>即使<code>ORDER BY</code>索引与索引不完全匹配，也可以使用索引，只要索引的所有未使用部分和所有额外的 <code>ORDER BY</code>列在<code>WHERE</code>子句中都是常量即可 。如果索引不包含查询访问的所有列，则仅当索引访问比其他访问方法便宜时才使用索引。</p>
<p>假设在上有一个索引 ，以下查询可以使用该索引来解析 零件。优化程序是否实际这样做取决于如果还必须读取索引中没有的列，则读取索引是否比表扫描更有效。 <code>(*key_part1*, *key_part2*)``ORDER BY</code></p>
<ul>
<li><p>在此查询中，索引on 使优化器避免排序： <code>(*key_part1*, *key_part2*)</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> key_part1, key_part2;</span><br></pre></td></tr></table></figure>

<p>但是，查询使用<code>SELECT *</code>，它可能会选择比<em>key_part1</em>和 多的列 <em>key_part2</em>。在这种情况下，扫描整个索引并查找表行以查找索引中未包含的列可能比扫描表并对结果进行排序要昂贵。如果是这样，优化器可能不会使用索引。如果 <code>SELECT *</code>仅选择索引列，则将使用索引并避免排序。</p>
<p>如果<code>t1</code>是<code>InnoDB</code> 表，则表主键隐式属于索引的一部分，并且该索引可用于解析 <code>ORDER BY</code>此查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> pk, key_part1, key_part2 <span class="keyword">FROM</span> t1</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> key_part1, key_part2;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在此查询中，它<em>key_part1<em>是常量，因此通过索引访问的所有行都是 *key_part2</em>有序的，并且如果子句具有足够的选择性以使索引范围扫描比表扫描便宜，则on的索引可以避免排序： `(*key_part1</em>, <em>key_part2</em>)``WHERE`</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1</span><br><span class="line">  <span class="keyword">WHERE</span> key_part1 = <span class="keyword">constant</span></span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> key_part2;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在接下来的两个查询中，是否使用索引与<code>DESC</code>前面没有显示的相同查询类似 ：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> key_part1 <span class="keyword">DESC</span>, key_part2 <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1</span><br><span class="line">  <span class="keyword">WHERE</span> key_part1 = <span class="keyword">constant</span></span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> key_part2 <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在接下来的两个查询中， <em>key_part1</em>将其与常量进行比较。如果 <code>WHERE</code>子句的选择性足以使索引范围扫描比表扫描便宜，那么将使用索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1</span><br><span class="line">  <span class="keyword">WHERE</span> key_part1 &gt; <span class="keyword">constant</span></span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> key_part1 <span class="keyword">ASC</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1</span><br><span class="line">  <span class="keyword">WHERE</span> key_part1 &lt; <span class="keyword">constant</span></span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> key_part1 <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在下一个查询中，<code>ORDER BY</code>不会命名<em>key_part1</em>，但是所选的所有行都有一个常 <em>key_part1</em>量值，因此仍可以使用索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1</span><br><span class="line">  <span class="keyword">WHERE</span> key_part1 = constant1 <span class="keyword">AND</span> key_part2 &gt; constant2</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> key_part2;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>在某些情况下，MySQL <em>无法</em>使用索引来解析<code>ORDER BY</code>，尽管它仍然可以使用索引来查找与该<code>WHERE</code>子句匹配的行 。例子：</p>
<ul>
<li><p>该查询用于<code>ORDER BY</code>不同的索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> key1, key2;</span><br></pre></td></tr></table></figure>
</li>
<li><p>该查询<code>ORDER BY</code>对索引的非连续部分使用：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> key2=<span class="keyword">constant</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> key1_part1, key1_part3;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询混合<code>ASC</code>和 <code>DESC</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> key_part1 <span class="keyword">DESC</span>, key_part2 <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用于获取行的索引与在中使用的索引不同<code>ORDER BY</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> key2=<span class="keyword">constant</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> key1;</span><br></pre></td></tr></table></figure>
</li>
<li><p>该查询使用<code>ORDER BY</code>的表达式包含除索引列名称以外的术语：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">ABS</span>(<span class="keyword">key</span>);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> -<span class="keyword">key</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>该查询联接了许多表，并且中的列 <code>ORDER BY</code>并非全部来自用于检索行的第一个非恒定表。（这是<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>输出中没有<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_const" target="_blank" rel="noopener"><code>const</code></a>联接类型的第一个表 。）</p>
</li>
<li><p>查询具有<code>ORDER BY</code>和 <code>GROUP BY</code>表达式。</p>
</li>
<li><p>仅在<code>ORDER BY</code>子句中命名的列的前缀上存在索引。在这种情况下，索引不能用于完全解析排序顺序。例如，如果仅<a href="https://dev.mysql.com/doc/refman/5.7/en/char.html" target="_blank" rel="noopener"><code>CHAR(20)</code></a>索引一列的前10个字节，则索引无法区分第10个字节之后的 值，<code>filesort</code>因此需要a。</p>
</li>
<li><p>索引不按顺序存储行。例如，对于表中的<code>HASH</code>索引来说 就是这样<code>MEMORY</code>。</p>
</li>
</ul>
<p>排序别名的可用性可能会受到列别名的使用的影响。假设该列 <code>t1.a</code>已建立索引。在此语句中，选择列表中列的名称为 <code>a</code>。它指的是<code>t1.a</code>，如同在参考<code>a</code>在 <code>ORDER BY</code>，所以上的索引 <code>t1.a</code>可用于：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a <span class="keyword">FROM</span> t1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> a;</span><br></pre></td></tr></table></figure>

<p>在此语句中，选择列表中列的名称也为<code>a</code>，但它是别名。它指的是<code>ABS(a)</code>，如同在参考<code>a</code>在<code>ORDER BY</code>，所以上的索引<code>t1.a</code>不能使用：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ABS</span>(a) <span class="keyword">AS</span> a <span class="keyword">FROM</span> t1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> a;</span><br></pre></td></tr></table></figure>

<p>在下面的语句中，<code>ORDER BY</code> 引用的名称不是选择列表中列的名称。但是<code>t1</code> named中有一个列<code>a</code>，因此可以使用<code>ORDER BY</code>refer <code>t1.a</code>和on上的索引<code>t1.a</code>。（当然，最终的排序顺序可能与的排序顺序完全不同 <code>ABS(a)</code>。）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ABS</span>(a) <span class="keyword">AS</span> b <span class="keyword">FROM</span> t1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> a;</span><br></pre></td></tr></table></figure>



<p>如果查询包括<code>GROUP BY</code>但希望避免对结果进行排序的开销，则可以通过指定来禁止排序<code>ORDER BY NULL</code>。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> foo</span><br><span class="line"><span class="keyword">SELECT</span> a, <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> bar <span class="keyword">GROUP</span> <span class="keyword">BY</span> a <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>优化器可能仍选择使用排序来实现分组操作。<code>ORDER BY NULL</code> 禁止对结果进行排序，而不是通过分组操作确定结果的先前排序。</p>
<h5 id="使用文件排序满足ORDER-BY"><a href="#使用文件排序满足ORDER-BY" class="headerlink" title="使用文件排序满足ORDER BY"></a>使用文件排序满足ORDER BY</h5><p>为了获得用于<code>filesort</code>操作的内存，优化器会预先分配固定数量的 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_sort_buffer_size" target="_blank" rel="noopener"><code>sort_buffer_size</code></a>字节。各个会话可以根据需要更改此变量的会话值，以避免过多的内存使用，或根据需要分配更多的内存。</p>
<p>一个<code>filesort</code>操作使用临时磁盘文件作为必要的，如果结果集是太大，无法在内存中。某些类型的查询特别适合完全内存<code>filesort</code>操作。例如，优化器可用于 <code>filesort</code>高效地在内存中处理<code>ORDER BY</code> 以下形式的查询（和子查询）操作，而无需使用临时文件：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> single_table ... <span class="keyword">ORDER</span> <span class="keyword">BY</span> non_index_column [<span class="keyword">DESC</span>] <span class="keyword">LIMIT</span> [M,]N;</span><br></pre></td></tr></table></figure>

<p>此类查询在Web应用程序中很常见，这些Web应用程序仅显示较大结果集中的几行。例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1, ... <span class="keyword">FROM</span> t1 ... <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">name</span> <span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">SELECT</span> col1, ... <span class="keyword">FROM</span> t1 ... <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">RAND</span>() <span class="keyword">LIMIT</span> <span class="number">15</span>;</span><br></pre></td></tr></table></figure>

<h5 id="通过优化影响订单"><a href="#通过优化影响订单" class="headerlink" title="通过优化影响订单"></a>通过优化影响订单</h5><p>对于未使用的慢<code>ORDER BY</code>查询 <code>filesort</code>，请尝试将<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_max_length_for_sort_data" target="_blank" rel="noopener"><code>max_length_for_sort_data</code></a> 系统变量降低 为适合触发的值 <code>filesort</code>。（将此变量的值设置得太高的症状是磁盘活动过多和CPU活动较低的组合。）</p>
<p>为了提高<code>ORDER BY</code>速度，请检查是否可以让MySQL使用索引而不是额外的排序阶段。如果这不可能，请尝试以下策略：</p>
<ul>
<li><p>增加 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_sort_buffer_size" target="_blank" rel="noopener"><code>sort_buffer_size</code></a> 变量值。理想情况下，该值应足够大以使整个结果集适合排序缓冲区（以避免写入磁盘和合并过程），但该值至少必须足够大以容纳15个元组。（最多合并15个临时磁盘文件，并且每个文件中至少必须有一个元组在内存中。）</p>
<p>考虑到存储在排序缓冲区中的列值的大小受 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_max_sort_length" target="_blank" rel="noopener"><code>max_sort_length</code></a>系统变量值的影响。例如，如果元组存储长字符串列的值，而您增加的值 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_max_sort_length" target="_blank" rel="noopener"><code>max_sort_length</code></a>，则排序缓冲区元组的大小也会增加，并且可能需要您增加 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_sort_buffer_size" target="_blank" rel="noopener"><code>sort_buffer_size</code></a>。对于由字符串表达式（例如调用字符串值函数的结果）计算出的列值，该<code>filesort</code>算法无法确定表达式值的最大长度，因此必须分配 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_max_sort_length" target="_blank" rel="noopener"><code>max_sort_length</code></a> 每个元组的字节数。</p>
<p>要监视合并次数（合并临时文件），请检查 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-status-variables.html#statvar_Sort_merge_passes" target="_blank" rel="noopener"><code>Sort_merge_passes</code></a> 状态变量。</p>
</li>
<li><p>增加 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_read_rnd_buffer_size" target="_blank" rel="noopener"><code>read_rnd_buffer_size</code></a> 变量值，以便一次读取更多行。</p>
</li>
<li><p>更改<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_tmpdir" target="_blank" rel="noopener"><code>tmpdir</code></a> 系统变量，使其指向具有大量可用空间的专用文件系统。变量值可以列出以循环方式使用的几个路径。您可以使用此功能将负载分散到多个目录中。<code>:</code>在Unix上，路径用冒号（）和分号（<code>;</code>）分隔。路径应命名位于不同<em>物理</em>磁盘上的文件系统中的目录 ，而不是同一磁盘上的不同分区。</p>
</li>
</ul>
<h5 id="ORDER-BY执行计划信息可用"><a href="#ORDER-BY执行计划信息可用" class="headerlink" title="ORDER BY执行计划信息可用"></a>ORDER BY执行计划信息可用</h5><p>使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a> （请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/using-explain.html" target="_blank" rel="noopener">第8.8.1节“使用EXPLAIN优化查询”</a>），可以检查MySQL是否可以使用索引来解析<code>ORDER BY</code>子句：</p>
<ul>
<li>如果输出的<code>Extra</code>列 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>不包含<code>Using filesort</code>，则使用索引，<code>filesort</code>而不执行a。</li>
<li>如果输出<code>Extra</code>列 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>包含 <code>Using filesort</code>，则不使用索引并<code>filesort</code>执行a。</li>
</ul>
<p>另外，如果<code>filesort</code>执行a，则优化器跟踪输出将包含一个 <code>filesort_summary</code>块。例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">"filesort_summary": &#123;</span><br><span class="line">  "rows": 100,</span><br><span class="line">  "examined_rows": 100,</span><br><span class="line">  "number_of_tmp_files": 0,</span><br><span class="line">  "sort_buffer_size": 25192,</span><br><span class="line">  "sort_mode": "&lt;sort_key, packed_additional_fields&gt;"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该<code>sort_mode</code>值提供有关排序缓冲区中元组内容的信息：</p>
<ul>
<li><code>&lt;sort_key, rowid&gt;</code>：这表明排序缓冲区元组是对，包含原始表行的排序键值和行ID。元组按排序键值排序，并且行ID用于从表中读取行。</li>
<li><code>&lt;sort_key, additional_fields&gt;</code>：这表明排序缓冲区元组包含排序键值和查询所引用的列。元组通过排序键值进行排序，并且列值直接从元组中读取。</li>
<li><code>&lt;sort_key, packed_additional_fields&gt;</code>：与以前的变体一样，但其他列紧密地打包在一起，而不是使用固定长度的编码。</li>
</ul>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>不区分优化器是否<code>filesort</code>在内存中执行 。<code>filesort</code>在优化器跟踪输出中可以看到内存的使用 。寻找 <code>filesort_priority_queue_optimization</code>。有关优化程序跟踪的信息，请参见 <a href="https://dev.mysql.com/doc/internals/en/optimizer-tracing.html" target="_blank" rel="noopener">MySQL内部：跟踪优化程序</a>。</p>
<h4 id="8-2-1-15按优化分组"><a href="#8-2-1-15按优化分组" class="headerlink" title="8.2.1.15按优化分组"></a>8.2.1.15按优化分组</h4><p>使用索引的最重要先决条件 <code>GROUP BY</code>是所有<code>GROUP BY</code>列均引用同一索引的属性，并且索引按顺序存储其键（例如，对于<code>BTREE</code>索引而言，这是正确的，但对于索引而言， 这是正确的<code>HASH</code>）。临时表的使用是否可以用索引访问代替，还取决于查询中使用索引的哪些部分，为这些部分指定的条件以及所选的聚合函数。</p>
<p>有两种<code>GROUP BY</code> 通过索引访问执行查询的方法，以下各节将详细介绍。第一种方法将分组操作与所有范围谓词（如果有）一起应用。第二种方法首先执行范围扫描，然后对所得的元组进行分组。</p>
<p>在MySQL中，<code>GROUP BY</code>用于排序，因此服务器也可以将<code>ORDER BY</code> 优化应用于分组。但是，不建议依赖隐式或显式<code>GROUP BY</code>排序。请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/order-by-optimization.html" target="_blank" rel="noopener">第8.2.1.14节“按优化排序”</a>。</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/group-by-optimization.html#loose-index-scan" target="_blank" rel="noopener">松散索引扫描</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/group-by-optimization.html#tight-index-scan" target="_blank" rel="noopener">紧密索引扫描</a></li>
</ul>
<h5 id="松散索引扫描"><a href="#松散索引扫描" class="headerlink" title="松散索引扫描"></a>松散索引扫描</h5><p>最有效的处理方法<code>GROUP BY</code>是使用索引直接检索分组列。通过这种访问方法，MySQL使用键排序的某些索引类型的属性（例如<code>BTREE</code>）。使用此属性，可以在索引中使用查找组，而不必考虑索引中满足所有<code>WHERE</code>条件的所有键 。此访问方法仅考虑索引中的一部分键，因此称为“ 松散索引扫描”。如果没有<code>WHERE</code> 子句，则“松散索引扫描”将读取与组数一样多的键，这可能比所有键的数目小得多。如果<code>WHERE</code>子句包含范围谓词（请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/using-explain.html" target="_blank" rel="noopener">第8.8.1节“使用EXPLAIN优化查询”</a>中对<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_range" target="_blank" rel="noopener"><code>range</code></a>连接类型 的讨论 ），<a href="https://dev.mysql.com/doc/refman/5.7/en/using-explain.html" target="_blank" rel="noopener">“</a>松散索引扫描”将查找满足范围条件的每个组的第一个键，并再次读取最小的可能值按键数。在以下情况下可以这样做：</p>
<ul>
<li>查询是在单个表上。</li>
<li>该<code>GROUP BY</code>唯一名称是构成该指数并没有其他列的最左边的前缀列。（如果<code>GROUP BY</code>查询具有<code>DISTINCT</code>子句，而不是查询，则所有不同的属性均引用构成索引最左前缀的列。）例如，如果表 <code>t1</code>的索引位于 <code>(c1,c2,c3)</code>，则松散索引扫描适用于查询<code>GROUP BY c1, c2</code>。如果查询具有<code>GROUP BY c2, c3</code>（列不是最左边的前缀）或<code>GROUP BY c1, c2, c4</code>（<code>c4</code>不在索引中），则不适用 。</li>
<li>选择列表中使用的唯一聚合函数（如果有）是<a href="https://dev.mysql.com/doc/refman/5.7/en/aggregate-functions.html#function_min" target="_blank" rel="noopener"><code>MIN()</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/aggregate-functions.html#function_max" target="_blank" rel="noopener"><code>MAX()</code></a>，并且它们全部引用同一列。该列必须在索引中，并且必须紧跟在中的列之后 <code>GROUP BY</code>。</li>
<li>索引中除<code>GROUP BY</code>查询中所引用部分以外的任何其他部分都 必须是常量（即必须与常量相等地引用），除了<a href="https://dev.mysql.com/doc/refman/5.7/en/aggregate-functions.html#function_min" target="_blank" rel="noopener"><code>MIN()</code></a>或 <a href="https://dev.mysql.com/doc/refman/5.7/en/aggregate-functions.html#function_max" target="_blank" rel="noopener"><code>MAX()</code></a>函数的参数外 。</li>
<li>对于索引中的列，必须为完整的列值建立索引，而不仅仅是前缀。例如，使用 <code>c1 VARCHAR(20), INDEX (c1(10))</code>，索引仅使用<code>c1</code>值的前缀，而不能用于宽松索引扫描。</li>
</ul>
<p>如果“松散索引扫描”适用于查询，则 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>输出将显示 <code>Using index for group-by</code>在该 <code>Extra</code>列中。</p>
<p>假设<code>idx(c1,c2,c3)</code>table上 有一个索引 <code>t1(c1,c2,c3,c4)</code>。松散索引扫描访问方法可用于以下查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c1, c2 <span class="keyword">FROM</span> t1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> c1, c2;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> c1, c2 <span class="keyword">FROM</span> t1;</span><br><span class="line"><span class="keyword">SELECT</span> c1, <span class="keyword">MIN</span>(c2) <span class="keyword">FROM</span> t1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> c1;</span><br><span class="line"><span class="keyword">SELECT</span> c1, c2 <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c1 &lt; const <span class="keyword">GROUP</span> <span class="keyword">BY</span> c1, c2;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(c3), <span class="keyword">MIN</span>(c3), c1, c2 <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c2 &gt; const <span class="keyword">GROUP</span> <span class="keyword">BY</span> c1, c2;</span><br><span class="line"><span class="keyword">SELECT</span> c2 <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c1 &lt; const <span class="keyword">GROUP</span> <span class="keyword">BY</span> c1, c2;</span><br><span class="line"><span class="keyword">SELECT</span> c1, c2 <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c3 = const <span class="keyword">GROUP</span> <span class="keyword">BY</span> c1, c2;</span><br></pre></td></tr></table></figure>

<p>由于给出的原因，无法使用此快速选择方法执行以下查询：</p>
<ul>
<li><p>除<a href="https://dev.mysql.com/doc/refman/5.7/en/aggregate-functions.html#function_min" target="_blank" rel="noopener"><code>MIN()</code></a>或 之外，还有其他聚合函数 <a href="https://dev.mysql.com/doc/refman/5.7/en/aggregate-functions.html#function_max" target="_blank" rel="noopener"><code>MAX()</code></a>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c1, <span class="keyword">SUM</span>(c2) <span class="keyword">FROM</span> t1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> c1;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>GROUP BY</code>子句中 的列不构成索引的最左前缀：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c1, c2 <span class="keyword">FROM</span> t1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> c2, c3;</span><br></pre></td></tr></table></figure>
</li>
<li><p>该查询指的是键的<code>GROUP BY</code>一部分，该部分位于该部分之后，并且该 部分与常量不相等：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c1, c3 <span class="keyword">FROM</span> t1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> c1, c2;</span><br></pre></td></tr></table></figure>

<p>如果查询包含，则可以使用松散索引扫描。 <code>WHERE c3 = *const*</code></p>
</li>
</ul>
<p>除了已经支持的<a href="https://dev.mysql.com/doc/refman/5.7/en/aggregate-functions.html#function_min" target="_blank" rel="noopener"><code>MIN()</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/aggregate-functions.html#function_max" target="_blank" rel="noopener"><code>MAX()</code></a>引用之外，松散索引扫描访问方法还可以应用于选择列表中的其他形式的聚合函数引用：</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/aggregate-functions.html#function_avg" target="_blank" rel="noopener"><code>AVG(DISTINCT)</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/aggregate-functions.html#function_sum" target="_blank" rel="noopener"><code>SUM(DISTINCT)</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/aggregate-functions.html#function_count" target="_blank" rel="noopener"><code>COUNT(DISTINCT)</code></a>支持。<a href="https://dev.mysql.com/doc/refman/5.7/en/aggregate-functions.html#function_avg" target="_blank" rel="noopener"><code>AVG(DISTINCT)</code></a> 并<a href="https://dev.mysql.com/doc/refman/5.7/en/aggregate-functions.html#function_sum" target="_blank" rel="noopener"><code>SUM(DISTINCT)</code></a>接受一个论点。 <a href="https://dev.mysql.com/doc/refman/5.7/en/aggregate-functions.html#function_count" target="_blank" rel="noopener"><code>COUNT(DISTINCT)</code></a>可以有多个列参数。</li>
<li>查询中 不能有<code>GROUP BY</code>or <code>DISTINCT</code>子句。</li>
<li>先前描述的松散索引扫描限制仍然适用。</li>
</ul>
<p>假设<code>idx(c1,c2,c3)</code>table上 有一个索引 <code>t1(c1,c2,c3,c4)</code>。松散索引扫描访问方法可用于以下查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> c1), <span class="keyword">SUM</span>(<span class="keyword">DISTINCT</span> c1) <span class="keyword">FROM</span> t1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> c1, c2), <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> c2, c1) <span class="keyword">FROM</span> t1;</span><br></pre></td></tr></table></figure>

<h5 id="紧密索引扫描"><a href="#紧密索引扫描" class="headerlink" title="紧密索引扫描"></a>紧密索引扫描</h5><p>紧密索引扫描可以是全索引扫描，也可以是范围索引扫描，具体取决于查询条件。</p>
<p>当不满足宽松索引扫描的条件时，仍然有可能避免创建用于<code>GROUP BY</code>查询的临时表。如果<code>WHERE</code>子句中有范围条件，则此方法仅读取满足这些条件的键。否则，它将执行索引扫描。由于此方法读取该<code>WHERE</code>子句定义的每个范围内的所有键 ，或者在没有范围条件的情况下扫描整个索引，因此称为“ 紧索引扫描”。对于紧密索引扫描，仅在找到所有满足范围条件的键之后才执行分组操作。</p>
<p>为了使这种方法起作用，对于查询中所有引用键部分之前或之间的<code>GROUP BY</code>键的部分，要有一个恒定的相等条件就足够了。来自相等条件的常量会填充 搜索键中的所有“ 间隙 ”，从而可以形成索引的完整前缀。这些索引前缀然后可以用于索引查找。如果<code>GROUP BY</code> 结果需要排序，并且有可能形成作为索引前缀的搜索关键字，MySQL还避免了额外的排序操作，因为在有序索引中使用前缀搜索已经按顺序检索了所有关键字。</p>
<p>假设<code>idx(c1,c2,c3)</code>table上 有一个索引 <code>t1(c1,c2,c3,c4)</code>。以下查询不适用于前面所述的“松散索引扫描”访问方法，但仍适用于“紧索引扫描”访问方法。</p>
<ul>
<li><p>中存在一个缺口<code>GROUP BY</code>，但由以下条件覆盖<code>c2 = &#39;a&#39;</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c1, c2, c3 <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c2 = <span class="string">'a'</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> c1, c3;</span><br></pre></td></tr></table></figure>
</li>
<li><p>的<code>GROUP BY</code>开头不是键的第一部分，但是有一个条件为该部分提供常数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c1, c2, c3 <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c1 = <span class="string">'a'</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> c2, c3;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="8-2-1-16-DISTINCT优化"><a href="#8-2-1-16-DISTINCT优化" class="headerlink" title="8.2.1.16 DISTINCT优化"></a>8.2.1.16 DISTINCT优化</h4><p>因为<code>DISTINCT</code>可能使用<code>GROUP BY</code>，所以了解MySQL如何处理 不属于所选列的<code>ORDER BY</code>or <code>HAVING</code>子句中的列。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/group-by-handling.html" target="_blank" rel="noopener">第12.20.3节“ MySQL BY GROUP BY”</a>。</p>
<p>在大多数情况下，<code>DISTINCT</code>子句可以视为的特殊情况<code>GROUP BY</code>。例如，以下两个查询是等效的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> c1, c2, c3 <span class="keyword">FROM</span> t1</span><br><span class="line"><span class="keyword">WHERE</span> c1 &gt; const;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> c1, c2, c3 <span class="keyword">FROM</span> t1</span><br><span class="line"><span class="keyword">WHERE</span> c1 &gt; const <span class="keyword">GROUP</span> <span class="keyword">BY</span> c1, c2, c3;</span><br></pre></td></tr></table></figure>

<p>由于这种等效性，适用于<code>GROUP BY</code>查询的优化 也可以应用于带有<code>DISTINCT</code>子句的查询。因此，有关<code>DISTINCT</code>查询优化可能性的更多详细信息 ，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/group-by-optimization.html" target="_blank" rel="noopener">第8.2.1.15节“按优化组”</a>。</p>
<p>与 结合使用时 ，MySQL一旦找到唯一的行，就会停止运行 。 <code>LIMIT *row_count*``DISTINCT</code><em>row_count</em></p>
<p>如果您不使用查询中命名的所有表中的列，则MySQL会在找到第一个匹配项后立即停止扫描任何未使用的表。在以下情况下，假设 <code>t1</code>以前使用过<code>t2</code> （您可以通过进行检查 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>），则MySQL <code>t2</code>在<code>t1</code>找到以下内容的第一行时将停止从（对于中的任何特定行） 进行 读取<code>t2</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> t1.a <span class="keyword">FROM</span> t1, t2 <span class="keyword">where</span> t1.a=t2.a;</span><br></pre></td></tr></table></figure>

<h4 id="8-2-1-17-LIMIT查询优化"><a href="#8-2-1-17-LIMIT查询优化" class="headerlink" title="8.2.1.17 LIMIT查询优化"></a>8.2.1.17 LIMIT查询优化</h4><p>MySQL有时会优化具有子句和无 子句的查询： <code>LIMIT *row_count*``HAVING</code></p>
<ul>
<li><p>如果仅使用来选择几行 <code>LIMIT</code>，则在通常情况下，MySQL倾向于使用全表扫描，因此有时会使用索引。</p>
</li>
<li><p>如果与结合使用 ，MySQL会在找到排序结果的第一行后立即停止排序 ，而不是对整个结果进行排序。如果通过使用索引进行排序，这将非常快。如果必须执行文件排序，则在找到第一个之前，将选择所有与查询匹配的不带子句的行，并对其中的大多数或全部进行排序 。找到初始行后，MySQL不会对结果集的其余部分进行排序。 <code>LIMIT *row_count*``ORDER BY</code><em>row_count<em><code>LIMIT</code></em>row_count</em></p>
<p>此行为的一种体现是，<code>ORDER BY</code>带有和不带有 查询的查询 <code>LIMIT</code>可能以不同顺序返回行，如本节后面所述。</p>
</li>
<li><p>如果与结合使用，MySQL 将在 找到唯一行后立即停止。 <code>LIMIT *row_count*``DISTINCT</code><em>row_count</em></p>
</li>
<li><p>在某些情况下，<code>GROUP BY</code>可以通过按顺序读取索引（或对索引进行排序），然后计算汇总直到索引值更改来解决a。在这种情况下，不计算任何不必要的 值。 <code>LIMIT *row_count*``GROUP BY</code></p>
</li>
<li><p>MySQL一旦向客户端发送了所需的行数，它将立即终止查询，除非您正在使用 <code>SQL_CALC_FOUND_ROWS</code>。在这种情况下，可以使用检索行数<code>SELECT FOUND_ROWS()</code>。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/information-functions.html" target="_blank" rel="noopener">第12.15节“信息功能”</a>。</p>
</li>
</ul>
<ul>
<li><p><code>LIMIT 0</code>快速返回一个空集。这对于检查查询的有效性很有用。它也可用于获取使用MySQL API的应用程序中结果列元数据的类型的结果列的类型。在 <a href="https://dev.mysql.com/doc/refman/5.7/en/mysql.html" target="_blank" rel="noopener"><strong>mysql</strong></a>客户端程序中，您可以使用该 <a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-command-options.html#option_mysql_column-type-info" target="_blank" rel="noopener"><code>--column-type-info</code></a>选项显示结果列类型。</p>
</li>
<li><p>如果服务器使用临时表来解析查询，则它将使用该子句来计算所需的空间。 <code>LIMIT *row_count*</code></p>
</li>
<li><p>如果未使用索引，<code>ORDER BY</code> 但<code>LIMIT</code>也存在子句，则优化器可以避免使用合并文件，并使用内存中<code>filesort</code>操作对内存中的行进行排序 。</p>
</li>
</ul>
<p>如果多行在列中具有相同的值<code>ORDER BY</code>，则服务器可以自由以任何顺序返回这些行，并且根据整体执行计划，这样做的方式可能有所不同。换句话说，这些行的排序顺序相对于无序列是不确定的。</p>
<p>影响执行计划的一个因素是 <code>LIMIT</code>，因此<code>ORDER BY</code> 带有和不带有查询的查询<code>LIMIT</code>可能以不同顺序返回行。考虑以下查询，该查询按<code>category</code>列排序，但对于<code>id</code>和 <code>rating</code>列不确定：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM ratings ORDER BY category;</span><br><span class="line">+<span class="comment">----+----------+--------+</span></span><br><span class="line">| id | category | rating |</span><br><span class="line">+<span class="comment">----+----------+--------+</span></span><br><span class="line">|  1 |        1 |    4.5 |</span><br><span class="line">|  5 |        1 |    3.2 |</span><br><span class="line">|  3 |        2 |    3.7 |</span><br><span class="line">|  4 |        2 |    3.5 |</span><br><span class="line">|  6 |        2 |    3.5 |</span><br><span class="line">|  2 |        3 |    5.0 |</span><br><span class="line">|  7 |        3 |    2.7 |</span><br><span class="line">+<span class="comment">----+----------+--------+</span></span><br></pre></td></tr></table></figure>

<p>包含<code>LIMIT</code>可能会影响每个<code>category</code>值中的行顺序。例如，这是一个有效的查询结果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM ratings ORDER BY category LIMIT 5;</span><br><span class="line">+<span class="comment">----+----------+--------+</span></span><br><span class="line">| id | category | rating |</span><br><span class="line">+<span class="comment">----+----------+--------+</span></span><br><span class="line">|  1 |        1 |    4.5 |</span><br><span class="line">|  5 |        1 |    3.2 |</span><br><span class="line">|  4 |        2 |    3.5 |</span><br><span class="line">|  3 |        2 |    3.7 |</span><br><span class="line">|  6 |        2 |    3.5 |</span><br><span class="line">+<span class="comment">----+----------+--------+</span></span><br></pre></td></tr></table></figure>

<p>在每种情况下，行均按<code>ORDER BY</code>列排序，这是SQL标准所需的全部。</p>
<p>如果重要的是要确保带和不带相同的行顺序，请<code>LIMIT</code>在<code>ORDER BY</code>子句中包括其他列以使顺序确定。例如，如果<code>id</code>值是唯一的，则可以通过如下排序使给定<code>category</code>值的行 按<code>id</code>顺序显示 ：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM ratings ORDER BY category, id;</span><br><span class="line">+<span class="comment">----+----------+--------+</span></span><br><span class="line">| id | category | rating |</span><br><span class="line">+<span class="comment">----+----------+--------+</span></span><br><span class="line">|  1 |        1 |    4.5 |</span><br><span class="line">|  5 |        1 |    3.2 |</span><br><span class="line">|  3 |        2 |    3.7 |</span><br><span class="line">|  4 |        2 |    3.5 |</span><br><span class="line">|  6 |        2 |    3.5 |</span><br><span class="line">|  2 |        3 |    5.0 |</span><br><span class="line">|  7 |        3 |    2.7 |</span><br><span class="line">+<span class="comment">----+----------+--------+</span></span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM ratings ORDER BY category, id LIMIT 5;</span><br><span class="line">+<span class="comment">----+----------+--------+</span></span><br><span class="line">| id | category | rating |</span><br><span class="line">+<span class="comment">----+----------+--------+</span></span><br><span class="line">|  1 |        1 |    4.5 |</span><br><span class="line">|  5 |        1 |    3.2 |</span><br><span class="line">|  3 |        2 |    3.7 |</span><br><span class="line">|  4 |        2 |    3.5 |</span><br><span class="line">|  6 |        2 |    3.5 |</span><br><span class="line">+<span class="comment">----+----------+--------+</span></span><br></pre></td></tr></table></figure>

<h4 id="8-2-1-18函数调用优化"><a href="#8-2-1-18函数调用优化" class="headerlink" title="8.2.1.18函数调用优化"></a>8.2.1.18函数调用优化</h4><p>如果某个函数被标记为不确定的，则将<code>WHERE</code>针对每一行（从一个表中选择时）或行的组合（从多表联接中选择时）评估子句中对该函数的引用。</p>
<p>MySQL还根据参数的类型（参数是表列还是常量值）确定何时评估函数。每当表列更改值时，都必须评估将表列作为参数的确定性函数。</p>
<p>非确定性函数可能会影响查询性能。例如，某些优化可能不可用，或者可能需要更多锁定。以下讨论使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/mathematical-functions.html#function_rand" target="_blank" rel="noopener"><code>RAND()</code></a>但也适用于其他不确定性函数。</p>
<p>假设一个表<code>t</code>具有以下定义：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t (<span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span>, col_a <span class="built_in">VARCHAR</span>(<span class="number">100</span>));</span><br></pre></td></tr></table></figure>

<p>考虑以下两个查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="keyword">POW</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="keyword">FLOOR</span>(<span class="number">1</span> + <span class="keyword">RAND</span>() * <span class="number">49</span>);</span><br></pre></td></tr></table></figure>

<p>由于与主键的相等性比较，两个查询似乎都使用了主键查找，但这仅适用于第一个查询：</p>
<ul>
<li>第一个查询始终最多产生一行，因为<a href="https://dev.mysql.com/doc/refman/5.7/en/mathematical-functions.html#function_pow" target="_blank" rel="noopener"><code>POW()</code></a>带有常量参数的常量是一个常量值，并用于索引查找。</li>
<li>第二个查询包含一个使用非确定性函数的表达式，该表达式 <a href="https://dev.mysql.com/doc/refman/5.7/en/mathematical-functions.html#function_rand" target="_blank" rel="noopener"><code>RAND()</code></a>在查询中不是常数，但实际上对于表的每一行都有一个新值<code>t</code>。因此，查询读取表的每一行，评估每一行的谓词，并输出主键与随机值匹配的所有行。根据<code>id</code>列值和<a href="https://dev.mysql.com/doc/refman/5.7/en/mathematical-functions.html#function_rand" target="_blank" rel="noopener"><code>RAND()</code></a>序列中的值， 它可以是零行，一行或多行 。</li>
</ul>
<p>非确定性的影响不仅限于 <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>陈述。该 <a href="https://dev.mysql.com/doc/refman/5.7/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a>语句使用非确定性函数来选择要修改的行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> col_a = some_expr <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="keyword">FLOOR</span>(<span class="number">1</span> + <span class="keyword">RAND</span>() * <span class="number">49</span>);</span><br></pre></td></tr></table></figure>

<p>大概的目的是最多更新主键与表达式匹配的一行。但是，它可能会更新零，一或多个行，具体取决于 <code>id</code>列值和<a href="https://dev.mysql.com/doc/refman/5.7/en/mathematical-functions.html#function_rand" target="_blank" rel="noopener"><code>RAND()</code></a>序列中的值 。</p>
<p>刚刚描述的行为对性能和复制有影响：</p>
<ul>
<li>由于不确定函数不会产生恒定值，因此优化器无法使用其他可能适用的策略，例如索引查找。结果可能是表扫描。</li>
<li><code>InnoDB</code> 可能升级为范围键锁，而不是为一个匹配的行获取单行锁。</li>
<li>无法确定执行的更新对于复制是不安全的。</li>
</ul>
<p>困难源于<a href="https://dev.mysql.com/doc/refman/5.7/en/mathematical-functions.html#function_rand" target="_blank" rel="noopener"><code>RAND()</code></a>对表的每一行都对函数进行一次评估的事实 。为了避免进行多功能评估，请使用以下技术之一：</p>
<ul>
<li><p>将包含不确定性函数的表达式移到单独的语句，将值保存在变量中。在原始语句中，用对变量的引用替换表达式，优化器可以将该变量视为常量值：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> @keyval = <span class="keyword">FLOOR</span>(<span class="number">1</span> + <span class="keyword">RAND</span>() * <span class="number">49</span>);</span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> col_a = some_expr <span class="keyword">WHERE</span> <span class="keyword">id</span> = @keyval;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将随机值分配给派生表中的变量。此技术使变量在<code>WHERE</code>子句中的比较中使用之前被分配一个值 ：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> optimizer_switch = <span class="string">'derived_merge=off'</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> t, (<span class="keyword">SELECT</span> @keyval := <span class="keyword">FLOOR</span>(<span class="number">1</span> + <span class="keyword">RAND</span>() * <span class="number">49</span>)) <span class="keyword">AS</span> dt</span><br><span class="line"><span class="keyword">SET</span> col_a = some_expr <span class="keyword">WHERE</span> <span class="keyword">id</span> = @keyval;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>如前所述，<code>WHERE</code>子句中的不确定性表达式 可能会阻止优化并导致表扫描。但是，<code>WHERE</code>如果其他表达式是确定性的，则可以部分优化该子句。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> partial_key=<span class="number">5</span> <span class="keyword">AND</span> some_column=<span class="keyword">RAND</span>();</span><br></pre></td></tr></table></figure>

<p>如果优化器可以<code>partial_key</code>用来减少选择的行的集合， <a href="https://dev.mysql.com/doc/refman/5.7/en/mathematical-functions.html#function_rand" target="_blank" rel="noopener"><code>RAND()</code></a>则执行的次数更少，这可以减少不确定性对优化的影响。</p>
<h4 id="8-2-1-19行构造器表达式优化"><a href="#8-2-1-19行构造器表达式优化" class="headerlink" title="8.2.1.19行构造器表达式优化"></a>8.2.1.19行构造器表达式优化</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> (column1,column2) = (<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> column1 = <span class="number">1</span> <span class="keyword">AND</span> column2 = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>另外，优化器以相同的方式处理两个表达式。</p>
<p>如果行构造器的列不覆盖索引的前缀，则优化器不太可能使用可用索引。考虑下表，该表具有一个主键 <code>(c1, c2, c3)</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (</span><br><span class="line">  c1 <span class="built_in">INT</span>, c2 <span class="built_in">INT</span>, c3 <span class="built_in">INT</span>, c4 <span class="built_in">CHAR</span>(<span class="number">100</span>),</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>(c1,c2,c3)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>在此查询中，该<code>WHERE</code>子句使用索引中的所有列。但是，行构造器本身不包含索引前缀，因此优化器仅使用<code>c1</code>（<code>key_len=4</code>，大小为<code>c1</code>）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM t1</span><br><span class="line">       WHERE c1=1 AND (c2,c3) &gt; (1,1)\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: t1</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 3</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using where</span><br></pre></td></tr></table></figure>

<p>在这种情况下，使用等效的非构造函数表达式重写行构造函数表达式可能会导致更完整的索引使用。对于给定的查询，行构造函数和等效的非构造函数表达式为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(c2,c3) &gt; (1,1)</span><br><span class="line">c2 &gt; 1 OR ((c2 = 1) AND (c3 &gt; 1))</span><br></pre></td></tr></table></figure>

<p>使用索引（<code>key_len=12</code>）中的所有三列重写查询以使用非构造函数表达式在优化器中导致结果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM t1</span><br><span class="line">       WHERE c1 = 1 AND (c2 &gt; 1 OR ((c2 = 1) AND (c3 &gt; 1)))\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: t1</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: range</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 12</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 3</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using where</span><br></pre></td></tr></table></figure>

<p>因此，为获得更好的结果，请避免将行构造函数与<a href="https://dev.mysql.com/doc/refman/5.7/en/logical-operators.html#operator_and" target="_blank" rel="noopener"><code>AND</code></a>/ <a href="https://dev.mysql.com/doc/refman/5.7/en/logical-operators.html#operator_or" target="_blank" rel="noopener"><code>OR</code></a> 表达式混合使用 。使用一个或另一个。</p>
<p>在某些条件下，优化器可以将范围访问方法应用于<a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_in" target="_blank" rel="noopener"><code>IN()</code></a>具有行构造函数参数的表达式。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/range-optimization.html#row-constructor-range-optimization" target="_blank" rel="noopener">行构造函数表达式的范围优化</a>。</p>
<h4 id="8-2-1-20避免全表扫描"><a href="#8-2-1-20避免全表扫描" class="headerlink" title="8.2.1.20避免全表扫描"></a>8.2.1.20避免全表扫描</h4><p>当MySQL使用<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_full_table_scan" target="_blank" rel="noopener">全表扫描</a>解决查询时， 列中 的输出<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>显示 。这通常在以下情况下发生： <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_all" target="_blank" rel="noopener"><code>ALL</code></a><code>type</code></p>
<ul>
<li>该表是如此之小，以至于执行表扫描要比打扰键查找要快得多。对于少于10行且行长较短的表，这很常见。</li>
<li>索引列 的<code>ON</code>or <code>WHERE</code>子句中没有可用的限制 。</li>
<li>您正在将索引列与常量值进行比较，并且MySQL已计算（基于索引树）（常量覆盖了表的很大一部分）并且表扫描会更快。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/where-optimization.html" target="_blank" rel="noopener">第8.2.1.1节“ WHERE子句优化”</a>。</li>
<li>您正在通过另一列使用基数较低的键（许多行与键值匹配）。在这种情况下，MySQL假定通过使用键，它可能会执行许多键查找，并且表扫描会更快。</li>
</ul>
<p>对于小型表，表扫描通常是合适的，并且对性能的影响可以忽略不计。对于大表，请尝试以下技术，以避免优化器错误地选择表扫描：</p>
<ul>
<li><p>使用更新的扫描表的键分布。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/analyze-table.html" target="_blank" rel="noopener">第13.7.2.1节“ ANALYZE TABLE语句”</a>。 <code>ANALYZE TABLE *tbl_name*</code></p>
</li>
<li><p>使用<code>FORCE INDEX</code>的扫描表告诉MySQL该表扫描是非常昂贵相比，使用给定的指标：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1, t2 <span class="keyword">FORCE</span> <span class="keyword">INDEX</span> (index_for_column)</span><br><span class="line">  <span class="keyword">WHERE</span> t1.col_name=t2.col_name;</span><br></pre></td></tr></table></figure>

<p>请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/index-hints.html" target="_blank" rel="noopener">第8.9.4节“索引提示”</a>。</p>
</li>
<li><p>使用该 选项 启动<a href="https://dev.mysql.com/doc/refman/5.7/en/mysqld.html" target="_blank" rel="noopener"><strong>mysqld</strong></a><a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_max_seeks_for_key" target="_blank" rel="noopener"><code>--max-seeks-for-key=1000</code></a>或使用<code>SET max_seeks_for_key=1000</code>告诉优化器假定没有键扫描导致超过1000个键查找。请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html" target="_blank" rel="noopener">第5.1.7节“服务器系统变量”</a>。</p>
</li>
</ul>
<h3 id="8-2-2优化子查询，派生表和视图引用"><a href="#8-2-2优化子查询，派生表和视图引用" class="headerlink" title="8.2.2优化子查询，派生表和视图引用"></a>8.2.2优化子查询，派生表和视图引用</h3><ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/semijoins.html" target="_blank" rel="noopener">8.2.2.1使用半联接转换优化子查询，派生表和视图引用</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/subquery-materialization.html" target="_blank" rel="noopener">8.2.2.2通过实现来优化子查询</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/subquery-optimization-with-exists.html" target="_blank" rel="noopener">8.2.2.3使用EXISTS策略优化子查询</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/derived-table-optimization.html" target="_blank" rel="noopener">8.2.2.4通过合并或实现来优化派生表和视图引用</a></li>
</ul>
<ul>
<li>对于<code>IN</code>（或<code>=ANY</code>）子查询，优化器具有以下选择：<ul>
<li>半连接</li>
<li>物化</li>
<li><code>EXISTS</code> 战略</li>
</ul>
</li>
<li>对于<code>NOT IN</code>（或 <code>&lt;&gt;ALL</code>）子查询，优化器具有以下选择：<ul>
<li>物化</li>
<li><code>EXISTS</code> 战略</li>
</ul>
</li>
</ul>
<p>对于派生表，优化器具有以下选择（这也适用于视图引用）：</p>
<ul>
<li>将派生表合并到外部查询块中</li>
<li>将派生表具体化为内部临时表</li>
</ul>
<p>以下讨论提供了有关前面的优化策略的更多信息。</p>
<p>注意</p>
<p>使用子查询修改单个表的<a href="https://dev.mysql.com/doc/refman/5.7/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/delete.html" target="_blank" rel="noopener"><code>DELETE</code></a>语句 的限制是，优化器不使用半联接或实现子查询优化。解决方法是，尝试将它们重写为使用联接而不是子查询的多表 <a href="https://dev.mysql.com/doc/refman/5.7/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/delete.html" target="_blank" rel="noopener"><code>DELETE</code></a>语句。</p>
<h4 id="8-2-2-1使用半联接转换优化子查询，派生表和视图引用"><a href="#8-2-2-1使用半联接转换优化子查询，派生表和视图引用" class="headerlink" title="8.2.2.1使用半联接转换优化子查询，派生表和视图引用"></a>8.2.2.1使用半联接转换优化子查询，派生表和视图引用</h4><p>半联接是准备时间的转换，它启用多种执行策略，例如表提取，重复删除，首次匹配，松散扫描和实现。如本节所述，优化器使用半联接策略来改善子查询的执行。</p>
<p>对于两个表之间的内部联接，该联接从一个表返回一行的次数是另一表中存在匹配项的次数。但是对于某些问题，唯一重要的信息是是否存在匹配项，而不是匹配数。假设在课程表和班级花名册（每个班级中都有学生）中分别有命名的表 <code>class</code>和<code>roster</code>列出的班级。要列出实际招收学生的课程，您可以使用以下联接：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> class.class_num, class.class_name</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">class</span> <span class="keyword">INNER</span> <span class="keyword">JOIN</span> roster</span><br><span class="line"><span class="keyword">WHERE</span> class.class_num = roster.class_num;</span><br></pre></td></tr></table></figure>

<p>但是，结果为每个注册学生列出一次每个班级。对于所提出的问题，这是不必要的信息重复。</p>
<p>假设它<code>class_num</code>是<code>class</code>表中的主键，则可以通过使用来抑制重复 <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT DISTINCT</code></a>，但是首先生成所有匹配的行效率很低，只能稍后消除重复。</p>
<p>可以使用子查询获得相同的无重复结果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> class_num, class_name</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">class</span></span><br><span class="line"><span class="keyword">WHERE</span> class_num <span class="keyword">IN</span> (<span class="keyword">SELECT</span> class_num <span class="keyword">FROM</span> roster);</span><br></pre></td></tr></table></figure>

<p>在这里，优化器可以识别出该 <code>IN</code>子句要求子查询仅返回<code>roster</code>表中每个类编号的一个实例 。在这种情况下，查询可以使用半联接；也就是说，该操作仅返回的每一行的一个实例，该实例 <code>class</code>与的行匹配 <code>roster</code>。</p>
<p>外部查询规范中允许使用外部联接和内部联接语法，并且表引用可以是基表，派生表或视图引用。</p>
<p>在MySQL中，子查询必须满足以下条件才能作为半联接处理：</p>
<ul>
<li><p>它必须是出现在or 子句最顶层的<code>IN</code>（或 <code>=ANY</code>）子查询，可能是表达式中的一个 词。例如： <code>WHERE``ON</code><a href="https://dev.mysql.com/doc/refman/5.7/en/logical-operators.html#operator_and" target="_blank" rel="noopener"><code>AND</code></a></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ...</span><br><span class="line"><span class="keyword">FROM</span> ot1, ...</span><br><span class="line"><span class="keyword">WHERE</span> (oe1, ...) <span class="keyword">IN</span> (<span class="keyword">SELECT</span> ie1, ... <span class="keyword">FROM</span> it1, ... <span class="keyword">WHERE</span> ...);</span><br></pre></td></tr></table></figure>

<p>在这里， 和 代表查询的外部和内部部分中的表，并且 和 表示引用外部和内部表中的列的表达式。 <code>ot_*i*``it_*i*``oe_*i*``ie_*i*</code></p>
</li>
<li><p>它必须是<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a> 没有<a href="https://dev.mysql.com/doc/refman/5.7/en/union.html" target="_blank" rel="noopener"><code>UNION</code></a>构造的单个。</p>
</li>
<li><p>它不能包含<code>GROUP BY</code>or <code>HAVING</code>子句。</p>
</li>
<li><p>不能将其隐式分组（不能包含任何聚合函数）。</p>
</li>
<li><p>它一定不能<code>ORDER BY</code>与 <code>LIMIT</code>。</p>
</li>
<li><p>该语句不得<code>STRAIGHT_JOIN</code>在外部查询中使用 联接类型。</p>
</li>
</ul>
<ul>
<li>该<code>STRAIGHT_JOIN</code>修改必须不存在。</li>
</ul>
<ul>
<li>外部表和内部表的总数必须小于联接中允许的最大表数。</li>
</ul>
<p>子查询可以是相关的或不相关的。 <code>DISTINCT</code>允许使用， <code>LIMIT</code>除非<code>ORDER BY</code>同样使用。</p>
<p>如果子查询满足上述条件，MySQL会将其转换为半联接，并从以下策略中进行基于成本的选择：</p>
<ul>
<li>将子查询转换为联接，或使用表提取，并将查询作为子查询表与外部表之间的内部联接运行。表提取将表从子查询中拉出到外部查询。</li>
</ul>
<ul>
<li>重复删除：像运行连接一样运行半连接，并使用临时表删除重复记录。</li>
</ul>
<ul>
<li>FirstMatch：当扫描内部表中的行组合并且给定值组有多个实例时，请选择一个而不是全部返回。这种“快捷方式”扫描可以消除不必要行的产生。</li>
</ul>
<ul>
<li>LooseScan：使用索引扫描子查询表，该索引允许从每个子查询的值组中选择一个值。</li>
</ul>
<ul>
<li>将子查询具体化到用于执行联接的索引临时表中，在该临时表中，索引用于删除重复项。当将临时表与外部表连接时，该索引以后也可能用于查找。如果不是，则扫描表。有关实现的更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/subquery-materialization.html" target="_blank" rel="noopener">第8.2.2.2节“通过实现来优化子查询”</a>。</li>
</ul>
<p>可以使用以下<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_optimizer_switch" target="_blank" rel="noopener"><code>optimizer_switch</code></a> 系统变量标志来启用或禁用这些策略中的每一个：</p>
<ul>
<li>该<code>semijoin</code>标志控制是否使用半联接。</li>
<li>如果<code>semijoin</code>使能， <code>firstmatch</code>， <code>loosescan</code>， <code>duplicateweedout</code>，和 <code>materialization</code>标志enable更好地控制在允许的半连接策略。</li>
<li>如果<code>duplicateweedout</code>禁用了半连接策略，则除非所有其他适用的策略也都被禁用，否则将不使用它。</li>
<li>如果<code>duplicateweedout</code>已禁用，则有时优化器可能会生成一个远非最佳的查询计划。发生这种情况的原因是贪婪搜索期间的启发式修剪，可以通过设置来避免 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_optimizer_prune_level" target="_blank" rel="noopener"><code>optimizer_prune_level=0</code></a>。</li>
</ul>
<p>默认情况下启用这些标志。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/switchable-optimizations.html" target="_blank" rel="noopener">第8.9.2节“可切换的优化”</a>。</p>
<p>优化器将视图和派生表的处理差异最小化。这会影响使用 <code>STRAIGHT_JOIN</code>修饰符的<code>IN</code>查询以及带有可转换为半联接的子查询的视图 。以下查询说明了这一点，因为处理中的更改导致转换中的更改，从而导致了不同的执行策略：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> v <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> t1</span><br><span class="line"><span class="keyword">WHERE</span> a <span class="keyword">IN</span> (<span class="keyword">SELECT</span> b</span><br><span class="line">           <span class="keyword">FROM</span> t2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">STRAIGHT_JOIN</span> *</span><br><span class="line"><span class="keyword">FROM</span> t3 <span class="keyword">JOIN</span> v <span class="keyword">ON</span> t3.x = v.a;</span><br></pre></td></tr></table></figure>

<p>优化器首先查看视图，然后将 <code>IN</code>子查询转换为半联接，然后检查是否有可能将视图合并到外部查询中。因为<code>STRAIGHT_JOIN</code>外部查询中的修饰符防止半联接，所以优化器拒绝合并，从而导致使用物化表进行派生表评估。</p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a> 输出表明使用了半连接策略，如下所示：</p>
<ul>
<li>半联接表显示在外部选择中。对于扩展<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>输出，以下内容显示的文本显示 <a href="https://dev.mysql.com/doc/refman/5.7/en/show-warnings.html" target="_blank" rel="noopener"><code>SHOW WARNINGS</code></a>了重写的查询，该查询显示了半联接结构。（请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-extended.html" target="_blank" rel="noopener">第8.8.3节“扩展的EXPLAIN输出格式”</a>。）由此，您可以了解哪些表从半联接中被拉出。如果将子查询转换为半联接，则将看到该子查询谓词已消失，并且其表和<code>WHERE</code>子句已合并到外部查询联接列表和 <code>WHERE</code>子句中。</li>
<li>对于重复Weedout临时表的使用是由指示 <code>Start temporary</code>和<code>End temporary</code>在<code>Extra</code> 列。那些没有拉出表是在范围内<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>所涵盖的输出行<code>Start temporary</code>，并 <code>End temporary</code>有自己 <code>rowid</code>的临时表。</li>
<li><code>FirstMatch(*tbl_name*)</code> 在<code>Extra</code>列表示加入shortcutting。</li>
<li><code>LooseScan(*m*..*n*)</code> 在<code>Extra</code>列指示使用LooseScan策略。<em>m</em>和 <em>n</em>是关键零件号。</li>
<li>用于实现的临时表由<code>select_type</code>值为的 <code>MATERIALIZED</code>行和的<code>table</code>值为的 行 指示。 <code>&lt;subquery*N*&gt;</code></li>
</ul>
<h4 id="8-2-2-2通过实现来优化子查询"><a href="#8-2-2-2通过实现来优化子查询" class="headerlink" title="8.2.2.2通过实现来优化子查询"></a>8.2.2.2通过实现来优化子查询</h4><p>优化器使用实现来启用更有效的子查询处理。物化通过生成子查询结果作为临时表（通常在内存中）来加快查询的执行速度。MySQL第一次需要子查询结果时，会将结果具体化为临时表。任何随后的需要结果的时间，MySQL都会再次引用临时表。优化器可以使用哈希索引为表建立索引，以使查找快速，廉价。索引包含唯一值，以消除重复项并使表更小。</p>
<p>子查询实现在可能的情况下使用内存中的临时表，如果表太大，则会退回到磁盘上的存储。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/internal-temporary-tables.html" target="_blank" rel="noopener">第8.4.4节“ MySQL中的内部临时表使用”</a>。</p>
<p>如果未使用实现，则优化器有时会将不相关的子查询重写为相关的子查询。例如，以下<code>IN</code>子查询是不相关的（<em>where_condition</em> 仅涉及from <code>t2</code>和not中的 列<code>t1</code>）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1</span><br><span class="line"><span class="keyword">WHERE</span> t1.a <span class="keyword">IN</span> (<span class="keyword">SELECT</span> t2.b <span class="keyword">FROM</span> t2 <span class="keyword">WHERE</span> where_condition);</span><br></pre></td></tr></table></figure>

<p>优化器可能将此重写为 <code>EXISTS</code>相关子查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> t2.b <span class="keyword">FROM</span> t2 <span class="keyword">WHERE</span> where_condition <span class="keyword">AND</span> t1.a=t2.b);</span><br></pre></td></tr></table></figure>

<p>使用临时表的子查询实现避免了这样的重写，并使得只可能执行一次子查询，而不是对外部查询的每一行执行一次。</p>
<p>为了使子查询实现在MySQL中使用， 必须启用<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_optimizer_switch" target="_blank" rel="noopener"><code>optimizer_switch</code></a>系统变量<code>materialization</code>标志。（见<a href="https://dev.mysql.com/doc/refman/5.7/en/switchable-optimizations.html" target="_blank" rel="noopener">第8.9.2节，“切换优化”</a>）。随着<code>materialization</code>启用的标志，物化适用于任何地方出现子查询谓词（在选择列表中，<code>WHERE</code>， <code>ON</code>，<code>GROUP BY</code>， <code>HAVING</code>，或<code>ORDER BY</code>），对于属于任何这些用例谓词：</p>
<ul>
<li><p>当没有外部表达式<em>oe_i</em>或内部表达式 <em>ie_i</em>可为空时，谓词具有这种形式 。 <em>N</em>为1或更大。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(oe_1, oe_2, ..., oe_N) [NOT] IN (<span class="keyword">SELECT</span> ie_1, i_2, ..., ie_N ...)</span><br></pre></td></tr></table></figure>
</li>
<li><p>当存在单个外部表达式<em>oe</em>和内部表达式时，谓词具有这种形式<em>ie</em>。表达式可以为空。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oe [NOT] IN (<span class="keyword">SELECT</span> ie ...)</span><br></pre></td></tr></table></figure>
</li>
<li><p>谓词为<code>IN</code>或，<code>NOT IN</code>并且<code>UNKNOWN</code> （<code>NULL</code>）的结果与的结果具有相同的含义<code>FALSE</code>。</p>
</li>
</ul>
<p>以下示例说明了等价<code>UNKNOWN</code>和 <code>FALSE</code>谓词求值的要求如何影响是否可以使用子查询实现。假定 <em>where_condition</em>只涉及来自<code>t2</code>而不涉及的列<code>t1</code> ，以使子查询不相关。</p>
<p>此查询需要具体实现：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1</span><br><span class="line"><span class="keyword">WHERE</span> t1.a <span class="keyword">IN</span> (<span class="keyword">SELECT</span> t2.b <span class="keyword">FROM</span> t2 <span class="keyword">WHERE</span> where_condition);</span><br></pre></td></tr></table></figure>

<p>在此，<code>IN</code> 谓词返回<code>UNKNOWN</code>还是 都没有关系<code>FALSE</code>。无论哪种方式，from的行 <code>t1</code>都不包含在查询结果中。</p>
<p>以下查询是不使用子查询实现的示例，其中<code>t2.b</code>的列为可空：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1</span><br><span class="line"><span class="keyword">WHERE</span> (t1.a,t1.b) <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> t2.a,t2.b <span class="keyword">FROM</span> t2</span><br><span class="line">                          <span class="keyword">WHERE</span> where_condition);</span><br></pre></td></tr></table></figure>

<p>以下限制适用于子查询实现的使用：</p>
<ul>
<li>内部和外部表达式的类型必须匹配。例如，如果两个表达式都是整数或两个都是十进制，那么优化器可能可以使用实现，但是如果一个表达式是整数而另一个表达式是十进制，则优化器不能使用实现。</li>
<li>内部表达式不能是 <a href="https://dev.mysql.com/doc/refman/5.7/en/blob.html" target="_blank" rel="noopener"><code>BLOB</code></a>。</li>
</ul>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>与查询一起 使用可提供有关优化器是否使用子查询实现的某种指示：</p>
<ul>
<li>与不使用实现的查询执行相比，<code>select_type</code>可以从更改<code>DEPENDENT SUBQUERY</code>为 <code>SUBQUERY</code>。这表明，对于将对每个外行执行一次的子查询，实现将使子查询仅执行一次。</li>
<li>对于扩展<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a> 输出，以下内容显示的文本 <a href="https://dev.mysql.com/doc/refman/5.7/en/show-warnings.html" target="_blank" rel="noopener"><code>SHOW WARNINGS</code></a>包括 <code>materialize</code>和 <code>materialized-subquery</code>。</li>
</ul>
<h4 id="8-2-2-3使用EXISTS策略优化子查询"><a href="#8-2-2-3使用EXISTS策略优化子查询" class="headerlink" title="8.2.2.3使用EXISTS策略优化子查询"></a>8.2.2.3使用EXISTS策略优化子查询</h4><p>考虑以下子查询比较：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outer_expr IN (<span class="keyword">SELECT</span> inner_expr <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> subquery_where)</span><br></pre></td></tr></table></figure>

<p>MySQL的评估查询“ 从外到内。” 即，首先获得外表达式的值 <em>outer_expr</em>，然后运行子查询，并且捕获的行，它产生。</p>
<p>一个非常有用的优化是“ 通知 ”子查询仅感兴趣的行是内部表达式<em>inner_expr</em>等于的行<em>outer_expr</em>。这是通过将适当的等式推入子查询的<code>WHERE</code>子句以使其更具限制性来完成的。转换后的比较如下所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXISTS (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> subquery_where <span class="keyword">AND</span> outer_expr=inner_expr)</span><br></pre></td></tr></table></figure>

<p>转换后，MySQL可以使用下推式相等性来限制评估子查询必须检查的行数。</p>
<p>更一般而言，将<em>N</em> 值与返回<em>N</em>-value行的子查询 进行比较将进行相同的转换。如果<em>oe_i</em>和 <em>ie_i</em>代表相应的外部和内部表达式值，则此子查询比较：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(oe_1, ..., oe_N) IN</span><br><span class="line">  (<span class="keyword">SELECT</span> ie_1, ..., ie_N <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> subquery_where)</span><br></pre></td></tr></table></figure>

<p>成为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXISTS (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> subquery_where</span><br><span class="line">                          <span class="keyword">AND</span> oe_1 = ie_1</span><br><span class="line">                          <span class="keyword">AND</span> ...</span><br><span class="line">                          <span class="keyword">AND</span> oe_N = ie_N)</span><br></pre></td></tr></table></figure>

<p>为简单起见，下面的讨论假定使用一对外部表达式值和内部表达式值。</p>
<p>刚刚描述的转换有其局限性。仅当我们忽略可能的<code>NULL</code>值时才有效。也就是说，只要满足以下两个条件，“ 下推 ”策略就可以起作用：</p>
<ul>
<li><p><em>outer_expr</em>而且 <em>inner_expr</em>不能 <code>NULL</code>。</p>
</li>
<li><p>你不必区分<code>NULL</code>从 <code>FALSE</code>子查询结果。如果子查询是子句中<a href="https://dev.mysql.com/doc/refman/5.7/en/logical-operators.html#operator_or" target="_blank" rel="noopener"><code>OR</code></a>or <a href="https://dev.mysql.com/doc/refman/5.7/en/logical-operators.html#operator_and" target="_blank" rel="noopener"><code>AND</code></a>表达式 的一部分<code>WHERE</code>，则MySQL认为您不在乎。在优化程序注意到另一个实例<code>NULL</code>和<code>FALSE</code> 子查询结果不需要区分是这样的结构：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">... WHERE outer_expr IN (subquery)</span><br></pre></td></tr></table></figure>

<p>在这种情况下，该<code>WHERE</code>子句拒绝该行，无论是return 还是。 <code>IN (*subquery*)``NULL``FALSE</code></p>
</li>
</ul>
<p>当这些条件中的任何一个或两个都不满足时，优化会更加复杂。</p>
<p>假设<em>outer_expr<em>已知这是一个非<code>NULL</code>值，但子查询不会产生诸如</em>outer_expr</em>= 的行 <em>inner_expr<em>。然后 `</em>outer_expr</em> IN (SELECT …)`评估如下：</p>
<ul>
<li><code>NULL</code>中，如果 <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>产生任何行，其中<em>inner_expr</em>是 <code>NULL</code></li>
<li><code>FALSE</code>，如果 <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>仅产生非<code>NULL</code>值或什么都不产生</li>
</ul>
<p>在这种情况下，使用查找行的方法 不再有效。有必要查找这样的行，但是如果没有找到，则还要在is中 查找行 。粗略地说，子查询可以转换为如下形式： <code>*outer_expr* = *inner_expr*</code><em>inner_expr</em><code>NULL</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXISTS (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> subquery_where <span class="keyword">AND</span></span><br><span class="line">        (outer_expr=inner_expr <span class="keyword">OR</span> inner_expr <span class="keyword">IS</span> <span class="literal">NULL</span>))</span><br></pre></td></tr></table></figure>

<p>需要评估额外<a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_is-null" target="_blank" rel="noopener"><code>IS NULL</code></a>条件是MySQL具有 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_ref_or_null" target="_blank" rel="noopener"><code>ref_or_null</code></a>访问方法的原因：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN</span><br><span class="line">       <span class="keyword">SELECT</span> outer_expr <span class="keyword">IN</span> (<span class="keyword">SELECT</span> t2.maybe_null_key</span><br><span class="line">                             <span class="keyword">FROM</span> t2, t3 <span class="keyword">WHERE</span> ...)</span><br><span class="line">       <span class="keyword">FROM</span> t1;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: PRIMARY</span><br><span class="line">        table: t1</span><br><span class="line">...</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">           id: 2</span><br><span class="line">  select_type: DEPENDENT SUBQUERY</span><br><span class="line">        table: t2</span><br><span class="line">         type: ref_or_null</span><br><span class="line">possible_keys: maybe_null_key</span><br><span class="line">          key: maybe_null_key</span><br><span class="line">      key_len: 5</span><br><span class="line">          ref: func</span><br><span class="line">         rows: 2</span><br><span class="line">        Extra: Using where; Using index</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_unique_subquery" target="_blank" rel="noopener"><code>unique_subquery</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_index_subquery" target="_blank" rel="noopener"><code>index_subquery</code></a> 子查询，具体的访问方法也有“ 或 <code>NULL</code> ”变种。</p>
<p>附加<code>OR ... IS NULL</code>条件使查询执行稍微复杂一些（并且子查询中的某些优化变得不适用），但是通常这是可以容忍的。</p>
<p>当<em>outer_expr*可以的 时候情况要糟得多 <code>NULL</code>。根据SQL解释<code>NULL</code>为“ 未知值 ”， 应评估为： `NULL IN (SELECT *inner_expr</em> …)`</p>
<ul>
<li><code>NULL</code>，如果 <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>产生任何行</li>
<li><code>FALSE</code>，如果不 <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>产生任何行</li>
</ul>
<p>为了进行适当的评估，必须能够检查是否<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>已产生任何行，因此 不能将其下推到子查询中。这是一个问题，因为许多现实世界中的子查询会变得非常缓慢，除非可以降低相等性。 <code>*outer_expr* = *inner_expr*</code></p>
<p>本质上，取决于的值，必须有不同的方法来执行子查询 <em>outer_expr</em>。</p>
<p>优化选择超速SQL合规性，所以它占的可能性 <em>outer_expr</em>可能是 <code>NULL</code>：</p>
<ul>
<li><p>如果<em>outer_expr</em>为 <code>NULL</code>，则要评估以下表达式，必须执行 <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>以确定它是否产生任何行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NULL IN (<span class="keyword">SELECT</span> inner_expr <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> subquery_where)</span><br></pre></td></tr></table></figure>

<p>必须在<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>这里执行原始文件 ，而没有前面提到的那种下推式等价物。</p>
</li>
<li><p>另一方面，当<em>outer_expr</em>不是 时 <code>NULL</code>，此比较绝对必要：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outer_expr IN (<span class="keyword">SELECT</span> inner_expr <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> subquery_where)</span><br></pre></td></tr></table></figure>

<p>转换为使用下推条件的表达式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXISTS (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> subquery_where <span class="keyword">AND</span> outer_expr=inner_expr)</span><br></pre></td></tr></table></figure>

<p>没有这种转换，子查询将很慢。</p>
</li>
</ul>
<p>为了解决是否将条件下推到子查询中的难题，将条件包装在 “ 触发器 ”函数中。因此，以下形式的表达式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outer_expr IN (<span class="keyword">SELECT</span> inner_expr <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> subquery_where)</span><br></pre></td></tr></table></figure>

<p>转换为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXISTS (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> subquery_where</span><br><span class="line">                          <span class="keyword">AND</span> trigcond(outer_expr=inner_expr))</span><br></pre></td></tr></table></figure>

<p>更一般而言，如果子查询比较基于几对外部和内部表达式，则转换将采用以下比较：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(oe_1, ..., oe_N) IN (<span class="keyword">SELECT</span> ie_1, ..., ie_N <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> subquery_where)</span><br></pre></td></tr></table></figure>

<p>并将其转换为以下表达式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXISTS (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> subquery_where</span><br><span class="line">                          <span class="keyword">AND</span> trigcond(oe_1=ie_1)</span><br><span class="line">                          <span class="keyword">AND</span> ...</span><br><span class="line">                          <span class="keyword">AND</span> trigcond(oe_N=ie_N)</span><br><span class="line">       )</span><br></pre></td></tr></table></figure>

<p>每个 函数都是一个特殊函数，其结果为以下值： <code>trigcond(*X*)</code></p>
<ul>
<li><em>X</em>当 “ 链接的 ”外部表达 <em>oe_i</em>不是 <code>NULL</code></li>
<li><code>TRUE</code>当“ 链接的 ” 外部表达<em>oe_i</em>是 <code>NULL</code></li>
</ul>
<p>注意</p>
<p>触发器函数<em>不是</em>您使用创建的那种触发器<a href="https://dev.mysql.com/doc/refman/5.7/en/create-trigger.html" target="_blank" rel="noopener"><code>CREATE TRIGGER</code></a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trigcond()&#96;函数 中包装的等式 不是查询优化器的第一类谓词。大多数优化不能处理可能在查询执行时打开和关闭的谓词，因此它们假定任何谓词 都是未知函数，而忽略它。那些优化可以使用触发的等式： &#96;trigcond(*X*)</span><br></pre></td></tr></table></figure>

<ul>
<li>参考优化： 可用于构建 ， 或 表访问。 <code>trigcond(*X*=*Y* [OR *Y* IS NULL])</code><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_ref" target="_blank" rel="noopener"><code>ref</code></a><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_eq_ref" target="_blank" rel="noopener"><code>eq_ref</code></a><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_ref_or_null" target="_blank" rel="noopener"><code>ref_or_null</code></a></li>
<li>基于索引查找的子查询执行引擎： 可用于构造 或 访问。 <code>trigcond(*X*=*Y*)</code><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_unique_subquery" target="_blank" rel="noopener"><code>unique_subquery</code></a><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_index_subquery" target="_blank" rel="noopener"><code>index_subquery</code></a></li>
<li>表条件生成器：如果子查询是多个表的联接，则将尽快检查触发条件。</li>
</ul>
<p>当优化器使用触发条件创建某种基于索引查找的访问时（对于前面列表的前两项），对于条件关闭的情况，优化器必须具有回退策略。此后备策略始终相同：执行全表扫描。在 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>输出中，回退显示<code>Full scan on NULL key</code>在 <code>Extra</code>列中：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT t1.col1,</span><br><span class="line">       t1.col1 IN (<span class="keyword">SELECT</span> t2.key1 <span class="keyword">FROM</span> t2 <span class="keyword">WHERE</span> t2.col2=t1.col2) <span class="keyword">FROM</span> t1\G</span><br><span class="line">*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">           <span class="keyword">id</span>: <span class="number">1</span></span><br><span class="line">  select_type: PRIMARY</span><br><span class="line">        <span class="keyword">table</span>: t1</span><br><span class="line">        ...</span><br><span class="line">*************************** <span class="number">2.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">           <span class="keyword">id</span>: <span class="number">2</span></span><br><span class="line">  select_type: DEPENDENT SUBQUERY</span><br><span class="line">        <span class="keyword">table</span>: t2</span><br><span class="line">         <span class="keyword">type</span>: index_subquery</span><br><span class="line">possible_keys: key1</span><br><span class="line">          <span class="keyword">key</span>: key1</span><br><span class="line">      key_len: <span class="number">5</span></span><br><span class="line">          <span class="keyword">ref</span>: func</span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">2</span></span><br><span class="line">        Extra: <span class="keyword">Using</span> <span class="keyword">where</span>; Full scan on NULL key</span><br></pre></td></tr></table></figure>

<p>如果你运行<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>之后 <a href="https://dev.mysql.com/doc/refman/5.7/en/show-warnings.html" target="_blank" rel="noopener"><code>SHOW WARNINGS</code></a>，你可以看到触发条件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*************************** 1. row ***************************</span><br><span class="line">  Level: Note</span><br><span class="line">   Code: 1003</span><br><span class="line">Message: select &#96;test&#96;.&#96;t1&#96;.&#96;col1&#96; AS &#96;col1&#96;,</span><br><span class="line">         &lt;in_optimizer&gt;(&#96;test&#96;.&#96;t1&#96;.&#96;col1&#96;,</span><br><span class="line">         &lt;exists&gt;(&lt;index_lookup&gt;(&lt;cache&gt;(&#96;test&#96;.&#96;t1&#96;.&#96;col1&#96;) in t2</span><br><span class="line">         on key1 checking NULL</span><br><span class="line">         where (&#96;test&#96;.&#96;t2&#96;.&#96;col2&#96; &#x3D; &#96;test&#96;.&#96;t1&#96;.&#96;col2&#96;) having</span><br><span class="line">         trigcond(&lt;is_not_null_test&gt;(&#96;test&#96;.&#96;t2&#96;.&#96;key1&#96;))))) AS</span><br><span class="line">         &#96;t1.col1 IN (select t2.key1 from t2 where t2.col2&#x3D;t1.col2)&#96;</span><br><span class="line">         from &#96;test&#96;.&#96;t1&#96;</span><br></pre></td></tr></table></figure>

<p>使用触发条件会影响性能。甲<code>NULL IN (SELECT ...)</code> 现在表达可能会导致全表扫描（这是慢）时，它以前没有。这是为获得正确结果而付出的代价（触发条件策略的目标是提高合规性，而不是速度）。</p>
<p>对于多表子查询，执行<code>NULL IN (SELECT ...)</code>特别慢，因为联接优化器不会针对外部表达式为的情况进行优化<code>NULL</code>。它假定<code>NULL</code>左侧的子查询评估非常少见，即使有统计数据表明并非如此。另一方面，如果外部表达式可能是 <code>NULL</code>但实际上不是，则不会影响性能。</p>
<p>为了帮助查询优化器更好地执行查询，请使用以下建议：</p>
<ul>
<li><p>声明一列，就<code>NOT NULL</code>好像它确实是一样。通过简化色谱柱的条件测试，这也有助于优化程序的其他方面。</p>
</li>
<li><p>如果您不需要区分<code>NULL</code>来自 <code>FALSE</code>子查询的结果，你可以很容易地避免慢的执行路径。替换如下所示的比较：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outer_expr IN (<span class="keyword">SELECT</span> inner_expr <span class="keyword">FROM</span> ...)</span><br></pre></td></tr></table></figure>

<p>具有以下表达式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(outer_expr IS NOT NULL) AND (outer_expr IN (<span class="keyword">SELECT</span> inner_expr <span class="keyword">FROM</span> ...))</span><br></pre></td></tr></table></figure>

<p>然后<code>NULL IN (SELECT ...)</code>永远不会进行评估，因为<a href="https://dev.mysql.com/doc/refman/5.7/en/logical-operators.html#operator_and" target="_blank" rel="noopener"><code>AND</code></a>一旦表达式结果明确，MySQL就会停止评估 零件。</p>
<p>另一种可能的重写：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXISTS (<span class="keyword">SELECT</span> inner_expr <span class="keyword">FROM</span> ...</span><br><span class="line">        <span class="keyword">WHERE</span> inner_expr=outer_expr)</span><br></pre></td></tr></table></figure>

<p>当你需要分不清这将适用于 <code>NULL</code>从<code>FALSE</code> 子查询结果，在这种情况下，你可能真的想 <code>EXISTS</code>。</p>
</li>
</ul>
<p>通过 系统变量的<code>subquery_materialization_cost_based</code> 标志，<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_optimizer_switch" target="_blank" rel="noopener"><code>optimizer_switch</code></a>可以控制子查询实现和<code>IN</code>-to- <code>EXISTS</code>subquery转换之间的选择 。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/switchable-optimizations.html" target="_blank" rel="noopener">第8.9.2节“可切换的优化”</a>。</p>
<h4 id="8-2-2-4通过合并或实现来优化派生表和视图引用"><a href="#8-2-2-4通过合并或实现来优化派生表和视图引用" class="headerlink" title="8.2.2.4通过合并或实现来优化派生表和视图引用"></a>8.2.2.4通过合并或实现来优化派生表和视图引用</h4><ul>
<li>将派生表合并到外部查询块中</li>
<li>将派生表具体化为内部临时表</li>
</ul>
<p>范例1：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1) <span class="keyword">AS</span> derived_t1;</span><br></pre></td></tr></table></figure>

<p>通过合并派生表 <code>derived_t1</code>，该查询的执行类似于：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1;</span><br></pre></td></tr></table></figure>

<p>范例2：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line">  <span class="keyword">FROM</span> t1 <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> t2.f1 <span class="keyword">FROM</span> t2) <span class="keyword">AS</span> derived_t2 <span class="keyword">ON</span> t1.f2=derived_t2.f1</span><br><span class="line">  <span class="keyword">WHERE</span> t1.f1 &gt; <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>通过合并派生表 <code>derived_t2</code>，该查询的执行类似于：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t1.*, t2.f1</span><br><span class="line">  <span class="keyword">FROM</span> t1 <span class="keyword">JOIN</span> t2 <span class="keyword">ON</span> t1.f2=t2.f1</span><br><span class="line">  <span class="keyword">WHERE</span> t1.f1 &gt; <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>有了物化后，<code>derived_t1</code>和 <code>derived_t2</code>分别在各自的查询中被视为一个单独的表。</p>
<p>优化器以相同的方式处理派生表和视图引用：尽可能避免不必要的实现，从而可以将条件从外部查询下推到派生表，并产生更有效的执行计划。（有关示例，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/subquery-materialization.html" target="_blank" rel="noopener">第8.2.2.2节“通过实现来优化子查询”）</a>。</p>
<p>如果合并将导致一个外部查询块引用超过61个基本表，则优化程序将选择实现。</p>
<p><code>ORDER BY</code>如果满足以下所有条件，则 优化器将派生子句在派生表或视图引用中传播到外部查询块：</p>
<ul>
<li>外部查询未分组或聚合。</li>
<li>外部查询不指定 <code>DISTINCT</code>，<code>HAVING</code>或 <code>ORDER BY</code>。</li>
<li>外部查询将此派生表或视图引用作为<code>FROM</code>子句中的唯一源。</li>
</ul>
<p>否则，优化器将忽略该<code>ORDER BY</code>子句。</p>
<p>以下方法可用来影响优化器是否尝试将派生表和视图引用合并到外部查询块中：</p>
<ul>
<li><p>假设没有其他规则阻止合并，则可以使用系统变量 的<code>derived_merge</code>标志 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_optimizer_switch" target="_blank" rel="noopener"><code>optimizer_switch</code></a>。请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/switchable-optimizations.html" target="_blank" rel="noopener">第8.9.2节“可切换的优化”</a>。默认情况下，该标志启用以允许合并。禁用该标志可防止合并并避免 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-error-reference.html#error_er_update_table_used" target="_blank" rel="noopener"><code>ER_UPDATE_TABLE_USED</code></a> 错误。</p>
<p>该<code>derived_merge</code>标志还适用于不包含任何<code>ALGORITHM</code>子句的视图。因此，如果 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-error-reference.html#error_er_update_table_used" target="_blank" rel="noopener"><code>ER_UPDATE_TABLE_USED</code></a>使用与子查询等效的表达式的视图引用发生错误，则添加 <code>ALGORITHM=TEMPTABLE</code>到视图定义将防止合并，并优先于该 <code>derived_merge</code>值。</p>
</li>
<li><p>可以通过在子查询中使用任何阻止合并的构造来禁用合并，尽管这些构造对实现的影响不那么明显。防止合并的构造与派生表和视图引用相同：</p>
</li>
</ul>
<p>该<code>derived_merge</code>标志还适用于不包含任何<code>ALGORITHM</code>子句的视图。因此，如果 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-error-reference.html#error_er_update_table_used" target="_blank" rel="noopener"><code>ER_UPDATE_TABLE_USED</code></a>使用与子查询等效的表达式的视图引用发生错误，则添加<code>ALGORITHM=TEMPTABLE</code> 到视图定义将防止合并，并优先于当前<code>derived_merge</code>值。</p>
<p>如果优化器选择实现策略而不是合并派生表，则它将按以下方式处理查询：</p>
<ul>
<li>优化器将派生表的实现推迟到查询执行期间需要其内容之前。这会提高性能，因为延迟实现可能会导致根本不必这样做。考虑一个将派生表的结果连接到另一个表的查询：如果优化器首先处理该另一个表并发现它不返回任何行，则不需要进一步执行联接，并且优化器可以完全跳过具体化派生表。</li>
<li>在查询执行期间，优化器可以将索引添加到派生表中，以加快从中获取行的速度。</li>
</ul>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a> 对于<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>包含派生表的查询， 请考虑以下语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1) <span class="keyword">AS</span> derived_t1;</span><br></pre></td></tr></table></figure>

<p>优化器通过将派生表延迟到<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>执行期间需要结果之前来避免实现该表 。在这种情况下，查询不会执行（因为它发生在 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>语句中），因此永远不需要结果。</p>
<p>即使对于已执行的查询，派生表实现的延迟也可以使优化程序完全避免实现。发生这种情况时，查询执行将比实现实现所需的时间更快。考虑以下查询，该查询将派生表的结果连接到另一个表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line">  <span class="keyword">FROM</span> t1 <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> t2.f1 <span class="keyword">FROM</span> t2) <span class="keyword">AS</span> derived_t2</span><br><span class="line">          <span class="keyword">ON</span> t1.f2=derived_t2.f1</span><br><span class="line">  <span class="keyword">WHERE</span> t1.f1 &gt; <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>如果优化过程<code>t1</code>首先进行且<code>WHERE</code>子句产生空结果，则联接必须一定为空，并且派生表不必实现。</p>
<p>对于派生表需要实现的情况，优化器可以向实现表添加索引以加快对其的访问。如果使用这样的索引可以 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_ref" target="_blank" rel="noopener"><code>ref</code></a>访问表，则可以大大减少查询执行期间读取的数据量。考虑以下查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"> <span class="keyword">FROM</span> t1 <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> f1 <span class="keyword">FROM</span> t2) <span class="keyword">AS</span> derived_t2</span><br><span class="line">         <span class="keyword">ON</span> t1.f1=derived_t2.f1;</span><br></pre></td></tr></table></figure>

<p>如果这样做 ，优化器将构造列上的索引 <code>f1</code>，<code>derived_t2</code>如果这样做，则可以将 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_ref" target="_blank" rel="noopener"><code>ref</code></a>访问用于最低成本的执行计划。添加索引之后，优化器可以将物化派生表与具有索引的常规表相同，并且它从生成的索引中同样受益。与没有索引的查询执行成本相比，索引创建的开销可以忽略不计。如果 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_ref" target="_blank" rel="noopener"><code>ref</code></a>访问会比其他访问方法带来更高的成本，则优化器不会创建索引，也不会丢失任何内容。</p>
<p>对于优化程序跟踪输出，合并的派生表或视图引用未显示为节点。仅其基础表出现在顶部查询的计划中。</p>
<h3 id="8-2-3优化INFORMATION-SCHEMA查询"><a href="#8-2-3优化INFORMATION-SCHEMA查询" class="headerlink" title="8.2.3优化INFORMATION_SCHEMA查询"></a>8.2.3优化INFORMATION_SCHEMA查询</h3><p>注意</p>
<p><code>INFORMATION_SCHEMA</code>查询中 数据库名称和表名称的比较行为 可能与您期望的有所不同。有关详细信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/charset-collation-information-schema.html" target="_blank" rel="noopener">第10.8.7节“在INFORMATION_SCHEMA搜索中使用归类”</a>。</p>
<p><strong>1）尝试在WHERE 子句中对数据库和表名使用常量查找值</strong></p>
<p>您可以利用以下原理：</p>
<ul>
<li>要查找数据库或表，请使用计算结果为常量的表达式，例如文字值，返回常量的函数或标量子查询。</li>
<li>避免使用非恒定数据库名称查找值（或不使用查找值）的查询，因为它们需要扫描数据目录以查找匹配的数据库目录名称。</li>
<li>在数据库内，请避免使用非恒定表名查找值（或不使用查找值）的查询，因为它们需要扫描数据库目录才能找到匹配的表文件。</li>
</ul>
<p>此原理适用于下 <code>INFORMATION_SCHEMA</code>表中显示的表，该表显示了其常量查找值使服务器能够避免目录扫描的列。例如，如果从中进行选择，则 在 子句中<a href="https://dev.mysql.com/doc/refman/5.7/en/tables-table.html" target="_blank" rel="noopener"><code>TABLES</code></a>使用for的常量查找值可以避免进行数据目录扫描。 <code>TABLE_SCHEMA``WHERE</code></p>
<table>
<thead>
<tr>
<th>表</th>
<th>指定要避免数据目录扫描的列</th>
<th>指定要避免数据库目录扫描的列</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/columns-table.html" target="_blank" rel="noopener"><code>COLUMNS</code></a></td>
<td><code>TABLE_SCHEMA</code></td>
<td><code>TABLE_NAME</code></td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/key-column-usage-table.html" target="_blank" rel="noopener"><code>KEY_COLUMN_USAGE</code></a></td>
<td><code>TABLE_SCHEMA</code></td>
<td><code>TABLE_NAME</code></td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/partitions-table.html" target="_blank" rel="noopener"><code>PARTITIONS</code></a></td>
<td><code>TABLE_SCHEMA</code></td>
<td><code>TABLE_NAME</code></td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/referential-constraints-table.html" target="_blank" rel="noopener"><code>REFERENTIAL_CONSTRAINTS</code></a></td>
<td><code>CONSTRAINT_SCHEMA</code></td>
<td><code>TABLE_NAME</code></td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/statistics-table.html" target="_blank" rel="noopener"><code>STATISTICS</code></a></td>
<td><code>TABLE_SCHEMA</code></td>
<td><code>TABLE_NAME</code></td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/tables-table.html" target="_blank" rel="noopener"><code>TABLES</code></a></td>
<td><code>TABLE_SCHEMA</code></td>
<td><code>TABLE_NAME</code></td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/table-constraints-table.html" target="_blank" rel="noopener"><code>TABLE_CONSTRAINTS</code></a></td>
<td><code>TABLE_SCHEMA</code></td>
<td><code>TABLE_NAME</code></td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/triggers-table.html" target="_blank" rel="noopener"><code>TRIGGERS</code></a></td>
<td><code>EVENT_OBJECT_SCHEMA</code></td>
<td><code>EVENT_OBJECT_TABLE</code></td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/views-table.html" target="_blank" rel="noopener"><code>VIEWS</code></a></td>
<td><code>TABLE_SCHEMA</code></td>
<td><code>TABLE_NAME</code></td>
</tr>
</tbody></table>
<p>限于特定的常量数据库名称的查询的好处是只需要对命名数据库目录进行检查。例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TABLE_NAME <span class="keyword">FROM</span> INFORMATION_SCHEMA.TABLES</span><br><span class="line"><span class="keyword">WHERE</span> TABLE_SCHEMA = <span class="string">'test'</span>;</span><br></pre></td></tr></table></figure>

<p>使用文字数据库名称<code>test</code>可使服务器仅检查<code>test</code>数据库目录，而不管可能存在多少个数据库。相比之下，以下查询效率较低，因为它需要扫描数据目录以确定哪些数据库名称与模式匹配<code>&#39;test%&#39;</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TABLE_NAME <span class="keyword">FROM</span> INFORMATION_SCHEMA.TABLES</span><br><span class="line"><span class="keyword">WHERE</span> TABLE_SCHEMA <span class="keyword">LIKE</span> <span class="string">'test%'</span>;</span><br></pre></td></tr></table></figure>

<p>对于限于特定常量表名称的查询，仅需要检查相应数据库目录中的命名表。例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TABLE_NAME <span class="keyword">FROM</span> INFORMATION_SCHEMA.TABLES</span><br><span class="line"><span class="keyword">WHERE</span> TABLE_SCHEMA = <span class="string">'test'</span> <span class="keyword">AND</span> TABLE_NAME = <span class="string">'t1'</span>;</span><br></pre></td></tr></table></figure>

<p>使用文字表名<code>t1</code>可使服务器仅检查<code>t1</code> 表文件，而不管<code>test</code>数据库中可能有多少个表 。相比之下，以下查询需要扫描<code>test</code>数据库目录以确定哪些表名称与模式匹配 <code>&#39;t%&#39;</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TABLE_NAME <span class="keyword">FROM</span> INFORMATION_SCHEMA.TABLES</span><br><span class="line"><span class="keyword">WHERE</span> TABLE_SCHEMA = <span class="string">'test'</span> <span class="keyword">AND</span> TABLE_NAME <span class="keyword">LIKE</span> <span class="string">'t%'</span>;</span><br></pre></td></tr></table></figure>

<p>以下查询需要扫描数据库目录以确定该模式的匹配数据库名称 <code>&#39;test%&#39;</code>，对于每个匹配的数据库，它都需要扫描数据库目录以确定该模式的匹配表名称<code>&#39;t%&#39;</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TABLE_NAME <span class="keyword">FROM</span> INFORMATION_SCHEMA.TABLES</span><br><span class="line"><span class="keyword">WHERE</span> TABLE_SCHEMA = <span class="string">'test%'</span> <span class="keyword">AND</span> TABLE_NAME <span class="keyword">LIKE</span> <span class="string">'t%'</span>;</span><br></pre></td></tr></table></figure>

<p><strong>2）编写查询以最小化必须打开的表文件的数量</strong></p>
<p>对于引用某些<code>INFORMATION_SCHEMA</code>表列的查询，可以进行 多种优化，以最大程度地减少必须打开的表文件的数量。例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TABLE_NAME, <span class="keyword">ENGINE</span> <span class="keyword">FROM</span> INFORMATION_SCHEMA.TABLES</span><br><span class="line"><span class="keyword">WHERE</span> TABLE_SCHEMA = <span class="string">'test'</span>;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，服务器扫描数据库目录以确定数据库中表的名称之后，这些名称将可用，而无需进行进一步的文件系统查找。因此，<code>TABLE_NAME</code>不需要打开任何文件。的<code>ENGINE</code>（存储引擎）值可以通过打开表的确定 <code>.frm</code>文件，而不接触其它表文件，例如<code>.MYD</code>或 <code>.MYI</code>文件。</p>
<p>某些值（例如<code>INDEX_LENGTH</code>用于 <code>MyISAM</code>表的值）也需要打开 <code>.MYD</code>或<code>.MYI</code>文件。</p>
<p>文件打开优化类型表示为：</p>
<ul>
<li><code>SKIP_OPEN_TABLE</code>：不需要打开表文件。通过扫描数据库目录，该信息已在查询中可用。</li>
<li><code>OPEN_FRM_ONLY</code>：仅<code>.frm</code>需要打开表的 文件。</li>
<li><code>OPEN_TRIGGER_ONLY</code>：仅<code>.TRG</code>需要打开表的 文件。</li>
<li><code>OPEN_FULL_TABLE</code>：未优化的信息查找。的<code>.frm</code>， <code>.MYD</code>和<code>.MYI</code> 文件必须被打开。</li>
</ul>
<ul>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/columns-table.html" target="_blank" rel="noopener"><code>COLUMNS</code></a>： <code>OPEN_FRM_ONLY</code>适用于所有列</p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/key-column-usage-table.html" target="_blank" rel="noopener"><code>KEY_COLUMN_USAGE</code></a>： <code>OPEN_FULL_TABLE</code>适用于所有列</p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/partitions-table.html" target="_blank" rel="noopener"><code>PARTITIONS</code></a>： <code>OPEN_FULL_TABLE</code>适用于所有列</p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/referential-constraints-table.html" target="_blank" rel="noopener"><code>REFERENTIAL_CONSTRAINTS</code></a>： <code>OPEN_FULL_TABLE</code>适用于所有列</p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/statistics-table.html" target="_blank" rel="noopener"><code>STATISTICS</code></a>：</p>
<table>
<thead>
<tr>
<th>柱</th>
<th>优化类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>TABLE_CATALOG</code></td>
<td><code>OPEN_FRM_ONLY</code></td>
</tr>
<tr>
<td><code>TABLE_SCHEMA</code></td>
<td><code>OPEN_FRM_ONLY</code></td>
</tr>
<tr>
<td><code>TABLE_NAME</code></td>
<td><code>OPEN_FRM_ONLY</code></td>
</tr>
<tr>
<td><code>NON_UNIQUE</code></td>
<td><code>OPEN_FRM_ONLY</code></td>
</tr>
<tr>
<td><code>INDEX_SCHEMA</code></td>
<td><code>OPEN_FRM_ONLY</code></td>
</tr>
<tr>
<td><code>INDEX_NAME</code></td>
<td><code>OPEN_FRM_ONLY</code></td>
</tr>
<tr>
<td><code>SEQ_IN_INDEX</code></td>
<td><code>OPEN_FRM_ONLY</code></td>
</tr>
<tr>
<td><code>COLUMN_NAME</code></td>
<td><code>OPEN_FRM_ONLY</code></td>
</tr>
<tr>
<td><code>COLLATION</code></td>
<td><code>OPEN_FRM_ONLY</code></td>
</tr>
<tr>
<td><code>CARDINALITY</code></td>
<td><code>OPEN_FULL_TABLE</code></td>
</tr>
<tr>
<td><code>SUB_PART</code></td>
<td><code>OPEN_FRM_ONLY</code></td>
</tr>
<tr>
<td><code>PACKED</code></td>
<td><code>OPEN_FRM_ONLY</code></td>
</tr>
<tr>
<td><code>NULLABLE</code></td>
<td><code>OPEN_FRM_ONLY</code></td>
</tr>
<tr>
<td><code>INDEX_TYPE</code></td>
<td><code>OPEN_FULL_TABLE</code></td>
</tr>
<tr>
<td><code>COMMENT</code></td>
<td><code>OPEN_FRM_ONLY</code></td>
</tr>
</tbody></table>
</li>
</ul>
<ul>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/tables-table.html" target="_blank" rel="noopener"><code>TABLES</code></a>：</p>
<table>
<thead>
<tr>
<th>柱</th>
<th>优化类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>TABLE_CATALOG</code></td>
<td><code>SKIP_OPEN_TABLE</code></td>
</tr>
<tr>
<td><code>TABLE_SCHEMA</code></td>
<td><code>SKIP_OPEN_TABLE</code></td>
</tr>
<tr>
<td><code>TABLE_NAME</code></td>
<td><code>SKIP_OPEN_TABLE</code></td>
</tr>
<tr>
<td><code>TABLE_TYPE</code></td>
<td><code>OPEN_FRM_ONLY</code></td>
</tr>
<tr>
<td><code>ENGINE</code></td>
<td><code>OPEN_FRM_ONLY</code></td>
</tr>
<tr>
<td><code>VERSION</code></td>
<td><code>OPEN_FRM_ONLY</code></td>
</tr>
<tr>
<td><code>ROW_FORMAT</code></td>
<td><code>OPEN_FULL_TABLE</code></td>
</tr>
<tr>
<td><code>TABLE_ROWS</code></td>
<td><code>OPEN_FULL_TABLE</code></td>
</tr>
<tr>
<td><code>AVG_ROW_LENGTH</code></td>
<td><code>OPEN_FULL_TABLE</code></td>
</tr>
<tr>
<td><code>DATA_LENGTH</code></td>
<td><code>OPEN_FULL_TABLE</code></td>
</tr>
<tr>
<td><code>MAX_DATA_LENGTH</code></td>
<td><code>OPEN_FULL_TABLE</code></td>
</tr>
<tr>
<td><code>INDEX_LENGTH</code></td>
<td><code>OPEN_FULL_TABLE</code></td>
</tr>
<tr>
<td><code>DATA_FREE</code></td>
<td><code>OPEN_FULL_TABLE</code></td>
</tr>
<tr>
<td><code>AUTO_INCREMENT</code></td>
<td><code>OPEN_FULL_TABLE</code></td>
</tr>
<tr>
<td><code>CREATE_TIME</code></td>
<td><code>OPEN_FULL_TABLE</code></td>
</tr>
<tr>
<td><code>UPDATE_TIME</code></td>
<td><code>OPEN_FULL_TABLE</code></td>
</tr>
<tr>
<td><code>CHECK_TIME</code></td>
<td><code>OPEN_FULL_TABLE</code></td>
</tr>
<tr>
<td><code>TABLE_COLLATION</code></td>
<td><code>OPEN_FRM_ONLY</code></td>
</tr>
<tr>
<td><code>CHECKSUM</code></td>
<td><code>OPEN_FULL_TABLE</code></td>
</tr>
<tr>
<td><code>CREATE_OPTIONS</code></td>
<td><code>OPEN_FRM_ONLY</code></td>
</tr>
<tr>
<td><code>TABLE_COMMENT</code></td>
<td><code>OPEN_FRM_ONLY</code></td>
</tr>
</tbody></table>
</li>
</ul>
<ul>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/table-constraints-table.html" target="_blank" rel="noopener"><code>TABLE_CONSTRAINTS</code></a>： <code>OPEN_FULL_TABLE</code>适用于所有列</p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/triggers-table.html" target="_blank" rel="noopener"><code>TRIGGERS</code></a>： <code>OPEN_TRIGGER_ONLY</code>适用于所有列</p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/views-table.html" target="_blank" rel="noopener"><code>VIEWS</code></a>：</p>
<table>
<thead>
<tr>
<th>柱</th>
<th>优化类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>TABLE_CATALOG</code></td>
<td><code>OPEN_FRM_ONLY</code></td>
</tr>
<tr>
<td><code>TABLE_SCHEMA</code></td>
<td><code>OPEN_FRM_ONLY</code></td>
</tr>
<tr>
<td><code>TABLE_NAME</code></td>
<td><code>OPEN_FRM_ONLY</code></td>
</tr>
<tr>
<td><code>VIEW_DEFINITION</code></td>
<td><code>OPEN_FRM_ONLY</code></td>
</tr>
<tr>
<td><code>CHECK_OPTION</code></td>
<td><code>OPEN_FRM_ONLY</code></td>
</tr>
<tr>
<td><code>IS_UPDATABLE</code></td>
<td><code>OPEN_FULL_TABLE</code></td>
</tr>
<tr>
<td><code>DEFINER</code></td>
<td><code>OPEN_FRM_ONLY</code></td>
</tr>
<tr>
<td><code>SECURITY_TYPE</code></td>
<td><code>OPEN_FRM_ONLY</code></td>
</tr>
<tr>
<td><code>CHARACTER_SET_CLIENT</code></td>
<td><code>OPEN_FRM_ONLY</code></td>
</tr>
<tr>
<td><code>COLLATION_CONNECTION</code></td>
<td><code>OPEN_FRM_ONLY</code></td>
</tr>
</tbody></table>
</li>
</ul>
<p><strong>3） EXPLAIN用于确定服务器是否可以INFORMATION_SCHEMA 对查询使用优化</strong></p>
<p>这尤其适用 <code>INFORMATION_SCHEMA</code>于从多个数据库中搜索信息的查询，这可能需要很长时间并影响性能。输出中的<code>Extra</code>值<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>指示服务器可以使用哪些（如果有的话）前面所述的优化来评估<code>INFORMATION_SCHEMA</code> 查询。以下示例演示了您期望在<code>Extra</code>值中看到的各种信息 。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT TABLE_NAME FROM INFORMATION_SCHEMA.VIEWS WHERE</span><br><span class="line">       TABLE_SCHEMA = 'test' AND TABLE_NAME = 'v1'\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: VIEWS</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: TABLE_SCHEMA,TABLE_NAME</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: NULL</span><br><span class="line">        Extra: Using where; Open_frm_only; Scanned 0 databases</span><br></pre></td></tr></table></figure>

<p>使用恒定的数据库和表查找值可使服务器避免目录扫描。对于的引用 <code>VIEWS.TABLE_NAME</code>，仅 <code>.frm</code>需要打开文件。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT TABLE_NAME, ROW_FORMAT FROM INFORMATION_SCHEMA.TABLES\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: TABLES</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: NULL</span><br><span class="line">        Extra: Open_full_table; Scanned all databases</span><br></pre></td></tr></table></figure>

<p>没有提供查找值（没有 <code>WHERE</code>子句），因此服务器必须扫描数据目录和每个数据库目录。对于这样标识的每个表，选择表名和行格式。 <code>TABLE_NAME</code>不需要打开其他表文件（<code>SKIP_OPEN_TABLE</code>适用优化）。<code>ROW_FORMAT</code>要求打开所有表文件（<code>OPEN_FULL_TABLE</code>适用）。 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>报告说， <code>OPEN_FULL_TABLE</code>因为它比贵<code>SKIP_OPEN_TABLE</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT TABLE_NAME, TABLE_TYPE FROM INFORMATION_SCHEMA.TABLES</span><br><span class="line">       WHERE TABLE_SCHEMA = 'test'\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: TABLES</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: TABLE_SCHEMA</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: NULL</span><br><span class="line">        Extra: Using where; Open_frm_only; Scanned 1 database</span><br></pre></td></tr></table></figure>

<p>No table name lookup value is provided, so the server must scan the <code>test</code> database directory. For the <code>TABLE_NAME</code> and <code>TABLE_TYPE</code> columns, the <code>SKIP_OPEN_TABLE</code> and <code>OPEN_FRM_ONLY</code> optimizations apply, respectively. <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a> reports <code>OPEN_FRM_ONLY</code> because it is more expensive.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT B.TABLE_NAME</span><br><span class="line">       FROM INFORMATION_SCHEMA.TABLES AS A, INFORMATION_SCHEMA.COLUMNS AS B</span><br><span class="line">       WHERE A.TABLE_SCHEMA = 'test'</span><br><span class="line">       AND A.TABLE_NAME = 't1'</span><br><span class="line">       AND B.TABLE_NAME = A.TABLE_NAME\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: A</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: TABLE_SCHEMA,TABLE_NAME</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: NULL</span><br><span class="line">        Extra: Using where; Skip_open_table; Scanned 0 databases</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: B</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: NULL</span><br><span class="line">        Extra: Using where; Open_frm_only; Scanned all databases;</span><br><span class="line">               Using join buffer</span><br></pre></td></tr></table></figure>

<p>For the first <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a> output row: Constant database and table lookup values enable the server to avoid directory scans for <code>TABLES</code> values. References to <code>TABLES.TABLE_NAME</code> require no further table files.</p>
<p>For the second <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a> output row: All <a href="https://dev.mysql.com/doc/refman/5.7/en/columns-table.html" target="_blank" rel="noopener"><code>COLUMNS</code></a> table values are <code>OPEN_FRM_ONLY</code> lookups, so <code>COLUMNS.TABLE_NAME</code> requires the <code>.frm</code> file to be opened.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM INFORMATION_SCHEMA.COLLATIONS\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: COLLATIONS</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: NULL</span><br><span class="line">        Extra:</span><br></pre></td></tr></table></figure>

<p>在这种情况下，由于<a href="https://dev.mysql.com/doc/refman/5.7/en/collations-table.html" target="_blank" rel="noopener"><code>COLLATIONS</code></a>没有<code>INFORMATION_SCHEMA</code>可用的优化表之一，因此不 应用 优化。</p>
<h3 id="8-2-4优化数据更改语句"><a href="#8-2-4优化数据更改语句" class="headerlink" title="8.2.4优化数据更改语句"></a>8.2.4优化数据更改语句</h3><ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/insert-optimization.html" target="_blank" rel="noopener">8.2.4.1优化INSERT语句</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/update-optimization.html" target="_blank" rel="noopener">8.2.4.2优化UPDATE语句</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/delete-optimization.html" target="_blank" rel="noopener">8.2.4.3优化DELETE语句</a></li>
</ul>
<p>这部分解释了如何加快数据更改语句： <a href="https://dev.mysql.com/doc/refman/5.7/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a>，和 <a href="https://dev.mysql.com/doc/refman/5.7/en/delete.html" target="_blank" rel="noopener"><code>DELETE</code></a>。传统的OLTP应用程序和现代Web应用程序通常会执行许多小的数据更改操作，而这些操作对并发至关重要。数据分析和报告应用程序通常运行会同时影响许多行的数据更改操作，其中主要考虑因素是I / O以写入大量数据并保持索引为最新。为了插入和更新大量数据（在业界称为ETL，即 “ extract-transform-load ”），有时您可以使用其他SQL语句或外部命令来模拟 <a href="https://dev.mysql.com/doc/refman/5.7/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/delete.html" target="_blank" rel="noopener"><code>DELETE</code></a>语句。</p>
<h4 id="8-2-4-1优化INSERT语句"><a href="#8-2-4-1优化INSERT语句" class="headerlink" title="8.2.4.1优化INSERT语句"></a>8.2.4.1优化INSERT语句</h4><p>插入行所需的时间由以下因素决定，其中数字表示近似比例：</p>
<ul>
<li>连接：（3）</li>
<li>向服务器发送查询：（2）</li>
<li>解析查询：（2）</li>
<li>插入行：（1×行大小）</li>
<li>插入索引：（1×索引数）</li>
<li>闭幕：（1）</li>
</ul>
<p>这没有考虑打开表的初始开销，对于每个并发运行的查询，该开销只需要执行一次即可。</p>
<p><em>N</em>假设B树索引， 表的大小会减慢按log插入索引的速度。</p>
<p>您可以使用以下方法来加快插入速度：</p>
<ul>
<li>如果要同时从同一客户端插入许多行，请使用<a href="https://dev.mysql.com/doc/refman/5.7/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a> 具有多个<code>VALUES</code>列表的语句一次插入几行。这比使用单独的单行<a href="https://dev.mysql.com/doc/refman/5.7/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a> 语句要快得多（某些情况下要快很多倍）。如果要将数据添加到非空表，则可以调整 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_bulk_insert_buffer_size" target="_blank" rel="noopener"><code>bulk_insert_buffer_size</code></a> 变量以使数据插入更快。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html" target="_blank" rel="noopener">第5.1.7节“服务器系统变量”</a>。</li>
<li>从文本文件加载表格时，请使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/load-data.html" target="_blank" rel="noopener"><code>LOAD DATA</code></a>。这通常比使用<a href="https://dev.mysql.com/doc/refman/5.7/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>语句快20倍 。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/load-data.html" target="_blank" rel="noopener">第13.2.6节“ LOAD DATA语句”</a>。</li>
<li>利用列具有默认值的事实。仅当要插入的值与默认值不同时才明确插入值。这减少了MySQL必须执行的解析，并提高了插入速度。</li>
<li>请参阅<a href="https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-bulk-data-loading.html" target="_blank" rel="noopener">第8.5.5节“为InnoDB表加载大数据”，</a> 以获取特定于<code>InnoDB</code>表的提示。</li>
<li>有关 特定于表的提示<a href="https://dev.mysql.com/doc/refman/5.7/en/optimizing-myisam-bulk-data-loading.html" target="_blank" rel="noopener">，</a>请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/optimizing-myisam-bulk-data-loading.html" target="_blank" rel="noopener">第8.6.2节“为MyISAM表批量加载数据”</a><code>MyISAM</code>。</li>
</ul>
<h4 id="8-2-4-2优化UPDATE语句"><a href="#8-2-4-2优化UPDATE语句" class="headerlink" title="8.2.4.2优化UPDATE语句"></a>8.2.4.2优化UPDATE语句</h4><p>优化了更新语句<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>，使其像 查询一样具有额外的写操作开销。写入速度取决于要更新的数据量和要更新的索引数。不变的索引不会更新。</p>
<p>获得快速更新的另一种方法是延迟更新，然后在以后连续进行许多更新。如果锁定表，一起执行多个更新要比一次执行一次更新快得多。</p>
<p>对于<code>MyISAM</code>使用动态行格式的表，将行更新为更长的总长度可能会拆分该行。如果您经常这样做，那么<a href="https://dev.mysql.com/doc/refman/5.7/en/optimize-table.html" target="_blank" rel="noopener"><code>OPTIMIZE TABLE</code></a>偶尔使用非常重要 。请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/optimize-table.html" target="_blank" rel="noopener">第13.7.2.4节“ OPTIMIZE TABLE语句”</a>。</p>
<h4 id="8-2-4-3优化DELETE语句"><a href="#8-2-4-3优化DELETE语句" class="headerlink" title="8.2.4.3优化DELETE语句"></a>8.2.4.3优化DELETE语句</h4><p>删除<code>MyISAM</code>表中的各个行所需的时间 与索引数成正比。若要更快地删除行，可以通过增加<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_key_buffer_size" target="_blank" rel="noopener"><code>key_buffer_size</code></a>系统变量来增加键高速缓存的大小 。请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/server-configuration.html" target="_blank" rel="noopener">第5.1.1节“配置服务器”</a>。</p>
<p>要删除<code>MyISAM</code>表中的所有行， 速度比快 。截断操作不是事务安全的；在活动事务或活动表锁定过程中尝试执行一个错误时发生错误。请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/truncate-table.html" target="_blank" rel="noopener">第13.1.34节“ TRUNCATE TABLE语句”</a>。 <code>TRUNCATE TABLE *tbl_name*``DELETE FROM *tbl_name*</code></p>
<h3 id="8-2-5优化数据库特权"><a href="#8-2-5优化数据库特权" class="headerlink" title="8.2.5优化数据库特权"></a>8.2.5优化数据库特权</h3><p>权限设置越复杂，所有SQL语句的开销就越大。简化由<a href="https://dev.mysql.com/doc/refman/5.7/en/grant.html" target="_blank" rel="noopener"><code>GRANT</code></a>语句建立的特权 可使MySQL减少客户端执行语句时的权限检查开销。例如，如果您不授予任何表级或列级特权，则服务器无需检查<code>tables_priv</code>和 <code>columns_priv</code>表的内容。同样，如果您没有对任何帐户设置资源限制，则服务器不必执行资源计数。如果您有很高的语句处理负载，请考虑使用简化的授权结构以减少权限检查的开销。</p>
<h3 id="8-2-6其他优化技巧"><a href="#8-2-6其他优化技巧" class="headerlink" title="8.2.6其他优化技巧"></a>8.2.6其他优化技巧</h3><ul>
<li><p>如果您的应用程序发出多个数据库请求以执行相关更新，则将这些语句组合到存储的例程中可以提高性能。同样，如果您的应用程序根据多个列值或大量数据计算单个结果，则将计算结果合并到UDF（用户定义的函数）中可以提高性能。然后，产生的快速数据库操作可用于其他查询，应用程序，甚至可以用不同的编程语言编写的代码重用。有关更多信息<a href="https://dev.mysql.com/doc/refman/5.7/en/stored-routines.html" target="_blank" rel="noopener">，</a>请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/stored-routines.html" target="_blank" rel="noopener">第23.2节“使用存储的例程”</a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/adding-functions.html" target="_blank" rel="noopener">第28.4节“向MySQL添加函数”</a>。</p>
</li>
<li><p>要解决<code>ARCHIVE</code>表出现的任何压缩问题 ，请使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/optimize-table.html" target="_blank" rel="noopener"><code>OPTIMIZE TABLE</code></a>。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/archive-storage-engine.html" target="_blank" rel="noopener">第15.5节“ ARCHIVE存储引擎”</a>。</p>
</li>
<li><p>如果可能，将报告分类为“ 实时 ”或 “ 统计 ”，其中统计报告所需的数据仅从根据实时数据定期生成的汇总表中创建。</p>
</li>
<li><p>如果您的数据与行和列的表结构不一致，则可以将数据打包并将其存储到<a href="https://dev.mysql.com/doc/refman/5.7/en/blob.html" target="_blank" rel="noopener"><code>BLOB</code></a>列中。在这种情况下，您必须在应用程序中提供代码以打包和解压缩信息，但这可能会节省I / O操作以读取和写入相关值集。</p>
</li>
<li><p>对于Web服务器，将图像和其他二进制资产存储为文件，路径名存储在数据库中，而不是文件本身。大多数Web服务器在缓存文件方面比在数据库内容上更好，因此使用文件通常更快。（尽管在这种情况下，您必须自己处理备份和存储问题。）</p>
</li>
<li><p>如果您确实需要很高的速度，请查看底层的MySQL接口。例如，通过直接访问MySQL <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html" target="_blank" rel="noopener"><code>InnoDB</code></a>或 <a href="https://dev.mysql.com/doc/refman/5.7/en/myisam-storage-engine.html" target="_blank" rel="noopener"><code>MyISAM</code></a>存储引擎，与使用SQL接口相比，可以大大提高速度。</p>
<p>同样，对于使用<a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-cluster.html" target="_blank" rel="noopener"><code>NDBCLUSTER</code></a>存储引擎的数据库 ，您可能希望研究NDB API的可能用法（请参阅《 <a href="https://dev.mysql.com/doc/ndbapi/en/" target="_blank" rel="noopener">MySQL NDB Cluster API开发人员指南》</a>）。</p>
</li>
<li><p>复制可以为某些操作提供性能优势。您可以在复制服务器之间分配客户端检索，以分散负载。为避免在备份时降低主服务器的速度，可以使用从服务器进行备份。请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/replication.html" target="_blank" rel="noopener">第16章，<em>复制</em></a>。</p>
</li>
</ul>
<h2 id="8-3优化和索引"><a href="#8-3优化和索引" class="headerlink" title="8.3优化和索引"></a>8.3优化和索引</h2><ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-indexes.html" target="_blank" rel="noopener">8.3.1 MySQL如何使用索引</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/primary-key-optimization.html" target="_blank" rel="noopener">8.3.2主键优化</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/foreign-key-optimization.html" target="_blank" rel="noopener">8.3.3外键优化</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/column-indexes.html" target="_blank" rel="noopener">8.3.4列索引</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/multiple-column-indexes.html" target="_blank" rel="noopener">8.3.5多列索引</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/verifying-index-usage.html" target="_blank" rel="noopener">8.3.6验证索引使用情况</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/index-statistics.html" target="_blank" rel="noopener">8.3.7 InnoDB和MyISAM索引统计信息收集</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/index-btree-hash.html" target="_blank" rel="noopener">8.3.8 B树和哈希索引的比较</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/index-extensions.html" target="_blank" rel="noopener">8.3.9索引扩展的使用</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/generated-column-index-optimizations.html" target="_blank" rel="noopener">8.3.10优化器对生成的列索引的使用</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/timestamp-lookups.html" target="_blank" rel="noopener">8.3.11从TIMESTAMP列进行索引查找</a></li>
</ul>
<p>改善操作性能的最佳方法 <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>是在查询中测试的一个或多个列上创建索引。索引条目的作用类似于指向表行的指针，从而使查询可以快速确定哪些行与<code>WHERE</code>子句中的条件匹配，并检索这些行的其他列值。所有MySQL数据类型都可以建立索引。</p>
<p>尽管可能会为查询中使用的每个可能的列创建索引，但是不必要的索引会浪费空间和时间，使MySQL难以确定要使用的索引。索引还会增加插入，更新和删除的成本，因为必须更新每个索引。您必须找到适当的平衡，才能使用最佳索引集来实现快速查询。</p>
<h3 id="8-3-1-MySQL如何使用索引"><a href="#8-3-1-MySQL如何使用索引" class="headerlink" title="8.3.1 MySQL如何使用索引"></a>8.3.1 MySQL如何使用索引</h3><p>索引用于快速查找具有特定列值的行。没有索引，MySQL必须从第一行开始，然后通读整个表以找到相关的行。桌子越大，花费越多。如果表中有相关列的索引，MySQL可以快速确定要在数据文件中间查找的位置，而不必查看所有数据。这比顺序读取每一行要快得多。</p>
<p>大多数MySQL索引（<code>PRIMARY KEY</code>， <code>UNIQUE</code>，<code>INDEX</code>和 <code>FULLTEXT</code>）存储在 <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_b_tree" target="_blank" rel="noopener">B树</a>。例外：空间数据类型的索引使用R树；<code>MEMORY</code> 表还支持<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_hash_index" target="_blank" rel="noopener">哈希索引</a> ; <code>InnoDB</code>对<code>FULLTEXT</code>索引使用倒排列表。</p>
<p>通常，如以下讨论中所述使用索引。<a href="https://dev.mysql.com/doc/refman/5.7/en/index-btree-hash.html" target="_blank" rel="noopener">第8.3.8节“ B树和哈希索引的比较”</a><code>MEMORY</code>中介绍了哈希索引特有的特性（如表中所用 ） 。</p>
<p>MySQL使用索引进行以下操作：</p>
<ul>
<li><p><code>WHERE</code>快速 查找与子句匹配的行。</p>
</li>
<li><p>从考虑中消除行。如果可以在多个索引之间进行选择，MySQL通常会使用找到最少行数的索引（最具 <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_selectivity" target="_blank" rel="noopener">选择性的</a>索引）。</p>
</li>
<li><p>如果表具有多列索引，那么优化器可以使用索引的任何最左前缀来查找行。举例来说，如果你有一个三列的索引 <code>(col1, col2, col3)</code>，你有索引的搜索功能<code>(col1)</code>， <code>(col1, col2)</code>以及<code>(col1, col2, col3)</code>。有关更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/multiple-column-indexes.html" target="_blank" rel="noopener">第8.3.5节“多列索引”</a>。</p>
</li>
<li><p>执行联接时从其他表中检索行。如果声明相同的类型和大小，MySQL可以更有效地在列上使用索引。在这种情况下， <a href="https://dev.mysql.com/doc/refman/5.7/en/char.html" target="_blank" rel="noopener"><code>VARCHAR</code></a>与 <a href="https://dev.mysql.com/doc/refman/5.7/en/char.html" target="_blank" rel="noopener"><code>CHAR</code></a>被认为是相同的，如果它们被声明为相同的大小。例如， <code>VARCHAR(10)</code>和 <code>CHAR(10)</code>是相同的大小，但是 <code>VARCHAR(10)</code>和 <code>CHAR(15)</code>不是。</p>
<p>为了在非二进制字符串列之间进行比较，两个列应使用相同的字符集。例如，将一<code>utf8</code>列与一 <code>latin1</code>列进行比较会排除使用索引。</p>
<p>Comparison of dissimilar columns (comparing a string column to a temporal or numeric column, for example) may prevent use of indexes if values cannot be compared directly without conversion. For a given value such as <code>1</code> in the numeric column, it might compare equal to any number of values in the string column such as <code>&#39;1&#39;</code>, <code>&#39; 1&#39;</code>, <code>&#39;00001&#39;</code>, or <code>&#39;01.e1&#39;</code>. This rules out use of any indexes for the string column.</p>
</li>
<li><p>查找特定索引列的<a href="https://dev.mysql.com/doc/refman/5.7/en/aggregate-functions.html#function_min" target="_blank" rel="noopener"><code>MIN()</code></a>或 <a href="https://dev.mysql.com/doc/refman/5.7/en/aggregate-functions.html#function_max" target="_blank" rel="noopener"><code>MAX()</code></a>值<em>key_col*。这由预处理器优化，该预处理器检查您是否正在 索引中之前出现的所有关键部分上使用。在这种情况下，MySQL为每个表达式或 表达式执行一次键查找，并将其替换为常量。如果所有表达式都用常量替换，查询将立即返回。例如： `WHERE *key_part_N</em> = <em>constant<em>`</em>key_col</em><a href="https://dev.mysql.com/doc/refman/5.7/en/aggregate-functions.html#function_min" target="_blank" rel="noopener"><code>MIN()</code></a><a href="https://dev.mysql.com/doc/refman/5.7/en/aggregate-functions.html#function_max" target="_blank" rel="noopener"><code>MAX()</code></a></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MIN</span>(key_part2),<span class="keyword">MAX</span>(key_part2)</span><br><span class="line">  <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> key_part1=<span class="number">10</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果排序或分组是在可用索引的最左前缀（例如）上完成的，则对表进行排序或分组 。如果所有关键部分后面都有，则按相反的顺序读取密钥。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/order-by-optimization.html" target="_blank" rel="noopener">第8.2.1.14节“按优化</a><a href="https://dev.mysql.com/doc/refman/5.7/en/group-by-optimization.html" target="_blank" rel="noopener">排序”</a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/group-by-optimization.html" target="_blank" rel="noopener">第8.2.1.15节“按优化分组”</a>。 <code>ORDER BY *key_part1*, *key_part2*``DESC</code></p>
</li>
<li><p>在某些情况下，可以优化查询以检索值而无需查询数据行。（为查询提供所有必要结果的<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_covering_index" target="_blank" rel="noopener">索引</a>称为 <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_covering_index" target="_blank" rel="noopener">覆盖索引</a>。）如果查询仅从表中使用某些索引中包含的列，则可以从索引树中检索所选值，以提高速度：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> key_part3 <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> key_part1=<span class="number">1</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>对于报表查询处理大多数或所有行的小型表或大型表，索引的重要性不那么重要。当查询需要访问大多数行时，顺序读取要比处理索引快。顺序读取可以最大程度地减少磁盘查找，即使查询不需要所有行。有关详细信息<a href="https://dev.mysql.com/doc/refman/5.7/en/table-scan-avoidance.html" target="_blank" rel="noopener">，</a>请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/table-scan-avoidance.html" target="_blank" rel="noopener">第8.2.1.20节“避免全表扫描”</a>。</p>
<h3 id="8-3-2主键优化"><a href="#8-3-2主键优化" class="headerlink" title="8.3.2主键优化"></a>8.3.2主键优化</h3><p>表的主键代表您在最重要的查询中使用的一列或几列。它具有关联的索引，可提高查询性能。查询性能可从<code>NOT NULL</code>优化中受益，因为它不能包含任何<code>NULL</code>值。使用<code>InnoDB</code>存储引擎，可以对表数据进行物理组织，以根据一个或多个主键列进行超快速查找和排序。</p>
<p>如果您的表又大又重要，但没有明显的列或一组列用作主键，则可以创建一个单独的列，并使用自动增量值作为主键。当您使用外键联接表时，这些唯一的ID可用作指向其他表中相应行的指针。</p>
<h3 id="8-3-3外键优化"><a href="#8-3-3外键优化" class="headerlink" title="8.3.3外键优化"></a>8.3.3外键优化</h3><p>如果一个表有许多列，并且您查询了许多不同的列组合，将不常用的数据拆分成单独的表（每个表包含几列），然后通过复制数字ID将它们关联回主表可能会比较有效。主表中的列。这样，每个小表都可以具有用于快速查找其数据的主键，并且您可以使用联接操作仅查询所需的一组列。根据相关数据的分布方式，查询可能执行较少的I / O并占用较少的缓存，因为相关的列在磁盘上打包在一起。（为了最大化性能，查询尝试从磁盘读取尽可能少的数据块；</p>
<h3 id="8-3-4列索引"><a href="#8-3-4列索引" class="headerlink" title="8.3.4列索引"></a>8.3.4列索引</h3><p>索引的最常见类型涉及单个列，该列将来自该列的值的副本存储在数据结构中，从而允许快速查找具有相应列值的行。B树数据结构可以让索引快速查找特定值，一组值，或值的范围，对应于运营商，如<code>=</code>， <code>&gt;</code>，<code>≤</code>， <code>BETWEEN</code>，<code>IN</code>，等等，一在<code>WHERE</code>子句。</p>
<p>每个存储引擎定义每个表的最大索引数和最大索引长度。请参阅 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html" target="_blank" rel="noopener">第14章，<em>InnoDB存储引擎</em></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/storage-engines.html" target="_blank" rel="noopener">第15章，<em>备用存储引擎</em></a>。所有存储引擎每个表至少支持16个索引，并且总索引长度至少为256个字节。大多数存储引擎都有更高的限制。</p>
<p>有关列索引的更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/create-index.html" target="_blank" rel="noopener">第13.1.14节“ CREATE INDEX语句”</a>。</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/column-indexes.html#column-indexes-prefix" target="_blank" rel="noopener">索引前缀</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/column-indexes.html#column-indexes-fulltext" target="_blank" rel="noopener">全文索引</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/column-indexes.html#column-indexes-spatial" target="_blank" rel="noopener">空间指数</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/column-indexes.html#column-indexes-memory-storage-engine" target="_blank" rel="noopener">MEMORY存储引擎中的索引</a></li>
</ul>
<h4 id="索引前缀"><a href="#索引前缀" class="headerlink" title="索引前缀"></a>索引前缀</h4><p>使用 字符串列的索引规范中的语法，您可以创建仅使用列首字符的索引 。以这种方式仅索引列值的前缀可以使索引文件小得多。为a 或 column 编制索引时 ， <em>必须<em>为索引指定前缀长度。例如： `</em>col_name</em>(<em>N</em>)<code>*N*[</code>BLOB<code>](https://dev.mysql.com/doc/refman/5.7/en/blob.html)[</code>TEXT`](<a href="https://dev.mysql.com/doc/refman/5.7/en/blob.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/blob.html</a>)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">test</span> (blob_col <span class="built_in">BLOB</span>, <span class="keyword">INDEX</span>(blob_col(<span class="number">10</span>)));</span><br></pre></td></tr></table></figure>

<p>前缀最长可以为1000个字节（<code>InnoDB</code>表中为767个字节 ，除非已 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_large_prefix" target="_blank" rel="noopener"><code>innodb_large_prefix</code></a>设置）。</p>
<p>注意</p>
<p>前缀限制以字节为单位，而在前缀长度<a href="https://dev.mysql.com/doc/refman/5.7/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/create-index.html" target="_blank" rel="noopener"><code>CREATE INDEX</code></a>语句被解释为非二进制串类型的字符数（<a href="https://dev.mysql.com/doc/refman/5.7/en/char.html" target="_blank" rel="noopener"><code>CHAR</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/char.html" target="_blank" rel="noopener"><code>VARCHAR</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/blob.html" target="_blank" rel="noopener"><code>TEXT</code></a>对于二进制串类型），并且字节数（<a href="https://dev.mysql.com/doc/refman/5.7/en/binary-varbinary.html" target="_blank" rel="noopener"><code>BINARY</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/binary-varbinary.html" target="_blank" rel="noopener"><code>VARBINARY</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/blob.html" target="_blank" rel="noopener"><code>BLOB</code></a>）。为使用多字节字符集的非二进制字符串列指定前缀长度时，请考虑到这一点。</p>
<p>如果搜索词超过索引前缀长度，则使用索引排除不匹配的行，然后检查其余行是否可能匹配。</p>
<p>有关索引前缀的更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/create-index.html" target="_blank" rel="noopener">第13.1.14节“ CREATE INDEX语句”</a>。</p>
<h4 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h4><p>优化适用于<code>FULLTEXT</code>针对单个<code>InnoDB</code>表的某些类型的 查询 。具有以下特征的查询特别有效：</p>
<ul>
<li><code>FULLTEXT</code> 仅返回文档ID或文档ID和搜索等级的查询。</li>
<li><code>FULLTEXT</code>查询以分数的降序对匹配行进行排序，并应用一个 <code>LIMIT</code>子句以获取前N个匹配行。为了应用此优化，必须没有 <code>WHERE</code>子句，只有一个 <code>ORDER BY</code>子句按降序排列。</li>
<li><code>FULLTEXT</code>仅检索<code>COUNT(*)</code>与搜索词匹配的行的 值的查询，没有其他<code>WHERE</code> 子句。将该<code>WHERE</code>子句编码为 ，没有任何比较运算符。 <code>WHERE MATCH(*text*) AGAINST (&#39;*other_text*&#39;)``&gt; 0</code></li>
</ul>
<p>对于包含全文表达式的查询，MySQL在查询执行的优化阶段评估这些表达式。优化器不仅查看全文表达式并进行估计，而且还在制定执行计划的过程中对它们进行评估。</p>
<p>这种行为的含义是， <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>与在优化阶段未进行任何表达式求值的非全文查询相比，全文查询通常要慢。</p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>由于优化期间发生匹配<code>Select tables optimized away</code>，因此全文查询可能会显示在该<code>Extra</code>列中；在这种情况下，在以后的执行期间不需要进行表访问。</p>
<h4 id="空间指数"><a href="#空间指数" class="headerlink" title="空间指数"></a>空间指数</h4><p>您可以在空间数据类型上创建索引。 <code>MyISAM</code>并<code>InnoDB</code> 支持有关空间类型的R树索引。其他存储引擎使用B树来索引空间类型（除外 <code>ARCHIVE</code>，不支持空间类型索引）。</p>
<h4 id="MEMORY存储引擎中的索引"><a href="#MEMORY存储引擎中的索引" class="headerlink" title="MEMORY存储引擎中的索引"></a>MEMORY存储引擎中的索引</h4><p>该<code>MEMORY</code>存储引擎使用 <code>HASH</code>默认的索引，而且还支持 <code>BTREE</code>索引。</p>
<h3 id="8-3-5多列索引"><a href="#8-3-5多列索引" class="headerlink" title="8.3.5多列索引"></a>8.3.5多列索引</h3><p>MySQL可以创建复合索引（即，多列上的索引）。一个索引最多可以包含16列。对于某些数据类型，您可以为列的前缀编制索引（请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/column-indexes.html" target="_blank" rel="noopener">第8.3.4节“列索引”</a>）。</p>
<p>MySQL可以将多列索引用于测试索引中所有列的查询，或者仅测试第一列，前两列，前三列等等的查询。如果以正确的顺序在索引定义中指定列，则单个复合索引可以加快对同一表的几种查询。</p>
<p>多列索引可以被认为是排序数组，其行包含通过串联索引列的值而创建的值。</p>
<p>注意</p>
<p>作为复合索引的替代方法，您可以根据其他列中的信息引入被“ 哈希化 ”的列。如果此列短，合理地唯一并且已建立索引，则它可能比许多列上的“ 宽 ”索引快。在MySQL中，使用此额外的列非常容易：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> hash_col=<span class="keyword">MD5</span>(<span class="keyword">CONCAT</span>(val1,val2))</span><br><span class="line">  <span class="keyword">AND</span> col1=val1 <span class="keyword">AND</span> col2=val2;</span><br></pre></td></tr></table></figure>

<p>假设一个表具有以下规范：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">test</span> (</span><br><span class="line">    <span class="keyword">id</span>         <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    last_name  <span class="built_in">CHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    first_name <span class="built_in">CHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>),</span><br><span class="line">    <span class="keyword">INDEX</span> <span class="keyword">name</span> (last_name,first_name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>该<code>name</code>指数是在一个索引 <code>last_name</code>和<code>first_name</code> 列。该索引可用于查询中的查找，这些查询指定在已知范围内的<code>last_name</code>和<code>first_name</code> 值组合的 值。它也可以用于仅指定<code>last_name</code>值的查询， 因为该列是索引的最左前缀（如本节稍后所述）。因此，该<code>name</code>索引用于以下查询中的查找：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">test</span> <span class="keyword">WHERE</span> last_name=<span class="string">'Jones'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">test</span></span><br><span class="line">  <span class="keyword">WHERE</span> last_name=<span class="string">'Jones'</span> <span class="keyword">AND</span> first_name=<span class="string">'John'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">test</span></span><br><span class="line">  <span class="keyword">WHERE</span> last_name=<span class="string">'Jones'</span></span><br><span class="line">  <span class="keyword">AND</span> (first_name=<span class="string">'John'</span> <span class="keyword">OR</span> first_name=<span class="string">'Jon'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">test</span></span><br><span class="line">  <span class="keyword">WHERE</span> last_name=<span class="string">'Jones'</span></span><br><span class="line">  <span class="keyword">AND</span> first_name &gt;=<span class="string">'M'</span> <span class="keyword">AND</span> first_name &lt; <span class="string">'N'</span>;</span><br></pre></td></tr></table></figure>

<p>但是，在以下查询中，<code>name</code>索引 <em>不</em>用于查找：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">test</span> <span class="keyword">WHERE</span> first_name=<span class="string">'John'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">test</span></span><br><span class="line">  <span class="keyword">WHERE</span> last_name=<span class="string">'Jones'</span> <span class="keyword">OR</span> first_name=<span class="string">'John'</span>;</span><br></pre></td></tr></table></figure>

<p>假设您发出以下 <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> col1=val1 <span class="keyword">AND</span> col2=val2;</span><br></pre></td></tr></table></figure>

<p>如果<code>col1</code>和上 存在多列索引<code>col2</code>，则可以直接获取相应的行。如果<code>col1</code>和上存在单独的单列索引 <code>col2</code>，那么优化器将尝试使用索引合并优化（请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/index-merge-optimization.html" target="_blank" rel="noopener">第8.2.1.3节“索引合并优化”</a>），或者尝试通过确定哪个索引排除更多行并使用来查找限制性最强的索引。该索引以获取行。</p>
<p>如果列不构成索引的最左前缀，则MySQL无法使用索引执行查找。假设您具有以下<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>所示的语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> col1=val1;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> col1=val1 <span class="keyword">AND</span> col2=val2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> col2=val2;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> col2=val2 <span class="keyword">AND</span> col3=val3;</span><br></pre></td></tr></table></figure>

<p>如果存在索引<code>(col1, col2, col3)</code>，则仅前两个查询使用索引。第三个查询和第四个查询确实涉及索引列，但是不使用索引来执行查找，因为<code>(col2)</code>和 <code>(col2, col3)</code>不是的最左前缀 <code>(col1, col2, col3)</code>。</p>
<h3 id="8-3-6验证索引使用情况"><a href="#8-3-6验证索引使用情况" class="headerlink" title="8.3.6验证索引使用情况"></a>8.3.6验证索引使用情况</h3><p>始终检查所有查询是否真的使用您在表中创建的索引。使用<a href="https://dev.mysql.com/doc/refman/5.7/en/using-explain.html" target="_blank" rel="noopener">第8.8.1节“使用EXPLAIN优化查询”中</a><a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>所述的 语句。</p>
<h3 id="8-3-7-InnoDB和MyISAM索引统计信息收集"><a href="#8-3-7-InnoDB和MyISAM索引统计信息收集" class="headerlink" title="8.3.7 InnoDB和MyISAM索引统计信息收集"></a>8.3.7 InnoDB和MyISAM索引统计信息收集</h3><p>存储引擎收集有关表的统计信息，以供优化器使用。表统计信息基于值组，其中值组是一组具有相同键前缀值的行。出于优化目的，重要的统计数据是平均值组的大小。</p>
<p>MySQL通过以下方式使用平均值组大小：</p>
<ul>
<li><p>估算每次<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_ref" target="_blank" rel="noopener"><code>ref</code></a>访问 必须读取多少行</p>
</li>
<li><p>估计部分联接将产生多少行；也就是说，这种形式的操作将产生的行数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(...) JOIN tbl_name ON tbl_name.key = expr</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>随着索引的平均值组大小的增加，该索引在这两个用途中的用处不大，因为每次查找的平均行数增加：为了使索引更好地用于优化目的，最好将每个索引值作为目标表中的行数。当给定的索引值产生大量的行时，该索引的作用较小，而MySQL不太可能使用该索引。</p>
<p>平均值组的大小与表基数有关，表基数是值组的数目。该 <a href="https://dev.mysql.com/doc/refman/5.7/en/show-index.html" target="_blank" rel="noopener"><code>SHOW INDEX</code></a>语句显示基于的基数值<em>N/S</em>，其中 <em>N</em>是表中的行数，并且<em>S</em>是平均值组的大小。该比率在表中产生大约数量的值组。</p>
<p>对于基于联接<code>&lt;=&gt;</code>比较运营商，<code>NULL</code>没有从任何其它值区别对待：<code>NULL &lt;=&gt; NULL</code>，就像任何其他 。 <code>*N* &lt;=&gt; *N*</code><em>N</em></p>
<p>但是，对于基于<code>=</code>运算符的联接， <code>NULL</code>它与非<code>NULL</code>值是不同的： 当或 （或两者）均为 时不为真 。这会影响 以下形式的比较访问：如果的当前值是，MySQL将不会访问表 ，因为比较不能为真。 <code>*expr1* = *expr2*</code><em>expr1*<em>expr2</em><code>NULL</code><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_ref" target="_blank" rel="noopener"><code>ref</code></a>`*tbl_name.key</em> = <em>expr</em><code>*expr*</code>NULL`</p>
<p>为了<code>=</code>进行比较，<code>NULL</code>表中有多少个值都没有关系。为了优化目的，相关值是非<code>NULL</code>值组的平均大小。但是，MySQL当前不支持收集或使用该平均大小。</p>
<p>对于<code>InnoDB</code>和<code>MyISAM</code> 表，您分别可以通过<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_stats_method" target="_blank" rel="noopener"><code>innodb_stats_method</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_myisam_stats_method" target="_blank" rel="noopener"><code>myisam_stats_method</code></a>系统变量来控制表统计信息的收集 。这些变量具有三个可能的值，其区别如下：</p>
<ul>
<li><p>当变量设置为时<code>nulls_equal</code>，所有<code>NULL</code>值都被视为相同（即，它们全部形成一个值组）。</p>
<p>如果<code>NULL</code>值组大小比平均非<code>NULL</code>值组大小大得多，则此方法会使平均值组大小向上倾斜。这使得索引在优化器中似乎没有那么有用，而对于查找非<code>NULL</code>值的联接而言，索引的作用实际上不那么有用。因此，该 <code>nulls_equal</code>方法可能导致优化器<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_ref" target="_blank" rel="noopener"><code>ref</code></a>在应该使用索引时不使用索引进行 访问。</p>
</li>
<li><p>当变量设置为时 <code>nulls_unequal</code>，<code>NULL</code> 值将被认为是不同的。而是，每个 <code>NULL</code>值构成一个单独的大小为1的值组。</p>
<p>如果您有很多<code>NULL</code>值，则此方法会使平均值组的大小向下倾斜。如果平均非<code>NULL</code>值组大小很大，则将<code>NULL</code>每个值作为一组大小1进行计数会导致优化器高估查找非<code>NULL</code> 值的联接的索引值。因此，当其他方法可能更好时，该<code>nulls_unequal</code> 方法可能会导致优化器将此索引用于 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_ref" target="_blank" rel="noopener"><code>ref</code></a>查找。</p>
</li>
<li><p>将变量设置为时 <code>nulls_ignored</code>，<code>NULL</code> 将忽略值。</p>
</li>
</ul>
<p>如果您倾向于使用许多使用<code>&lt;=&gt;</code>而不是的联接 <code>=</code>，则 <code>NULL</code>值在比较中并不特殊，一个<code>NULL</code>等于另一个。在这种情况下，<code>nulls_equal</code>是适当的统计方法。</p>
<p>该<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_stats_method" target="_blank" rel="noopener"><code>innodb_stats_method</code></a>系统变量具有全局值; 该 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_myisam_stats_method" target="_blank" rel="noopener"><code>myisam_stats_method</code></a>系统变量有全局和会话值。设置全局值会影响从相应存储引擎收集表的统计信息。设置会话值只会影响当前客户端连接的统计信息收集。这意味着您可以通过将会话值设置为来强制使用给定的方法重新生成表的统计信息，而不会影响其他客户端 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_myisam_stats_method" target="_blank" rel="noopener"><code>myisam_stats_method</code></a>。</p>
<p>要重新生成<code>MyISAM</code>表统计信息，可以使用以下任何一种方法：</p>
<ul>
<li>执行<a href="https://dev.mysql.com/doc/refman/5.7/en/myisamchk.html" target="_blank" rel="noopener"><strong>myisamchk –stats_method = method_name –analyze</strong></a></li>
<li>更改表以使其统计信息过时（例如，插入一行然后将其删除），然后设置 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_myisam_stats_method" target="_blank" rel="noopener"><code>myisam_stats_method</code></a>并发出一条<a href="https://dev.mysql.com/doc/refman/5.7/en/analyze-table.html" target="_blank" rel="noopener"><code>ANALYZE TABLE</code></a> 语句</li>
</ul>
<p>关于使用的一些注意事项 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_stats_method" target="_blank" rel="noopener"><code>innodb_stats_method</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_myisam_stats_method" target="_blank" rel="noopener"><code>myisam_stats_method</code></a>：</p>
<ul>
<li>如前所述，您可以强制显式收集表统计信息。但是，MySQL可能还会自动收集统计信息。例如，如果在执行表语句的过程中，其中一些语句修改了表，则MySQL可能会收集统计信息。（例如，这可能发生在批量插入或删除操作或某些 <a href="https://dev.mysql.com/doc/refman/5.7/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>语句中。）如果发生这种情况，则使用任何值 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_stats_method" target="_blank" rel="noopener"><code>innodb_stats_method</code></a>或 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_myisam_stats_method" target="_blank" rel="noopener"><code>myisam_stats_method</code></a>当时有。因此，如果您使用一种方法收集统计信息，但是稍后稍后自动收集表的统计信息时，系统变量设置为另一种方法，则将使用另一种方法。</li>
<li>无法确定使用哪种方法为给定表生成统计信息。</li>
<li>这些变量仅适用于<code>InnoDB</code>和 <code>MyISAM</code>表。其他存储引擎只有一种收集表统计信息的方法。通常它更接近该<code>nulls_equal</code>方法。</li>
</ul>
<h3 id="8-3-8-B树和哈希索引的比较"><a href="#8-3-8-B树和哈希索引的比较" class="headerlink" title="8.3.8 B树和哈希索引的比较"></a>8.3.8 B树和哈希索引的比较</h3><ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/index-btree-hash.html#btree-index-characteristics" target="_blank" rel="noopener">B树索引特征</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/index-btree-hash.html#hash-index-characteristics" target="_blank" rel="noopener">哈希指数特征</a></li>
</ul>
<h4 id="B树索引特征"><a href="#B树索引特征" class="headerlink" title="B树索引特征"></a>B树索引特征</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> key_col <span class="keyword">LIKE</span> <span class="string">'Patrick%'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> key_col <span class="keyword">LIKE</span> <span class="string">'Pat%_ck%'</span>;</span><br></pre></td></tr></table></figure>

<p>在第一条语句中，仅考虑带有的行。在第二条语句中，仅考虑带有的行。 <code>&#39;Patrick&#39; &lt;= *key_col* &lt; &#39;Patricl&#39;``&#39;Pat&#39; &lt;= *key_col* &lt; &#39;Pau&#39;</code></p>
<p>以下<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>语句不使用索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> key_col <span class="keyword">LIKE</span> <span class="string">'%Patrick%'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> key_col <span class="keyword">LIKE</span> other_col;</span><br></pre></td></tr></table></figure>

<p>在第一个语句中，该<a href="https://dev.mysql.com/doc/refman/5.7/en/string-comparison-functions.html#operator_like" target="_blank" rel="noopener"><code>LIKE</code></a> 值以通配符开头。在第二条语句中，该<a href="https://dev.mysql.com/doc/refman/5.7/en/string-comparison-functions.html#operator_like" target="_blank" rel="noopener"><code>LIKE</code></a>值不是常数。</p>
<p>如果使用且 长度超过三个字符，则MySQL使用Turbo Boyer-Moore算法初始化字符串的模式，然后使用该模式更快地执行搜索。 <code>... LIKE &#39;%*string*%&#39;</code><em>string</em></p>
<p>没有覆盖子句中所有<a href="https://dev.mysql.com/doc/refman/5.7/en/logical-operators.html#operator_and" target="_blank" rel="noopener"><code>AND</code></a>级别的 任何索引都 <code>WHERE</code>不会用于优化查询。换句话说，为了能够使用索引，必须在每个<a href="https://dev.mysql.com/doc/refman/5.7/en/logical-operators.html#operator_and" target="_blank" rel="noopener"><code>AND</code></a>组中使用索引的前缀 。</p>
<p>以下<code>WHERE</code>子句使用索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">... WHERE index_part1=1 AND index_part2=2 AND other_column=3</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* index = 1 OR index = 2 */</span></span><br><span class="line">... WHERE index=1 OR A=10 AND index=2</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* optimized like "index_part1='hello'" */</span></span><br><span class="line">... WHERE index_part1='hello' AND index_part3=5</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Can use index on index1 but not on index2 or index3 */</span></span><br><span class="line">... WHERE index1=1 AND index2=2 OR index1=3 AND index3=3;</span><br></pre></td></tr></table></figure>

<p>这些<code>WHERE</code>子句 <em>不</em>使用索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* index_part1 is not used */</span></span><br><span class="line">... WHERE index_part2=1 AND index_part3=2</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  Index is not used in both parts of the WHERE clause  */</span></span><br><span class="line">... WHERE index=1 OR A=10</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* No index spans all rows  */</span></span><br><span class="line">... WHERE index_part1=1 OR index_part2=10</span><br></pre></td></tr></table></figure>

<p>有时，即使索引可用，MySQL也不使用索引。发生这种情况的一种情况是，优化器估计使用索引将需要MySQL访问表中很大比例的行。（在这种情况下，表扫描可能会更快，因为它需要更少的查找。）但是，如果这样的查询<code>LIMIT</code>仅用于检索某些行，则MySQL仍会使用索引，因为它可以更快地找到索引。几行返回结果。</p>
<h4 id="哈希指数特征"><a href="#哈希指数特征" class="headerlink" title="哈希指数特征"></a>哈希指数特征</h4><p>哈希索引与刚刚讨论的索引具有一些不同的特征：</p>
<ul>
<li>它们仅用于使用<code>=</code>or <code>&lt;=&gt;</code> 运算符的相等比较 （但<em>非常</em>快）。它们不用于比较运算符，例如<code>&lt;</code>用于查找值范围的运算符 。依赖于这种单值查找类型的系统称为“ 键值存储 ”；要将MySQL用于此类应用程序，请尽可能使用哈希索引。</li>
<li>优化器无法使用哈希索引来加快<code>ORDER BY</code>操作速度 。（此索引类型不能用于按顺序搜索下一个条目。）</li>
<li>MySQL无法确定两个值之间大约有多少行（范围优化器使用它来决定要使用哪个索引）。如果将<code>MyISAM</code>或 <code>InnoDB</code>表更改为哈希索引 <code>MEMORY</code>表，这可能会影响某些查询。</li>
<li>仅整个键可用于搜索行。（对于B树索引，键的任何最左边的前缀都可用于查找行。）</li>
</ul>
<h3 id="8-3-9索引扩展的使用"><a href="#8-3-9索引扩展的使用" class="headerlink" title="8.3.9索引扩展的使用"></a>8.3.9索引扩展的使用</h3><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html" target="_blank" rel="noopener"><code>InnoDB</code></a>通过将主键列附加到辅助索引来自动扩展每个辅助索引。考虑此表定义：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (</span><br><span class="line">  i1 <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  i2 <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  d <span class="built_in">DATE</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (i1, i2),</span><br><span class="line">  <span class="keyword">INDEX</span> k_d (d)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>

<p>该表在列上定义了主键<code>(i1, i2)</code>。它还<code>k_d</code>在列上定义了辅助索引 <code>(d)</code>，但是在内部<code>InnoDB</code>扩展了该索引并将其视为列<code>(d, i1, i2)</code>。</p>
<p>在确定如何以及是否使用该索引时，优化器会考虑扩展二级索引的主键列。这可以导致更有效的查询执行计划和更好的性能。</p>
<p>优化器可以将扩展的辅助索引用于 <code>ref</code>，<code>range</code>和 <code>index_merge</code>索引访问，松散索引扫描访问，联接和排序优化以及 <a href="https://dev.mysql.com/doc/refman/5.7/en/aggregate-functions.html#function_min" target="_blank" rel="noopener"><code>MIN()</code></a>/ <a href="https://dev.mysql.com/doc/refman/5.7/en/aggregate-functions.html#function_max" target="_blank" rel="noopener"><code>MAX()</code></a> 优化。</p>
<p>以下示例显示了优化程序是否使用扩展二级索引如何影响执行计划。假设<code>t1</code>用以下行填充：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>, <span class="string">'1998-01-01'</span>), (<span class="number">1</span>, <span class="number">2</span>, <span class="string">'1999-01-01'</span>),</span><br><span class="line">(<span class="number">1</span>, <span class="number">3</span>, <span class="string">'2000-01-01'</span>), (<span class="number">1</span>, <span class="number">4</span>, <span class="string">'2001-01-01'</span>),</span><br><span class="line">(<span class="number">1</span>, <span class="number">5</span>, <span class="string">'2002-01-01'</span>), (<span class="number">2</span>, <span class="number">1</span>, <span class="string">'1998-01-01'</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="number">2</span>, <span class="string">'1999-01-01'</span>), (<span class="number">2</span>, <span class="number">3</span>, <span class="string">'2000-01-01'</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>, <span class="string">'2001-01-01'</span>), (<span class="number">2</span>, <span class="number">5</span>, <span class="string">'2002-01-01'</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="number">1</span>, <span class="string">'1998-01-01'</span>), (<span class="number">3</span>, <span class="number">2</span>, <span class="string">'1999-01-01'</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="number">3</span>, <span class="string">'2000-01-01'</span>), (<span class="number">3</span>, <span class="number">4</span>, <span class="string">'2001-01-01'</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="number">5</span>, <span class="string">'2002-01-01'</span>), (<span class="number">4</span>, <span class="number">1</span>, <span class="string">'1998-01-01'</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="number">2</span>, <span class="string">'1999-01-01'</span>), (<span class="number">4</span>, <span class="number">3</span>, <span class="string">'2000-01-01'</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="number">4</span>, <span class="string">'2001-01-01'</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="string">'2002-01-01'</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="number">1</span>, <span class="string">'1998-01-01'</span>), (<span class="number">5</span>, <span class="number">2</span>, <span class="string">'1999-01-01'</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="number">3</span>, <span class="string">'2000-01-01'</span>), (<span class="number">5</span>, <span class="number">4</span>, <span class="string">'2001-01-01'</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="number">5</span>, <span class="string">'2002-01-01'</span>);</span><br></pre></td></tr></table></figure>

<p>现在考虑以下查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> i1 = <span class="number">3</span> <span class="keyword">AND</span> d = <span class="string">'2000-01-01'</span></span><br></pre></td></tr></table></figure>

<p>执行计划取决于是否使用扩展索引。</p>
<p>当优化器不考虑索引扩展时，它将索引<code>k_d</code>视为<code>(d)</code>。 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>对于查询产生以下结果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT COUNT(*) FROM t1 WHERE i1 = 3 AND d = '2000-01-01'\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: t1</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: PRIMARY,k_d</span><br><span class="line">          key: k_d</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 5</span><br><span class="line">        Extra: Using where; Using index</span><br></pre></td></tr></table></figure>

<p>当优化需要索引扩展到帐户，它把<code>k_d</code>作为<code>(d, i1, i2)</code>。在这种情况下，它可以使用最左边的索引前缀<code>(d, i1)</code>来产生更好的执行计划：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT COUNT(*) FROM t1 WHERE i1 = 3 AND d = '2000-01-01'\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: t1</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: PRIMARY,k_d</span><br><span class="line">          key: k_d</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: const,const</span><br><span class="line">         rows: 1</span><br><span class="line">        Extra: Using index</span><br></pre></td></tr></table></figure>

<p>在这两种情况下，都<code>key</code>表明优化器将使用二级索引，<code>k_d</code>但是<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>输出显示了使用扩展索引的这些改进：</p>
<ul>
<li><code>key_len</code>从4个字节到8个字节去，表明键查找中使用的列<code>d</code> 和<code>i1</code>，而不仅仅是<code>d</code>。</li>
<li>该<code>ref</code>值从改变 <code>const</code>到<code>const,const</code> ，因为键查找使用两个关键部分，没有之一。</li>
<li>的<code>rows</code>计数降低从5到1，表明<code>InnoDB</code>应该需要检查更少的行，以产生结果。</li>
<li>该<code>Extra</code>值从变化 <code>Using where; Using index</code>到 <code>Using index</code>。这意味着可以仅使用索引读取行，而无需查阅数据行中的列。</li>
</ul>
<p>使用扩展索引的优化器行为也可以通过以下方式看到<a href="https://dev.mysql.com/doc/refman/5.7/en/show-status.html" target="_blank" rel="noopener"><code>SHOW STATUS</code></a>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">TABLE</span> t1;</span><br><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">STATUS</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> i1 = <span class="number">3</span> <span class="keyword">AND</span> d = <span class="string">'2000-01-01'</span>;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">STATUS</span> <span class="keyword">LIKE</span> <span class="string">'handler_read%'</span></span><br></pre></td></tr></table></figure>

<p>前面的语句包括<a href="https://dev.mysql.com/doc/refman/5.7/en/flush.html#flush-tables" target="_blank" rel="noopener"><code>FLUSH TABLES</code></a>和<a href="https://dev.mysql.com/doc/refman/5.7/en/flush.html#flush-status" target="_blank" rel="noopener"><code>FLUSH STATUS</code></a> 刷新表缓存并清除状态计数器。</p>
<p>没有索引扩展名，将<a href="https://dev.mysql.com/doc/refman/5.7/en/show-status.html" target="_blank" rel="noopener"><code>SHOW STATUS</code></a>产生以下结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------+-------+</span><br><span class="line">| Variable_name         | Value |</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| Handler_read_first    | 0     |</span><br><span class="line">| Handler_read_key      | 1     |</span><br><span class="line">| Handler_read_last     | 0     |</span><br><span class="line">| Handler_read_next     | 5     |</span><br><span class="line">| Handler_read_prev     | 0     |</span><br><span class="line">| Handler_read_rnd      | 0     |</span><br><span class="line">| Handler_read_rnd_next | 0     |</span><br><span class="line">+-----------------------+-------+</span><br></pre></td></tr></table></figure>

<p>使用索引扩展，可<a href="https://dev.mysql.com/doc/refman/5.7/en/show-status.html" target="_blank" rel="noopener"><code>SHOW STATUS</code></a>产生此结果。该 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-status-variables.html#statvar_Handler_read_next" target="_blank" rel="noopener"><code>Handler_read_next</code></a>值从5减少到1，表示可以更有效地使用索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------+-------+</span><br><span class="line">| Variable_name         | Value |</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| Handler_read_first    | 0     |</span><br><span class="line">| Handler_read_key      | 1     |</span><br><span class="line">| Handler_read_last     | 0     |</span><br><span class="line">| Handler_read_next     | 1     |</span><br><span class="line">| Handler_read_prev     | 0     |</span><br><span class="line">| Handler_read_rnd      | 0     |</span><br><span class="line">| Handler_read_rnd_next | 0     |</span><br><span class="line">+-----------------------+-------+</span><br></pre></td></tr></table></figure>

<p>系统变量 的<code>use_index_extensions</code>标志 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_optimizer_switch" target="_blank" rel="noopener"><code>optimizer_switch</code></a>允许控制在确定如何使用<code>InnoDB</code>表的二级索引时优化器是否考虑主键列 。默认情况下<code>use_index_extensions</code>启用。要检查禁用索引扩展的使用是否可以提高性能，请使用以下语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> optimizer_switch = <span class="string">'use_index_extensions=off'</span>;</span><br></pre></td></tr></table></figure>

<p>优化程序对索引扩展的使用受制于对索引中关键部分的数量（16）和最大密钥长度（3072字节）的通常限制。</p>
<h3 id="8-3-10优化器对生成的列索引的使用"><a href="#8-3-10优化器对生成的列索引的使用" class="headerlink" title="8.3.10优化器对生成的列索引的使用"></a>8.3.10优化器对生成的列索引的使用</h3><p>MySQL支持在生成的列上建立索引。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (f1 <span class="built_in">INT</span>, gc <span class="built_in">INT</span> <span class="keyword">AS</span> (f1 + <span class="number">1</span>) <span class="keyword">STORED</span>, <span class="keyword">INDEX</span> (gc));</span><br></pre></td></tr></table></figure>

<p>生成的列<code>gc</code>定义为表达式<code>f1 + 1</code>。该列也被索引，优化器可以在执行计划构建期间考虑该索引。在以下查询中，该 <code>WHERE</code>子句引用<code>gc</code> 并且优化器考虑该列上的索引是否产生更有效的计划：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> gc &gt; <span class="number">9</span>;</span><br></pre></td></tr></table></figure>

<p>即使在查询中没有按名称对这些列进行直接引用的情况下，优化器也可以使用生成的列上的索引来生成执行计划。会发生此如果 <code>WHERE</code>，<code>ORDER BY</code>或 <code>GROUP BY</code>条款是指一些索引生成列的定义相匹配的表达式。以下查询未直接引用，<code>gc</code> 但使用与以下定义匹配的表达式 <code>gc</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> f1 + <span class="number">1</span> &gt; <span class="number">9</span>;</span><br></pre></td></tr></table></figure>

<p>优化器认识到表达式<code>f1 + 1</code>与的定义匹配<code>gc</code>并且<code>gc</code>被索引，因此它在执行计划构建期间会考虑该索引。您可以使用<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>以下命令查看 ：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM t1 WHERE f1 + 1 &gt; 9\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: t1</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: range</span><br><span class="line">possible_keys: gc</span><br><span class="line">          key: gc</span><br><span class="line">      key_len: 5</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using index condition</span><br></pre></td></tr></table></figure>

<p>实际上，优化器已将表达式替换为与表达式<code>f1 + 1</code>匹配的已生成列的名称。在<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a> 由<a href="https://dev.mysql.com/doc/refman/5.7/en/show-warnings.html" target="_blank" rel="noopener"><code>SHOW WARNINGS</code></a>以下命令显示的扩展信息中可用的重写查询中也很明显：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW WARNINGS\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">  Level: Note</span><br><span class="line">   Code: 1003</span><br><span class="line">Message: <span class="comment">/* select#1 */</span> <span class="keyword">select</span> <span class="string">`test`</span>.<span class="string">`t1`</span>.<span class="string">`f1`</span> <span class="keyword">AS</span> <span class="string">`f1`</span>,<span class="string">`test`</span>.<span class="string">`t1`</span>.<span class="string">`gc`</span></span><br><span class="line">         <span class="keyword">AS</span> <span class="string">`gc`</span> <span class="keyword">from</span> <span class="string">`test`</span>.<span class="string">`t1`</span> <span class="keyword">where</span> (<span class="string">`test`</span>.<span class="string">`t1`</span>.<span class="string">`gc`</span> &gt; <span class="number">9</span>)</span><br></pre></td></tr></table></figure>

<p>以下限制和条件适用于优化器对生成的列索引的使用：</p>
<ul>
<li><p>为了使查询表达式与生成的列定义匹配，该表达式必须相同并且其结果类型必须相同。例如，如果生成的列表达式为<code>f1 + 1</code>，如果查询使用<code>1 + f1</code>，或者<code>f1 + 1</code> （整数表达式）与字符串进行比较，则优化器将无法识别匹配项 。</p>
</li>
<li><p>优化适用于这些操作符： <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_equal" target="_blank" rel="noopener"><code>=</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_less-than" target="_blank" rel="noopener"><code>&lt;</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_less-than-or-equal" target="_blank" rel="noopener"><code>&lt;=</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_greater-than" target="_blank" rel="noopener"><code>&gt;</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_greater-than-or-equal" target="_blank" rel="noopener"><code>&gt;=</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_between" target="_blank" rel="noopener"><code>BETWEEN</code></a>，和 <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_in" target="_blank" rel="noopener"><code>IN()</code></a>。</p>
<p>对于<a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_between" target="_blank" rel="noopener"><code>BETWEEN</code></a>和 以外的运算符 <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_in" target="_blank" rel="noopener"><code>IN()</code></a>，可以用匹配的生成列替换任一个操作数。对于 <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_between" target="_blank" rel="noopener"><code>BETWEEN</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_in" target="_blank" rel="noopener"><code>IN()</code></a>，只有第一个参数可以由匹配的生成的列替换，其他参数必须具有相同的结果类型。 <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_between" target="_blank" rel="noopener"><code>BETWEEN</code></a>并且 <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_in" target="_blank" rel="noopener"><code>IN()</code></a>尚不支持涉及JSON值的比较。</p>
</li>
<li><p>必须将生成的列定义为至少包含一个函数调用或前一项中提到的运算符之一的表达式。该表达式不能包含对另一列的简单引用。例如，<code>gc INT AS (f1) STORED</code>仅由列引用组成，因此<code>gc</code>不考虑索引on 。</p>
</li>
<li><p>为了将字符串与索引生成的列进行比较，索引生成的列从返回带引号的字符串的JSON函数计算值，<a href="https://dev.mysql.com/doc/refman/5.7/en/json-modification-functions.html#function_json-unquote" target="_blank" rel="noopener"><code>JSON_UNQUOTE()</code></a>因此在列定义中需要从函数值中删除多余的引号。（为了将字符串直接与函数结果进行比较，JSON比较器会处理引号删除，但是对于索引查找不会发生这种情况。）例如，与其编写这样的列定义：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doc_name TEXT AS (JSON_EXTRACT(jdoc, '$.name')) STORED</span><br></pre></td></tr></table></figure>

<p>这样写：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doc_name TEXT AS (JSON_UNQUOTE(JSON_EXTRACT(jdoc, '$.name'))) STORED</span><br></pre></td></tr></table></figure>

<p>使用后一个定义，优化器可以为以下两个比较检测到匹配：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">... WHERE JSON_EXTRACT(jdoc, '$.name') = 'some_string' ...</span><br><span class="line">... WHERE JSON_UNQUOTE(JSON_EXTRACT(jdoc, '$.name')) = 'some_string' ...</span><br></pre></td></tr></table></figure>

<p>如果不在<a href="https://dev.mysql.com/doc/refman/5.7/en/json-modification-functions.html#function_json-unquote" target="_blank" rel="noopener"><code>JSON_UNQUOTE()</code></a>列定义中，则优化器仅针对这些比较中的第一个比较检测到匹配项。</p>
</li>
<li><p>如果优化器无法选择所需的索引，则可以使用索引提示来强制优化器做出其他选择。</p>
</li>
</ul>
<h3 id="8-3-11从TIMESTAMP列进行索引查找"><a href="#8-3-11从TIMESTAMP列进行索引查找" class="headerlink" title="8.3.11从TIMESTAMP列进行索引查找"></a>8.3.11从TIMESTAMP列进行索引查找</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE tstable (ts TIMESTAMP);</span><br><span class="line">mysql&gt; SET time_zone = 'UTC'; -- insert UTC values</span><br><span class="line">mysql&gt; INSERT INTO tstable VALUES</span><br><span class="line">       ('2018-10-28 00:30:00'),</span><br><span class="line">       ('2018-10-28 01:30:00');</span><br><span class="line">mysql&gt; SELECT ts FROM tstable;</span><br><span class="line">+<span class="comment">---------------------+</span></span><br><span class="line">| ts                  |</span><br><span class="line">+<span class="comment">---------------------+</span></span><br><span class="line">| 2018-10-28 00:30:00 |</span><br><span class="line">| 2018-10-28 01:30:00 |</span><br><span class="line">+<span class="comment">---------------------+</span></span><br><span class="line">mysql&gt; SET time_zone = 'MET'; -- retrieve non-UTC values</span><br><span class="line">mysql&gt; SELECT ts FROM tstable;</span><br><span class="line">+<span class="comment">---------------------+</span></span><br><span class="line">| ts                  |</span><br><span class="line">+<span class="comment">---------------------+</span></span><br><span class="line">| 2018-10-28 02:30:00 |</span><br><span class="line">| 2018-10-28 02:30:00 |</span><br><span class="line">+<span class="comment">---------------------+</span></span><br></pre></td></tr></table></figure>

<p>注意</p>
<p>要使用诸如<code>&#39;MET&#39;</code>或的 命名时区<code>&#39;Europe/Amsterdam&#39;</code>，必须正确设置时区表。有关说明，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/time-zone-support.html" target="_blank" rel="noopener">第5.1.13节“ MySQL服务器时区支持”</a>。</p>
<p>您会看到两个不同的UTC值在转换<code>&#39;MET&#39;</code>为时区时是相同的。对于特定的<a href="https://dev.mysql.com/doc/refman/5.7/en/datetime.html" target="_blank" rel="noopener"><code>TIMESTAMP</code></a>列查询，此现象可能导致不同的结果 ，具体取决于优化器是否使用索引来执行查询。</p>
<p>假设查询使用<code>WHERE</code>子句从前面显示的表中选择值，以在该<code>ts</code>列中搜索 单个特定值，例如用户提供的时间戳文字：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ts <span class="keyword">FROM</span> tstable</span><br><span class="line"><span class="keyword">WHERE</span> ts = <span class="string">'literal'</span>;</span><br></pre></td></tr></table></figure>

<p>进一步假设查询在以下条件下执行：</p>
<ul>
<li><p>会话时区不是UTC，并且具有DST偏移。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">time_zone</span> = <span class="string">'MET'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/datetime.html" target="_blank" rel="noopener"><code>TIMESTAMP</code></a>由于DST偏移 ，该列中存储的唯一UTC值在 会话时区中不是唯一的。（前面显示的示例说明了这种情况的发生。）</p>
</li>
<li><p>该查询指定了在会话时区中输入DST小时内的搜索值。</p>
</li>
</ul>
<p>在这种情况下，<code>WHERE</code>对于未建立索引和建立索引的查找，子句中的比较以 不同的方式发生，并导致不同的结果：</p>
<ul>
<li><p>如果没有索引或优化器无法使用它，则会在会话时区中进行比较。优化器执行表扫描，在其中检索每个 <code>ts</code>列值，将其从UTC转换为会话时区，然后将其与搜索值（也在会话时区中解释）进行比较：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT ts FROM tstable</span><br><span class="line">       WHERE ts = '2018-10-28 02:30:00';</span><br><span class="line">+<span class="comment">---------------------+</span></span><br><span class="line">| ts                  |</span><br><span class="line">+<span class="comment">---------------------+</span></span><br><span class="line">| 2018-10-28 02:30:00 |</span><br><span class="line">| 2018-10-28 02:30:00 |</span><br><span class="line">+<span class="comment">---------------------+</span></span><br></pre></td></tr></table></figure>

<p>由于已存储的<code>ts</code>值已转换为会话时区，因此查询有可能返回两个时间戳值，这些时间戳值与UTC值不同，但在会话时区中相等：当时钟更改时，一个值发生在DST移位之前， DST移位后出现的一个值。</p>
</li>
<li><p>如果有可用的索引，则以UTC进行比较。优化器执行索引扫描，首先将搜索值从会话时区转换为UTC，然后将结果与UTC索引条目进行比较：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE tstable ADD INDEX (ts);</span><br><span class="line">mysql&gt; SELECT ts FROM tstable</span><br><span class="line">       WHERE ts = '2018-10-28 02:30:00';</span><br><span class="line">+<span class="comment">---------------------+</span></span><br><span class="line">| ts                  |</span><br><span class="line">+<span class="comment">---------------------+</span></span><br><span class="line">| 2018-10-28 02:30:00 |</span><br><span class="line">+<span class="comment">---------------------+</span></span><br></pre></td></tr></table></figure>

<p>在这种情况下，（转换后的）搜索值仅与索引条目匹配，并且由于不同存储的UTC值的索引条目也不同，因此搜索值只能匹配其中之一。</p>
</li>
</ul>
<p>由于针对非索引和索引查找的优化器操作不同，因此在每种情况下查询都会产生不同的结果。非索引查找的结果将返回会话时区中所有匹配的值。索引查找不能这样做：</p>
<ul>
<li>它在仅了解UTC值的存储引擎内执行。</li>
<li>对于映射到相同UTC值的两个不同的会话时区值，索引查找仅匹配相应的UTC索引条目，并且仅返回单行。</li>
</ul>
<p>在前面的讨论中，存储在其中的数据集 <code>tstable</code>恰好由不同的UTC值组成。在这种情况下，所示形式的所有使用索引的查询最多匹配一个索引条目。</p>
<p>如果索引不是<code>UNIQUE</code>，则表（和索引）可以存储给定UTC值的多个实例。例如，该<code>ts</code>列可能包含UTC value的多个实例 <code>&#39;2018-10-28 00:30:00&#39;</code>。在这种情况下，使用索引的查询将返回它们中的每一个（转换为<code>&#39;2018-10-28 02:30:00&#39;</code>结果集中的MET值）。仍然使用索引的查询将转换后的搜索值与UTC索引条目中的单个值进行匹配，而不是将在会话时区中转换为搜索值的多个UTC值进行匹配。</p>
<p>如果返回<code>ts</code>在会话时区中匹配的所有值很重要，则解决方法是禁止使用带有<code>IGNORE INDEX</code>提示的索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT ts FROM tstable</span><br><span class="line">       IGNORE INDEX (ts)</span><br><span class="line">       WHERE ts = '2018-10-28 02:30:00';</span><br><span class="line">+<span class="comment">---------------------+</span></span><br><span class="line">| ts                  |</span><br><span class="line">+<span class="comment">---------------------+</span></span><br><span class="line">| 2018-10-28 02:30:00 |</span><br><span class="line">| 2018-10-28 02:30:00 |</span><br><span class="line">+<span class="comment">---------------------+</span></span><br></pre></td></tr></table></figure>

<p>在其他情况下（例如使用<a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_from-unixtime" target="_blank" rel="noopener"><code>FROM_UNIXTIME()</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_unix-timestamp" target="_blank" rel="noopener"><code>UNIX_TIMESTAMP()</code></a>功能执行的转换），在两个方向上也都缺少时区转换的一对一映射 。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html" target="_blank" rel="noopener">第12.6节“日期和时间函数”</a>。</p>
<h2 id="8-4优化数据库结构"><a href="#8-4优化数据库结构" class="headerlink" title="8.4优化数据库结构"></a>8.4优化数据库结构</h2><ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/data-size.html" target="_blank" rel="noopener">8.4.1优化数据大小</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/optimize-data-types.html" target="_blank" rel="noopener">8.4.2优化MySQL数据类型</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/optimize-multi-tables.html" target="_blank" rel="noopener">8.4.3优化许多表</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/internal-temporary-tables.html" target="_blank" rel="noopener">8.4.4 MySQL中内部临时表的使用</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/database-count-limit.html" target="_blank" rel="noopener">8.4.5数据库和表数限制</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/table-size-limit.html" target="_blank" rel="noopener">8.4.6表格大小限制</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/column-count-limit.html" target="_blank" rel="noopener">8.4.7表列数和行大小的限制</a></li>
</ul>
<p>在担任数据库设计师的角色中，寻找最有效的方式来组织架构，表和列。与调整应用程序代码时一样，您可以最大程度地减少I / O，将相关项目放在一起，并提前进行计划，以便随着数据量的增加而保持较高的性能。从高效的数据库设计开始，团队成员可以更轻松地编写高性能的应用程序代码，并使数据库很可能随着应用程序的发展和重写而持久。</p>
<h3 id="8-4-1优化数据大小"><a href="#8-4-1优化数据大小" class="headerlink" title="8.4.1优化数据大小"></a>8.4.1优化数据大小</h3><p>设计表以最小化它们在磁盘上的空间。通过减少写入磁盘和从磁盘读取的数据量，这可以带来巨大的改进。较小的表通常需要较少的主内存，而在查询执行期间对它们的内容进行主动处理时。表数据的任何空间减少也会导致较小的索引，可以更快地对其进行处理。</p>
<p>MySQL支持许多不同的存储引擎（表类型）和行格式。对于每个表，您可以决定使用哪种存储和索引方法。为您的应用程序选择适当的表格式可以大大提高性能。请参阅 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html" target="_blank" rel="noopener">第14章，<em>InnoDB存储引擎</em></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/storage-engines.html" target="_blank" rel="noopener">第15章，<em>备用存储引擎</em></a>。</p>
<p>通过使用此处列出的技术，可以提高表的性能，并最大程度地减少存储空间：</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/data-size.html#data-size-table-columns" target="_blank" rel="noopener">表格栏</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/data-size.html#data-size-row-format" target="_blank" rel="noopener">行格式</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/data-size.html#data-size-indexes" target="_blank" rel="noopener">指标</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/data-size.html#data-size-joins" target="_blank" rel="noopener">加入</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/data-size.html#data-size-normalization" target="_blank" rel="noopener">正常化</a></li>
</ul>
<h4 id="表格栏"><a href="#表格栏" class="headerlink" title="表格栏"></a>表格栏</h4><ul>
<li>尽可能使用最有效（最小）的数据类型。MySQL具有许多专门的类型，可以节省磁盘空间和内存。例如，如果可能，使用较小的整数类型以获得较小的表。 <a href="https://dev.mysql.com/doc/refman/5.7/en/integer-types.html" target="_blank" rel="noopener"><code>MEDIUMINT</code></a>通常比<a href="https://dev.mysql.com/doc/refman/5.7/en/integer-types.html" target="_blank" rel="noopener"><code>INT</code></a>由于 <a href="https://dev.mysql.com/doc/refman/5.7/en/integer-types.html" target="_blank" rel="noopener"><code>MEDIUMINT</code></a>列占用的空间少25％更好。</li>
<li><code>NOT NULL</code>尽可能 声明列。通过更好地使用索引并消除测试每个值是否为的开销，可以使SQL操作更快<code>NULL</code>。您还节省了一些存储空间，每列一位。如果您确实需要<code>NULL</code>表中的值，请使用它们。只要避免使用默认设置，该默认设置允许 <code>NULL</code>每一列中的值。</li>
</ul>
<h4 id="行格式"><a href="#行格式" class="headerlink" title="行格式"></a>行格式</h4><ul>
<li><p><code>InnoDB</code>表格<code>DYNAMIC</code>默认使用行格式创建 。要使用以外的行格式<code>DYNAMIC</code>，请配置 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_default_row_format" target="_blank" rel="noopener"><code>innodb_default_row_format</code></a>，或<code>ROW_FORMAT</code>在<a href="https://dev.mysql.com/doc/refman/5.7/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a>or <a href="https://dev.mysql.com/doc/refman/5.7/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>语句中显式指定选项。</p>
<p>紧凑的行格式系列（包括 <code>COMPACT</code>，<code>DYNAMIC</code>和<code>COMPRESSED</code>）减少了行存储空间，但增加了某些操作的CPU使用率。如果您的工作量是典型的工作，并且受缓存命中率和磁盘速度的限制，则可能会更快。如果在极少数情况下受CPU速度的限制，则它可能会变慢。</p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/char.html" target="_blank" rel="noopener"><code>CHAR</code></a>当使用可变长度字符集（例如<code>utf8mb3</code>或）时 ，紧凑的行格式系列还可以优化 列存储 <code>utf8mb4</code>。使用<code>ROW_FORMAT=REDUNDANT</code>， 占×字符集的最大字节长度。许多语言可以主要使用单字节字符编写 ，因此固定的存储长度通常会浪费空间。使用紧凑的行格式系列，可以 在到的范围内分配可变的存储量 <code>CHAR(*N*)</code><em>N</em><code>utf8``InnoDB</code><em>N*</em>N<em>×通过删除尾随空格来删除这些列的字符集的最大字节长度。</em>N*在典型情况下，最小存储长度为 字节，以方便就地更新。有关更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-row-format.html" target="_blank" rel="noopener">第14.11节“ InnoDB行格式”</a>。</p>
</li>
<li><p>通过以压缩形式存储表数据来进一步减少空间，请<code>ROW_FORMAT=COMPRESSED</code>在创建<code>InnoDB</code>表时 指定 ，或在现有表上运行 <a href="https://dev.mysql.com/doc/refman/5.7/en/myisampack.html" target="_blank" rel="noopener"><strong>myisampack</strong></a>命令 <code>MyISAM</code>。（<code>InnoDB</code>压缩表是可读写的，而<code>MyISAM</code>压缩表是只读的。）</p>
</li>
<li><p>对于<code>MyISAM</code>表中，如果没有任何可变长度列（<a href="https://dev.mysql.com/doc/refman/5.7/en/char.html" target="_blank" rel="noopener"><code>VARCHAR</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/blob.html" target="_blank" rel="noopener"><code>TEXT</code></a>，或 <a href="https://dev.mysql.com/doc/refman/5.7/en/blob.html" target="_blank" rel="noopener"><code>BLOB</code></a>列），一个固定大小的行格式被使用。这样比较快，但可能会浪费一些空间。请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/myisam-table-formats.html" target="_blank" rel="noopener">第15.2.3节“ MyISAM表存储格式”</a>。即使您有<a href="https://dev.mysql.com/doc/refman/5.7/en/char.html" target="_blank" rel="noopener"><code>VARCHAR</code></a>带有<a href="https://dev.mysql.com/doc/refman/5.7/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a>选项的 列，也可以暗示您希望具有固定长度的行<code>ROW_FORMAT=FIXED</code>。</p>
</li>
</ul>
<h4 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h4><ul>
<li>表的主索引应尽可能短。这使得识别每一行变得容易且有效。对于<code>InnoDB</code>表，主键列在每个辅助索引条目中重复，因此如果您有许多辅助索引，则较短的主键可节省大量空间。</li>
<li>仅创建提高查询性能所需的索引。索引很适合检索，但是会降低插入和更新操作的速度。如果您主要通过搜索列的组合来访问表，请在列上创建单个复合索引，而不是为每个列创建单独的索引。索引的第一部分应该是最常用的列。如果从表中选择时<em>总是</em>使用许多列，则索引中的第一列应该是重复次数最多的列，以更好地压缩索引。</li>
<li>如果长字符串列很可能在第一个字符数上具有唯一的前缀，则最好使用MySQL支持在该列的最左侧创建索引来仅对此前缀进行索引（请参阅<a href="https://dev.mysql.com/doc/refman/5.7/en/create-index.html" target="_blank" rel="noopener">第13.1.14节） ，“ CREATE INDEX语句”</a>）。索引越短越快，这不仅是因为它们需要较少的磁盘空间，而且还因为它们还会使索引缓存中的命中次数增加，从而减少了磁盘寻道。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-configuration.html" target="_blank" rel="noopener">第5.1.1节“配置服务器”</a>。</li>
</ul>
<h4 id="加入"><a href="#加入" class="headerlink" title="加入"></a>加入</h4><ul>
<li>在某些情况下，将经常扫描的表分成两部分可能会有所帮助。如果它是动态格式表，并且可以使用较小的静态格式表（在扫描表时可以用来查找相关行），则尤其如此。</li>
<li>在具有相同数据类型的不同表中声明具有相同信息的列，以加快基于相应列的联接。</li>
<li>使列名保持简单，以便您可以在不同的表中使用相同的名称并简化联接查询。例如，在名为的表中<code>customer</code>，使用列名<code>name</code>代替 <code>customer_name</code>。为了使您的名称可移植到其他SQL Server中，请考虑使名称短于18个字符。</li>
</ul>
<h4 id="正常化"><a href="#正常化" class="headerlink" title="正常化"></a>正常化</h4><ul>
<li>通常，请尝试使所有数据都保持非冗余状态（遵守数据库理论中所谓的 第三范式）。不必重复冗长的值（例如名称和地址），而是给它们分配唯一的ID，在多个较小的表中根据需要重复这些ID，然后通过引用join子句中的ID在查询中联接这些表。</li>
<li>如果速度比磁盘空间和保留多个数据副本的维护成本更为重要，例如在商业智能场景中，您分析大型表中的所有数据，则可以放宽规范化规则，复制信息或创建汇总表以提高速度。</li>
</ul>
<h3 id="8-4-2优化MySQL数据类型"><a href="#8-4-2优化MySQL数据类型" class="headerlink" title="8.4.2优化MySQL数据类型"></a>8.4.2优化MySQL数据类型</h3><ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/optimize-numeric.html" target="_blank" rel="noopener">8.4.2.1优化数值数据</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/optimize-character.html" target="_blank" rel="noopener">8.4.2.2优化字符和字符串类型</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/optimize-blob.html" target="_blank" rel="noopener">8.4.2.3优化BLOB类型</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/procedure-analyse.html" target="_blank" rel="noopener">8.4.2.4使用过程分析</a></li>
</ul>
<h4 id="8-4-2-1优化数值数据"><a href="#8-4-2-1优化数值数据" class="headerlink" title="8.4.2.1优化数值数据"></a>8.4.2.1优化数值数据</h4><ul>
<li>对于可以表示为字符串或数字的唯一ID或其他值，与字符串列相比，首选数字列。由于大数值可以比相应字符串存储在更少的字节中，因此它传输速度更快，并且占用更少的内存来进行比较。</li>
<li>如果使用的是数字数据，则在许多情况下（通过实时连接）从数据库访问信息的访问要比访问文本文件更快。数据库中的信息可能以比文本文件更紧凑的格式存储，因此访问它涉及的磁盘访问较少。您还可以将代码保存在应用程序中，因为可以避免解析文本文件来查找行边界和列边界。</li>
</ul>
<h4 id="8-4-2-2优化字符和字符串类型"><a href="#8-4-2-2优化字符和字符串类型" class="headerlink" title="8.4.2.2优化字符和字符串类型"></a>8.4.2.2优化字符和字符串类型</h4><p>对于字符和字符串列，请遵循以下准则：</p>
<ul>
<li>当您不需要特定于语言的排序规则功能时，请使用二进制排序规则顺序进行快速比较和排序操作。您可以使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/cast-functions.html#operator_binary" target="_blank" rel="noopener"><code>BINARY</code></a>运算符在特定查询中使用二进制排序规则。</li>
<li>比较来自不同列的值时，请尽可能使用相同的字符集和排序规则声明这些列，以避免在运行查询时进行字符串转换。</li>
<li>对于小于8KB的列值，请使用二进制 <code>VARCHAR</code>而不是 <code>BLOB</code>。该<code>GROUP BY</code> 和<code>ORDER BY</code>条款可以生成临时表，这些临时表可以使用的 <code>MEMORY</code>存储引擎，如果原来的表不包含任何<code>BLOB</code> 列。</li>
<li>如果表包含名称和地址之类的字符串列，但是许多查询未检索到这些列，请考虑将字符串列拆分为单独的表，并在必要时使用带有外键的联接查询。当MySQL从一行中检索任何值时，它将读取包含该行所有列（可能还有其他相邻行）的数据块。保持每行较小，仅使用最常使用的列，可使更多行适合每个数据块。这样的紧凑表减少了常见查询的磁盘I / O和内存使用量。</li>
<li>当您将随机生成的值用作<code>InnoDB</code>表中的主键时，请尽可能在其前面加上一个升值，例如当前日期和时间。当连续的主值在物理上彼此靠近存储时，<code>InnoDB</code>可以更快地插入和检索它们。</li>
<li>有关为什么数字列通常比等效的字符串列更可取的原因<a href="https://dev.mysql.com/doc/refman/5.7/en/optimize-numeric.html" target="_blank" rel="noopener">，</a>请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/optimize-numeric.html" target="_blank" rel="noopener">第8.4.2.1节“优化数字数据”</a>。</li>
</ul>
<h4 id="8-4-2-3优化BLOB类型"><a href="#8-4-2-3优化BLOB类型" class="headerlink" title="8.4.2.3优化BLOB类型"></a>8.4.2.3优化BLOB类型</h4><ul>
<li>当存储包含文本数据的大blob时，请考虑首先对其进行压缩。当整个表由<code>InnoDB</code>或压缩时，请勿使用此技术 <code>MyISAM</code>。</li>
<li>对于具有多个列的表，为了减少不使用BLOB列的查询的内存需求，请考虑将BLOB列拆分为一个单独的表，并在需要时使用联接查询对其进行引用。</li>
<li>由于检索和显示BLOB值的性能要求可能与其他数据类型有很大不同，因此可以将特定于BLOB的表放在不同的存储设备上，甚至放在单独的数据库实例上。例如，检索BLOB可能需要读取较大的顺序磁盘，这比传统的<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_ssd" target="_blank" rel="noopener">SSD</a>更适合传统硬盘驱动 <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_ssd" target="_blank" rel="noopener">器</a>。</li>
<li>有关为什么有时有时使用二进制列优于等效的BLOB列的原因<a href="https://dev.mysql.com/doc/refman/5.7/en/optimize-character.html" target="_blank" rel="noopener">，</a>请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/optimize-character.html" target="_blank" rel="noopener">第8.4.2.2节“优化字符和字符串类型”</a><code>VARCHAR</code>。</li>
<li>您可以将列值的哈希存储在单独的列中，对该列进行索引并在查询中测试该哈希值，而不是针对非常长的文本字符串测试是否相等。（使用<code>MD5()</code>或 <code>CRC32()</code>函数来生成哈希值。）由于哈希函数可以为不同的输入生成重复的结果，因此您仍然在查询中包括一个子句 以防止错误匹配。性能优势来自较小，易于扫描的哈希值索引。 <code>AND *blob_column* = *long_string_value*</code></li>
</ul>
<h4 id="8-4-2-4使用过程分析"><a href="#8-4-2-4使用过程分析" class="headerlink" title="8.4.2.4使用过程分析"></a>8.4.2.4使用过程分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANALYSE([*max_elements*[,*max_memory*]])</span><br></pre></td></tr></table></figure>



<p>注意</p>
<p><code>PROCEDURE ANALYSE()</code> 自MySQL 5.7.18起已弃用，并在MySQL 8.0中删除。</p>
<p><code>ANALYSE()</code>检查查询的结果并返回结果分析，该分析建议每列的最佳数据类型，这可能有助于减小表的大小。要获得此分析，<code>PROCEDURE ANALYSE</code>请在<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>语句末尾 附加：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> ... <span class="keyword">PROCEDURE</span> ANALYSE([max_elements,[max_memory]])</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1, col2 <span class="keyword">FROM</span> table1 <span class="keyword">PROCEDURE</span> ANALYSE(<span class="number">10</span>, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>

<p>结果显示查询返回的值的一些统计信息，并为列提供最佳数据类型。这对于检查现有表或导入新数据后会很有帮助。您可能需要为参数尝试不同的设置，以便在不合适时<code>PROCEDURE ANALYSE()</code>不建议 <a href="https://dev.mysql.com/doc/refman/5.7/en/enum.html" target="_blank" rel="noopener"><code>ENUM</code></a>数据类型。</p>
<p>参数是可选的，并按如下方式使用：</p>
<ul>
<li><em>max_elements</em>（默认值为256）是<code>ANALYSE()</code>每列中可注意的最大不重复值数量 。用于<code>ANALYSE()</code>检查最佳数据类型是否为类型 <a href="https://dev.mysql.com/doc/refman/5.7/en/enum.html" target="_blank" rel="noopener"><code>ENUM</code></a>; 如果有多个<em>max_elements</em>不同的值，则<a href="https://dev.mysql.com/doc/refman/5.7/en/enum.html" target="_blank" rel="noopener"><code>ENUM</code></a>不是建议的类型。</li>
<li><em>max_memory</em>（默认值8192）是<code>ANALYSE()</code>在尝试查找所有不同值时应为每列分配的最大内存量 。</li>
</ul>
<p><code>PROCEDURE</code>语句中不允许 使用子句 <a href="https://dev.mysql.com/doc/refman/5.7/en/union.html" target="_blank" rel="noopener"><code>UNION</code></a>。</p>
<h3 id="8-4-3优化许多表"><a href="#8-4-3优化许多表" class="headerlink" title="8.4.3优化许多表"></a>8.4.3优化许多表</h3><ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/table-cache.html" target="_blank" rel="noopener">8.4.3.1 MySQL如何打开和关闭表</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/creating-many-tables.html" target="_blank" rel="noopener">8.4.3.2在同一数据库中创建多个表的缺点</a></li>
</ul>
<p>一些用于保持单个查询快速运行的技术涉及在多个表之间拆分数据。当表的数量达到数千甚至数百万时，处理所有这些表的开销将成为新的性能考虑因素。</p>
<h4 id="8-4-3-1-MySQL如何打开和关闭表"><a href="#8-4-3-1-MySQL如何打开和关闭表" class="headerlink" title="8.4.3.1 MySQL如何打开和关闭表"></a>8.4.3.1 MySQL如何打开和关闭表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Uptime: 426 Running threads: 1 Questions: 11082</span><br><span class="line">Reloads: 1 Open tables: 12</span><br></pre></td></tr></table></figure>

<p><code>Open tables</code>如果表少于12个，则12 的值可能会令人困惑。</p>
<p>MySQL是多线程的，因此可能有许多客户端同时为给定表发出查询。为了最大程度地减少同一张表上具有不同状态的多个客户端会话的问题，每个并发会话会独立打开该表。这会使用额外的内存，但通常会提高性能。对于<code>MyISAM</code>表，每个打开表的客户端的数据文件都需要一个额外的文件描述符。（相比之下，索引文件描述符在所有会话之间共享。）</p>
<p>该<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_table_open_cache" target="_blank" rel="noopener"><code>table_open_cache</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_max_connections" target="_blank" rel="noopener"><code>max_connections</code></a>系统变量影响服务器保持打开的文件的最大数量。如果增加这两个值中的一个或两个，则可能会遇到操作系统对打开文件描述符的每个进程数施加的限制。许多方法允许您增加打开文件的限制，尽管方法因系统而异。请查阅您的操作系统文档，以确定是否可以增加限制以及如何增加限制。</p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_table_open_cache" target="_blank" rel="noopener"><code>table_open_cache</code></a>与有关<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_max_connections" target="_blank" rel="noopener"><code>max_connections</code></a>。例如，对于200个并发运行的连接，指定的表缓存大小至少为，其中 是您执行的任何查询中每个联接的最大表数。您还必须为临时表和文件保留一些额外的文件描述符。 <code>200 * *N*</code><em>N</em></p>
<p>确保您的操作系统可以处理该<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_table_open_cache" target="_blank" rel="noopener"><code>table_open_cache</code></a>设置所隐含的打开文件描述符的数量 。如果 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_table_open_cache" target="_blank" rel="noopener"><code>table_open_cache</code></a>设置得太高，MySQL可能会用尽文件描述符，并表现出诸如拒绝连接或无法执行查询之类的症状。</p>
<p>还应考虑到<code>MyISAM</code> 存储引擎对于每个唯一的打开表都需要两个文件描述符。对于分区<code>MyISAM</code>表，打开的表的每个分区都需要两个文件描述符。（<code>MyISAM</code>打开分区表时，无论是否实际使用给定的分区，它都会打开该表的每个分区。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/partitioning-limitations.html#partitioning-limitations-myisam-file-descriptors" target="_blank" rel="noopener">MyISAM和分区文件描述符的用法</a>。）要增加可用于MySQL的文件描述符的数量，请设置<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_open_files_limit" target="_blank" rel="noopener"><code>open_files_limit</code></a> 系统变量。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/not-enough-file-handles.html" target="_blank" rel="noopener">第B.4.2.17节“找不到文件和类似错误”</a>。</p>
<p>打开表的缓存保持在<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_table_open_cache" target="_blank" rel="noopener"><code>table_open_cache</code></a>条目级别 。服务器在启动时自动调整缓存大小。要显式设置大小，请<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_table_open_cache" target="_blank" rel="noopener"><code>table_open_cache</code></a>在启动时设置 系统变量。MySQL可能会临时打开更多表来执行查询，如本节后面所述。</p>
<p>在以下情况下，MySQL关闭未使用的表并将其从表缓存中删除：</p>
<ul>
<li>当缓存已满并且线程尝试打开不在缓存中的表时。</li>
<li>当高速缓存包含多个<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_table_open_cache" target="_blank" rel="noopener"><code>table_open_cache</code></a>条目并且高速缓存中 的表不再被任何线程使用时。</li>
<li>当进行表刷新操作时。当有人发出<a href="https://dev.mysql.com/doc/refman/5.7/en/flush.html#flush-tables" target="_blank" rel="noopener"><code>FLUSH TABLES</code></a>语句或执行 <a href="https://dev.mysql.com/doc/refman/5.7/en/mysqladmin.html" target="_blank" rel="noopener"><strong>mysqladmin flush-tables</strong></a>或 <a href="https://dev.mysql.com/doc/refman/5.7/en/mysqladmin.html" target="_blank" rel="noopener"><strong>mysqladmin refresh</strong></a>命令时，会发生这种情况。</li>
</ul>
<p>当表高速缓存填满时，服务器将使用以下过程找到要使用的高速缓存条目：</p>
<ul>
<li>从最近最少使用的表开始，释放当前未使用的表。</li>
<li>如果必须打开一个新表，但是缓存已满，并且无法释放任何表，则根据需要临时扩展缓存。当缓存处于临时扩展状态并且表从使用状态变为未使用状态时，表将关闭并从缓存中释放。</li>
</ul>
<p><code>MyISAM</code>将为每个并发访问打开 一个表。这意味着，如果两个线程访问同一个表，或者如果一个线程在同一查询中两次访问该表（例如，通过将表自身连接），则该表需要打开两次。每个并发打开都需要在表缓存中有一个条目。任何<code>MyISAM</code>表的第一次打开都 需要两个文件描述符：一个用于数据文件，一个用于索引文件。该表的每次其他使用都只为数据文件使用一个文件描述符。索引文件描述符在所有线程之间共享。</p>
<p>如果要使用该语句打开表，则会为该线程分配专用的表对象。该表对象不与其他线程共享，并且在线程调用或线程终止之前不会关闭。发生这种情况时，会将表放回表高速缓存中（如果高速缓存未满）。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/handler.html" target="_blank" rel="noopener">第13.2.4节“ HANDLER语句”</a>。 <code>HANDLER *tbl_name* OPEN``HANDLER *tbl_name* CLOSE</code></p>
<p>要确定表缓存是否太小，请检查 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-status-variables.html#statvar_Opened_tables" target="_blank" rel="noopener"><code>Opened_tables</code></a>状态变量，该变量指示自服务器启动以来表打开操作的数量：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW GLOBAL STATUS LIKE 'Opened_tables';</span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br><span class="line">| Opened_tables | 2741  |</span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br></pre></td></tr></table></figure>

<p>如果该值很大或迅速增加，即使您没有发出很多<a href="https://dev.mysql.com/doc/refman/5.7/en/flush.html#flush-tables" target="_blank" rel="noopener"><code>FLUSH TABLES</code></a>语句，也请<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_table_open_cache" target="_blank" rel="noopener"><code>table_open_cache</code></a>在服务器启动时增加该 值。</p>
<h4 id="8-4-3-2在同一数据库中创建多个表的缺点"><a href="#8-4-3-2在同一数据库中创建多个表的缺点" class="headerlink" title="8.4.3.2在同一数据库中创建多个表的缺点"></a>8.4.3.2在同一数据库中创建多个表的缺点</h4><p>如果<code>MyISAM</code>同一数据库目录中有许多表，则打开，关闭和创建操作的速度很慢。如果<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a> 在许多不同的表上执行语句，则表高速缓存已满时会产生一些开销，因为对于必须打开的每个表，必须关闭另一个表。您可以通过增加表缓存中允许的条目数来减少此开销。</p>
<h3 id="8-4-4-MySQL中内部临时表的使用"><a href="#8-4-4-MySQL中内部临时表的使用" class="headerlink" title="8.4.4 MySQL中内部临时表的使用"></a>8.4.4 MySQL中内部临时表的使用</h3><p>在某些情况下，服务器在处理语句时会创建内部临时表。用户无法直接控制何时发生这种情况。</p>
<p>服务器在以下条件下创建临时表：</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/union.html" target="_blank" rel="noopener"><code>UNION</code></a> 语句的 评估，但稍后会有一些例外。</li>
<li>评估某些视图，例如使用<code>TEMPTABLE</code>算法 <a href="https://dev.mysql.com/doc/refman/5.7/en/union.html" target="_blank" rel="noopener"><code>UNION</code></a>或聚合的视图 。</li>
<li>派生表的评估（请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/derived-tables.html" target="_blank" rel="noopener">第13.2.10.8节“派生表”</a>）。</li>
<li>为子查询或半联接实现创建的表（请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/subquery-optimization.html" target="_blank" rel="noopener">第8.2.2节“优化子查询，派生表和视图引用”</a>）。</li>
<li>评估包含一个<code>ORDER BY</code>子句和一个不同<code>GROUP BY</code>子句，或者其中的<code>ORDER BY</code>或<code>GROUP BY</code>包含联接队列中第一个表以外的表中的列的语句。</li>
<li>评价<code>DISTINCT</code>结合 <code>ORDER BY</code>可能需要一个临时表。</li>
<li>对于使用<code>SQL_SMALL_RESULT</code> 修饰符的查询，MySQL使用内存中临时表，除非查询还包含需要磁盘存储的元素（稍后描述）。</li>
<li>为了评估 <a href="https://dev.mysql.com/doc/refman/5.7/en/insert-select.html" target="_blank" rel="noopener"><code>INSERT ... SELECT</code></a>从同一表中选择并插入到同一表中的语句，MySQL创建了一个内部临时表来保存中的行 <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>，然后将这些行插入目标表中。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/insert-select.html" target="_blank" rel="noopener">第13.2.5.1节“ INSERT … SELECT语句”</a>。</li>
<li>评估多表 <a href="https://dev.mysql.com/doc/refman/5.7/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a>语句。</li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/aggregate-functions.html#function_group-concat" target="_blank" rel="noopener"><code>GROUP_CONCAT()</code></a> 或<a href="https://dev.mysql.com/doc/refman/5.7/en/aggregate-functions.html#function_count" target="_blank" rel="noopener"><code>COUNT(DISTINCT)</code></a> 表达式的 评估。</li>
</ul>
<p>要确定一条语句是否需要一个临时表，请使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>并检查该 <code>Extra</code>列是否显示 <code>Using temporary</code>（请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/using-explain.html" target="_blank" rel="noopener">第8.8.1节“使用EXPLAIN优化查询”</a>）。对于派生或具体化的临时表，<code>EXPLAIN</code> 不一定会说<code>Using temporary</code>。</p>
<p>一些查询条件阻止使用内存中的临时表，在这种情况下，服务器将使用磁盘上的表：</p>
<ul>
<li>表格中 存在<a href="https://dev.mysql.com/doc/refman/5.7/en/blob.html" target="_blank" rel="noopener"><code>BLOB</code></a>或 <a href="https://dev.mysql.com/doc/refman/5.7/en/blob.html" target="_blank" rel="noopener"><code>TEXT</code></a>列。这包括具有字符串值的用户定义变量，因为它们分别被视为二进制或非二进制字符串，因此将其视为 <a href="https://dev.mysql.com/doc/refman/5.7/en/blob.html" target="_blank" rel="noopener"><code>BLOB</code></a>或 <a href="https://dev.mysql.com/doc/refman/5.7/en/blob.html" target="_blank" rel="noopener"><code>TEXT</code></a>列。</li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>如果使用<a href="https://dev.mysql.com/doc/refman/5.7/en/union.html" target="_blank" rel="noopener"><code>UNION</code></a>或 ，则列表中 存在最大长度大于512（字符串为二进制字符串，非二进制为字符）的任何字符串列<a href="https://dev.mysql.com/doc/refman/5.7/en/union.html" target="_blank" rel="noopener"><code>UNION ALL</code></a> 。</li>
<li>的<a href="https://dev.mysql.com/doc/refman/5.7/en/show-columns.html" target="_blank" rel="noopener"><code>SHOW COLUMNS</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/describe.html" target="_blank" rel="noopener"><code>DESCRIBE</code></a>语句中使用 <code>BLOB</code>作为用于某些列的类型，从而用于结果的临时表是磁盘上的表。</li>
</ul>
<p>服务器不会将临时表用于<a href="https://dev.mysql.com/doc/refman/5.7/en/union.html" target="_blank" rel="noopener"><code>UNION</code></a>满足某些条件的 语句。而是从临时表创建中仅保留执行结果列类型转换所需的数据结构。该表未完全实例化，并且没有向其写入或读取任何行；行直接发送到客户端。结果是减少了内存和磁盘需求，并减少了将第一行发送给客户端之前的延迟，因为服务器不必等到最后一个查询块执行完毕。<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>优化器跟踪输出反映了这种执行策略： <code>UNION RESULT</code> 查询块不存在，因为该块对应于从临时表中读取的部分。</p>
<p>这些条件<code>UNION</code>不带临时表即可进行评估：</p>
<ul>
<li>工会是<code>UNION ALL</code>，不是 <code>UNION</code>或<code>UNION DISTINCT</code>。</li>
<li>没有全局<code>ORDER BY</code>子句。</li>
<li>联合不是<code>{INSERT | REPLACE} ... SELECT ...</code> 语句的顶级查询块 。</li>
</ul>
<h4 id="内部临时表存储引擎"><a href="#内部临时表存储引擎" class="headerlink" title="内部临时表存储引擎"></a>内部临时表存储引擎</h4><p>内部临时表可以保存在内存中并由<code>MEMORY</code>存储引擎处理，或者由<code>InnoDB</code>或 <code>MyISAM</code>存储引擎存储在磁盘上。</p>
<p>如果内部临时表被创建为内存表，但是又太大了，MySQL会自动将其转换为磁盘表。内存中临时表的最大大小由<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_tmp_table_size" target="_blank" rel="noopener"><code>tmp_table_size</code></a>或 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_max_heap_table_size" target="_blank" rel="noopener"><code>max_heap_table_size</code></a>值定义 ，以较小者为准。这与使用<code>MEMORY</code>显式创建的表 不同 <a href="https://dev.mysql.com/doc/refman/5.7/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a>。对于此类表，仅<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_max_heap_table_size" target="_blank" rel="noopener"><code>max_heap_table_size</code></a> 变量确定表可以增长到多大，并且不转换为磁盘格式。</p>
<p>该 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_internal_tmp_disk_storage_engine" target="_blank" rel="noopener"><code>internal_tmp_disk_storage_engine</code></a> 变量定义服务器用于管理磁盘内部临时表的存储引擎。允许的值为 <code>INNODB</code>（默认值）和 <code>MYISAM</code>。</p>
<p>注意</p>
<p>使用时 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_internal_tmp_disk_storage_engine" target="_blank" rel="noopener"><code>internal_tmp_disk_storage_engine=INNODB</code></a>，生成超过<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-limits.html" target="_blank" rel="noopener"><code>InnoDB</code>行或列限制</a>的磁盘内部临时表的查询 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-limits.html" target="_blank" rel="noopener">将</a>返回行大小太大或列太多 错误。解决方法是设置 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_internal_tmp_disk_storage_engine" target="_blank" rel="noopener"><code>internal_tmp_disk_storage_engine</code></a> 为<code>MYISAM</code>。</p>
<p>在内存或磁盘中创建内部临时表时，服务器将增加该 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-status-variables.html#statvar_Created_tmp_tables" target="_blank" rel="noopener"><code>Created_tmp_tables</code></a>值。在磁盘上创建内部临时表时，服务器将增加该 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-status-variables.html#statvar_Created_tmp_disk_tables" target="_blank" rel="noopener"><code>Created_tmp_disk_tables</code></a> 值。如果磁盘上创建了太多内部临时表，请考虑增加 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_tmp_table_size" target="_blank" rel="noopener"><code>tmp_table_size</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_max_heap_table_size" target="_blank" rel="noopener"><code>max_heap_table_size</code></a>设置。</p>
<h4 id="内部临时表存储格式"><a href="#内部临时表存储格式" class="headerlink" title="内部临时表存储格式"></a>内部临时表存储格式</h4><p>内存中临时表由<code>MEMORY</code>存储引擎管理，该 引擎使用固定长度的行格式。<code>VARCHAR</code>和 <code>VARBINARY</code>列值被填充为最大列长度，实际上将它们存储为 <code>CHAR</code>和<code>BINARY</code>列。</p>
<p>磁盘上的临时表由<code>InnoDB</code>或<code>MyISAM</code>存储引擎管理 （取决于 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_internal_tmp_disk_storage_engine" target="_blank" rel="noopener"><code>internal_tmp_disk_storage_engine</code></a> 设置）。两个引擎都使用动态宽度行格式存储临时表。列仅占用所需的存储空间，与使用固定长度行的磁盘表相比，这减少了磁盘I / O，空间需求和处理时间。</p>
<p>对于最初在内存中创建内部临时表然后将其转换为磁盘上表的语句，跳过转换步骤并在磁盘上开始创建表可能会获得更好的性能。该 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_big_tables" target="_blank" rel="noopener"><code>big_tables</code></a>变量可用于强制内部临时表进行磁盘存储。</p>
<h3 id="8-4-5数据库和表数限制"><a href="#8-4-5数据库和表数限制" class="headerlink" title="8.4.5数据库和表数限制"></a>8.4.5数据库和表数限制</h3><p>MySQL对表的数量没有限制。基础文件系统可能会对表示表的文件数量有所限制。各个存储引擎可能会强加特定于引擎的约束。<code>InnoDB</code>最多允许40亿张桌子。</p>
<h3 id="8-4-6表格大小限制"><a href="#8-4-6表格大小限制" class="headerlink" title="8.4.6表格大小限制"></a>8.4.6表格大小限制</h3><p>MySQL数据库的有效最大表大小通常由操作系统对文件大小的限制来确定，而不是由MySQL内部限制来确定。有关操作系统文件大小限制的最新信息，请参阅特定于您的操作系统的文档。</p>
<p>Windows用户，请注意，FAT和VFAT（FAT32）都 <em>没有</em>被考虑用于MySQL的生产使用。请改用NTFS。</p>
<p>如果遇到全表错误，则可能由于多种原因导致它发生：</p>
<ul>
<li><p>磁盘可能已满。</p>
</li>
<li><p>您正在使用<code>InnoDB</code>表，并且<code>InnoDB</code>表空间文件中的空间已用完。最大表空间大小也是表的最大大小。有关表空间大小的限制，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-limits.html" target="_blank" rel="noopener">第14.23节“ InnoDB限制”</a>。</p>
<p>通常，对于大于1TB的表，建议将表划分为多个表空间文件。</p>
</li>
<li><p>您已达到操作系统文件大小限制。例如，您<code>MyISAM</code>在操作系统上使用的表仅支持最大2GB的文件，而数据文件或索引文件已达到此限制。</p>
</li>
<li><p>您正在使用一个<code>MyISAM</code>表，并且该表所需的空间超出了内部指针大小所允许的空间。<code>MyISAM</code>允许数据和索引文件默认增加到256TB，但是此限制可以更改为最大允许大小65,536TB（256 7 − 1字节）。</p>
<p>如果您需要一个<code>MyISAM</code>大于默认限制的表，并且您的操作系统支持大文件，则该<a href="https://dev.mysql.com/doc/refman/5.7/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a> 语句支持<code>AVG_ROW_LENGTH</code>和 <code>MAX_ROWS</code>选项。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/create-table.html" target="_blank" rel="noopener">第13.1.18节“ CREATE TABLE语句”</a>。服务器使用这些选项来确定允许表的大小。</p>
<p>如果指针大小对于现有表而言太小，则可以使用更改选项<a href="https://dev.mysql.com/doc/refman/5.7/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>以增加表的最大允许大小。请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/alter-table.html" target="_blank" rel="noopener">第13.1.8节“ ALTER TABLE语句”</a>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name MAX_ROWS=<span class="number">1000000000</span> AVG_ROW_LENGTH=nnn;</span><br></pre></td></tr></table></figure>

<p>您<code>AVG_ROW_LENGTH</code>只需为带有<a href="https://dev.mysql.com/doc/refman/5.7/en/blob.html" target="_blank" rel="noopener"><code>BLOB</code></a>或 <a href="https://dev.mysql.com/doc/refman/5.7/en/blob.html" target="_blank" rel="noopener"><code>TEXT</code></a>列的表指定；在这种情况下，MySQL无法仅根据行数来优化所需的空间。</p>
<p>要更改<code>MyISAM</code>表的默认大小限制 ，请设置 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_myisam_data_pointer_size" target="_blank" rel="noopener"><code>myisam_data_pointer_size</code></a>，它设置用于内部行指针的字节数。如果未指定<code>MAX_ROWS</code> 选项，则该值用于设置新表的指针大小。的值 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_myisam_data_pointer_size" target="_blank" rel="noopener"><code>myisam_data_pointer_size</code></a> 可以是2到7。值4允许最大4GB的表；值6允许最多256TB的表。</p>
<p>您可以使用以下语句检查最大数据和索引大小：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> <span class="keyword">STATUS</span> <span class="keyword">FROM</span> db_name <span class="keyword">LIKE</span> <span class="string">'tbl_name'</span>;</span><br></pre></td></tr></table></figure>

<p>您也可以使用<a href="https://dev.mysql.com/doc/refman/5.7/en/myisamchk.html" target="_blank" rel="noopener"><strong>myisamchk -dv / path / to / table-index-file</strong></a>。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/show.html" target="_blank" rel="noopener">第13.7.5节“ SHOW语句”</a>或<a href="https://dev.mysql.com/doc/refman/5.7/en/myisamchk.html" target="_blank" rel="noopener">第4.6.3节“ <strong>myisamchk</strong> -MyISAM表维护实用程序”</a>。</p>
<p>解决<code>MyISAM</code>表的文件大小限制的其他方法 如下：</p>
<ul>
<li>如果您的大表是只读的，则可以使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/myisampack.html" target="_blank" rel="noopener"><strong>myisampack对其</strong></a>进行压缩。 <a href="https://dev.mysql.com/doc/refman/5.7/en/myisampack.html" target="_blank" rel="noopener"><strong>myisampack</strong></a>通常会将表压缩至少50％，因此实际上您可以拥有更大的表。<a href="https://dev.mysql.com/doc/refman/5.7/en/myisampack.html" target="_blank" rel="noopener"><strong>myisampack</strong></a>还可以将多个表合并为一个表。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/myisampack.html" target="_blank" rel="noopener">第4.6.5节“ <strong>myisampack-</strong>生成压缩的只读MyISAM表”</a>。</li>
<li>MySQL包含一个<code>MERGE</code>库，使您能够处理<code>MyISAM</code>具有与单个<code>MERGE</code>表相同结构的表的集合 。请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/merge-storage-engine.html" target="_blank" rel="noopener">第15.7节“ MERGE存储引擎”</a>。</li>
</ul>
</li>
<li><p>您正在使用<code>MEMORY</code> （<code>HEAP</code>）存储引擎；在这种情况下，您需要增加<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_max_heap_table_size" target="_blank" rel="noopener"><code>max_heap_table_size</code></a>系统变量的值 。请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html" target="_blank" rel="noopener">第5.1.7节“服务器系统变量”</a>。</p>
</li>
</ul>
<h3 id="8-4-7表列数和行大小的限制"><a href="#8-4-7表列数和行大小的限制" class="headerlink" title="8.4.7表列数和行大小的限制"></a>8.4.7表列数和行大小的限制</h3><p>本节描述对表中的列数和单个行的大小的限制。</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/column-count-limit.html#column-count-limits" target="_blank" rel="noopener">列数限制</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/column-count-limit.html#row-size-limits" target="_blank" rel="noopener">行大小限制</a></li>
</ul>
<h4 id="列数限制"><a href="#列数限制" class="headerlink" title="列数限制"></a>列数限制</h4><p>MySQL对每个表有4096列的硬限制，但是对于给定的表，有效最大值可能会更少。确切的列限制取决于几个因素：</p>
<ul>
<li>一个表的最大行大小限制了列的数量（可能还有大小），因为所有列的总长度不能超过该大小。请参阅 <a href="https://dev.mysql.com/doc/refman/5.7/en/column-count-limit.html#row-size-limits" target="_blank" rel="noopener">行大小限制</a>。</li>
<li>单个列的存储要求限制了给定最大行大小内的列数。某些数据类型的存储要求取决于存储引擎，存储格式和字符集等因素。请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/storage-requirements.html" target="_blank" rel="noopener">第11.7节“数据类型存储要求”</a>。</li>
<li>存储引擎可能会施加其他限制表列计数的限制。例如， <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html" target="_blank" rel="noopener"><code>InnoDB</code></a>每个表的限制为1017列。请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-limits.html" target="_blank" rel="noopener">第14.23节“ InnoDB限制”</a>。有关其他存储引擎的信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/storage-engines.html" target="_blank" rel="noopener">第15章，<em>备用存储引擎</em></a>。</li>
<li>每个表都有一个<code>.frm</code>包含表定义的文件。该定义以可能影响表中允许的列数的方式影响此文件的内容。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/create-table-files.html#limits-frm-file" target="_blank" rel="noopener">.frm文件结构施加的限制</a>。</li>
</ul>
<h4 id="行大小限制"><a href="#行大小限制" class="headerlink" title="行大小限制"></a>行大小限制</h4><p>给定表的最大行大小由几个因素决定：</p>
<ul>
<li><p>MySQL表的内部表示具有65,535字节的最大行大小限制，即使存储引擎能够支持更大的行。 <a href="https://dev.mysql.com/doc/refman/5.7/en/blob.html" target="_blank" rel="noopener"><code>BLOB</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/blob.html" target="_blank" rel="noopener"><code>TEXT</code></a>列仅有助于朝向行大小限制9〜12字节，因为它们的内容是从该行的其余部分分开存储。</p>
</li>
<li><p><code>InnoDB</code> 对于4KB，8KB，16KB和32KB <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_page_size" target="_blank" rel="noopener"><code>innodb_page_size</code></a> 设置，表 的最大行大小（适用于本地存储在数据库页面内的数据）略小于页面的一半 。例如，对于默认的16KB <code>InnoDB</code>页面大小，最大行大小略小于8KB 。对于64KB页面，最大行大小略小于16KB。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-limits.html" target="_blank" rel="noopener">第14.23节“ InnoDB限制”</a>。</p>
<p>如果包含 <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_variable_length_type" target="_blank" rel="noopener">可变长度列</a>的<code>InnoDB</code> 行超过最大行大小，请<code>InnoDB</code>选择可变长度列进行外部页外存储，直到该行适合<code>InnoDB</code> 行大小限制。对于行外存储的变长列，本地存储的数据量因行格式而异。有关更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-row-format.html" target="_blank" rel="noopener">第14.11节“ InnoDB行格式”</a>。</p>
</li>
<li><p>不同的存储格式使用不同数量的页面标题和尾部数据，这会影响行可用的存储量。</p>
<ul>
<li>有关<code>InnoDB</code>行格式的信息，请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-row-format.html" target="_blank" rel="noopener">第14.11节“ InnoDB行格式”</a>。</li>
<li>有关<code>MyISAM</code> 存储格式的信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/myisam-table-formats.html" target="_blank" rel="noopener">第15.2.3节“ MyISAM表存储格式”</a>。</li>
</ul>
</li>
</ul>
<h5 id="行大小限制示例"><a href="#行大小限制示例" class="headerlink" title="行大小限制示例"></a>行大小限制示例</h5><ul>
<li><p>的65,535字节MySQL的最大行大小限制证明在下面<code>InnoDB</code> 和<code>MyISAM</code>实施例。不管存储引擎如何，都会强制执行该限制，即使存储引擎可能能够支持更大的行。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE t (a VARCHAR(10000), b VARCHAR(10000),</span><br><span class="line">       c VARCHAR(10000), d VARCHAR(10000), e VARCHAR(10000),</span><br><span class="line">       f VARCHAR(10000), g VARCHAR(6000)) ENGINE=InnoDB CHARACTER <span class="keyword">SET</span> latin1;</span><br><span class="line">ERROR 1118 (42000): Row size too large. The maximum row size for the used</span><br><span class="line">table type, not counting BLOBs, is 65535. This includes storage overhead,</span><br><span class="line"><span class="keyword">check</span> the manual. You have <span class="keyword">to</span> <span class="keyword">change</span> <span class="keyword">some</span> <span class="keyword">columns</span> <span class="keyword">to</span> <span class="built_in">TEXT</span> <span class="keyword">or</span> BLOBs</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE t (a VARCHAR(10000), b VARCHAR(10000),</span><br><span class="line">       c VARCHAR(10000), d VARCHAR(10000), e VARCHAR(10000),</span><br><span class="line">       f VARCHAR(10000), g VARCHAR(6000)) ENGINE=MyISAM CHARACTER <span class="keyword">SET</span> latin1;</span><br><span class="line">ERROR 1118 (42000): Row size too large. The maximum row size for the used</span><br><span class="line">table type, not counting BLOBs, is 65535. This includes storage overhead,</span><br><span class="line"><span class="keyword">check</span> the manual. You have <span class="keyword">to</span> <span class="keyword">change</span> <span class="keyword">some</span> <span class="keyword">columns</span> <span class="keyword">to</span> <span class="built_in">TEXT</span> <span class="keyword">or</span> BLOBs</span><br></pre></td></tr></table></figure>

<p>在以下<code>MyISAM</code>示例中，更改列可<a href="https://dev.mysql.com/doc/refman/5.7/en/blob.html" target="_blank" rel="noopener"><code>TEXT</code></a> 避免行数限制为65,535字节，并允许操作成功，因为 <a href="https://dev.mysql.com/doc/refman/5.7/en/blob.html" target="_blank" rel="noopener"><code>BLOB</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/blob.html" target="_blank" rel="noopener"><code>TEXT</code></a>列仅对行大小贡献9到12个字节。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE t (a VARCHAR(10000), b VARCHAR(10000),</span><br><span class="line">       c VARCHAR(10000), d VARCHAR(10000), e VARCHAR(10000),</span><br><span class="line">       f VARCHAR(10000), g TEXT(6000)) ENGINE=MyISAM CHARACTER <span class="keyword">SET</span> latin1;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br></pre></td></tr></table></figure>

<p>该<code>InnoDB</code> 表的操作成功，因为更改列 <a href="https://dev.mysql.com/doc/refman/5.7/en/blob.html" target="_blank" rel="noopener"><code>TEXT</code></a>可以避免MySQL 65,535字节的行大小限制，而<code>InnoDB</code> 变长列的页外存储可以避免 <code>InnoDB</code>行大小限制。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE t (a VARCHAR(10000), b VARCHAR(10000),</span><br><span class="line">       c VARCHAR(10000), d VARCHAR(10000), e VARCHAR(10000),</span><br><span class="line">       f VARCHAR(10000), g TEXT(6000)) ENGINE=InnoDB CHARACTER <span class="keyword">SET</span> latin1;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>可变长度列的存储包括长度字节，该长度字节计入行大小。例如，一 <a href="https://dev.mysql.com/doc/refman/5.7/en/char.html" target="_blank" rel="noopener"><code>VARCHAR(255) CHARACTER SET utf8mb3</code></a>列需要两个字节来存储值的长度，因此每个值最多可以占用767个字节。</p>
<p>创建表的语句<code>t1</code> 成功，因为列需要32,765 + 2字节和32,766 + 2字节，这在最大行大小65,535字节之内：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE t1</span><br><span class="line">       (c1 VARCHAR(32765) NOT NULL, c2 VARCHAR(32766) NOT NULL)</span><br><span class="line">       ENGINE = InnoDB CHARACTER <span class="keyword">SET</span> latin1;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br></pre></td></tr></table></figure>

<p>创建表的语句<code>t2</code>失败，因为尽管列长度在最大长度65,535字节以内，但仍需要两个额外的字节来记录该长度，这会导致行大小超过65,535字节：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE t2</span><br><span class="line">       (c1 VARCHAR(65535) NOT NULL)</span><br><span class="line">       ENGINE = InnoDB CHARACTER <span class="keyword">SET</span> latin1;</span><br><span class="line">ERROR 1118 (42000): Row size too large. The maximum row size for the used</span><br><span class="line">table type, not counting BLOBs, is 65535. This includes storage overhead,</span><br><span class="line"><span class="keyword">check</span> the manual. You have <span class="keyword">to</span> <span class="keyword">change</span> <span class="keyword">some</span> <span class="keyword">columns</span> <span class="keyword">to</span> <span class="built_in">TEXT</span> <span class="keyword">or</span> BLOBs</span><br></pre></td></tr></table></figure>

<p>将列长度减少到65,533或更短将使该语句成功。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE t2</span><br><span class="line">       (c1 VARCHAR(65533) NOT NULL)</span><br><span class="line">       ENGINE = InnoDB CHARACTER <span class="keyword">SET</span> latin1;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于<a href="https://dev.mysql.com/doc/refman/5.7/en/myisam-storage-engine.html" target="_blank" rel="noopener"><code>MyISAM</code></a>表， <code>NULL</code>列在行中需要额外的空间以记录其值是否为 <code>NULL</code>。每<code>NULL</code> 列多花一位，四舍五入到最接近的字节。</p>
<p>创建表的语句<code>t3</code>失败，因为除可变长度列长度字节所需的空间外，还<a href="https://dev.mysql.com/doc/refman/5.7/en/myisam-storage-engine.html" target="_blank" rel="noopener"><code>MyISAM</code></a>需要<code>NULL</code>列空间，从而导致行大小超过65,535字节：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE t3</span><br><span class="line">       (c1 VARCHAR(32765) NULL, c2 VARCHAR(32766) NULL)</span><br><span class="line">       ENGINE = MyISAM CHARACTER <span class="keyword">SET</span> latin1;</span><br><span class="line">ERROR 1118 (42000): Row size too large. The maximum row size for the used</span><br><span class="line">table type, not counting BLOBs, is 65535. This includes storage overhead,</span><br><span class="line"><span class="keyword">check</span> the manual. You have <span class="keyword">to</span> <span class="keyword">change</span> <span class="keyword">some</span> <span class="keyword">columns</span> <span class="keyword">to</span> <span class="built_in">TEXT</span> <span class="keyword">or</span> BLOBs</span><br></pre></td></tr></table></figure>

<p>有关列存储的信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-row-format.html" target="_blank" rel="noopener">第14.11节“ InnoDB行格式”</a>。 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html" target="_blank" rel="noopener"><code>InnoDB</code></a> <code>NULL</code></p>
</li>
<li><p><code>InnoDB</code>对于4KB，8KB，16KB和32KB <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_page_size" target="_blank" rel="noopener"><code>innodb_page_size</code></a> 设置，将行大小（用于数据库页面中本地存储的数据）限制为数据库页面的一半以下 ，而对于64KB页面，则限制为小于16KB。</p>
<p>创建表的语句<code>t4</code>失败，因为定义的列超出了16KB <code>InnoDB</code>页面的行大小限制。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE t4 (</span><br><span class="line">       c1 CHAR(255),c2 CHAR(255),c3 CHAR(255),</span><br><span class="line">       c4 CHAR(255),c5 CHAR(255),c6 CHAR(255),</span><br><span class="line">       c7 CHAR(255),c8 CHAR(255),c9 CHAR(255),</span><br><span class="line">       c10 CHAR(255),c11 CHAR(255),c12 CHAR(255),</span><br><span class="line">       c13 CHAR(255),c14 CHAR(255),c15 CHAR(255),</span><br><span class="line">       c16 CHAR(255),c17 CHAR(255),c18 CHAR(255),</span><br><span class="line">       c19 CHAR(255),c20 CHAR(255),c21 CHAR(255),</span><br><span class="line">       c22 CHAR(255),c23 CHAR(255),c24 CHAR(255),</span><br><span class="line">       c25 CHAR(255),c26 CHAR(255),c27 CHAR(255),</span><br><span class="line">       c28 CHAR(255),c29 CHAR(255),c30 CHAR(255),</span><br><span class="line">       c31 CHAR(255),c32 CHAR(255),c33 CHAR(255)</span><br><span class="line">       ) ENGINE=InnoDB ROW_FORMAT=COMPACT DEFAULT CHARSET latin1;</span><br><span class="line">ERROR 1118 (42000): Row size too large (&gt; 8126). Changing some columns to TEXT or BLOB or using</span><br><span class="line">ROW_FORMAT=DYNAMIC or ROW_FORMAT=COMPRESSED may help. <span class="keyword">In</span> <span class="keyword">current</span> <span class="keyword">row</span> <span class="keyword">format</span>, <span class="built_in">BLOB</span> prefix <span class="keyword">of</span> <span class="number">768</span></span><br><span class="line"><span class="keyword">bytes</span> <span class="keyword">is</span> <span class="keyword">stored</span> inline.</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="8-5优化InnoDB表"><a href="#8-5优化InnoDB表" class="headerlink" title="8.5优化InnoDB表"></a>8.5优化InnoDB表</h2><ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-storage-layout.html" target="_blank" rel="noopener">8.5.1优化InnoDB表的存储布局</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-transaction-management.html" target="_blank" rel="noopener">8.5.2优化InnoDB事务管理</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-ro-txn.html" target="_blank" rel="noopener">8.5.3优化InnoDB只读事务</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-logging.html" target="_blank" rel="noopener">8.5.4优化InnoDB重做日志</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-bulk-data-loading.html" target="_blank" rel="noopener">8.5.5 InnoDB表的批量数据加载</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-queries.html" target="_blank" rel="noopener">8.5.6优化InnoDB查询</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-ddl-operations.html" target="_blank" rel="noopener">8.5.7优化InnoDB DDL操作</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-diskio.html" target="_blank" rel="noopener">8.5.8优化InnoDB磁盘I / O</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-configuration-variables.html" target="_blank" rel="noopener">8.5.9优化InnoDB配置变量</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-many-tables.html" target="_blank" rel="noopener">8.5.10为具有多个表的系统优化InnoDB</a></li>
</ul>
<h3 id="8-5-1优化InnoDB表的存储布局"><a href="#8-5-1优化InnoDB表的存储布局" class="headerlink" title="8.5.1优化InnoDB表的存储布局"></a>8.5.1优化InnoDB表的存储布局</h3><ul>
<li><p>一旦数据达到稳定的大小，或者正在增长的表增加了几十或几百兆字节，请考虑使用该<code>OPTIMIZE TABLE</code>语句重新组织表并压缩所有浪费的空间。重组后的表需要较少的磁盘I / O来执行全表扫描。这是一种直接的技术，可以在其他技术（如改善索引使用率或调整应用程序代码）不可行时提高性能。</p>
<p><code>OPTIMIZE TABLE</code>复制表的数据部分并重建索引。好处来自改善索引内数据的打包，并减少了表空间和磁盘内的碎片。好处因每个表中的数据而异。您可能会发现其中一些收益显着，而其他收益则不大，或者收益随着时间的流逝而减少，直到您下次优化表格为止。如果表很大或正在重建的索引不适合缓冲池，则此操作可能会很慢。向表中添加大量数据后的第一次运行通常比以后的运行要慢得多。</p>
</li>
<li><p>在中<code>InnoDB</code>，拥有一个较长的值<code>PRIMARY KEY</code>（一个具有长值的列，或者形成一个较长的复合值的几列）会浪费大量的磁盘空间。在指向同一行的所有辅助索引记录中，行的主键值均重复。（请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-index-types.html" target="_blank" rel="noopener">第14.6.2.1节“聚集索引和二级索引”</a>。）<code>AUTO_INCREMENT</code>如果主键很长，则创建一列作为主键，或者为长<code>VARCHAR</code>列的前缀而不是整个列建立索引。</p>
</li>
<li><p>使用<a href="https://dev.mysql.com/doc/refman/5.7/en/char.html" target="_blank" rel="noopener"><code>VARCHAR</code></a>数据类型代替<a href="https://dev.mysql.com/doc/refman/5.7/en/char.html" target="_blank" rel="noopener"><code>CHAR</code></a>存储可变长度的字符串或用于具有许多<code>NULL</code>值的列 。甲 列总是占据字符来存储数据，即使该字符串是较短，或者其值 。较小的表更适合缓冲池并减少磁盘I / O。 <a href="https://dev.mysql.com/doc/refman/5.7/en/char.html" target="_blank" rel="noopener"><code>CHAR(*N*)</code></a><em>N</em><code>NULL</code></p>
<p>当使用<code>COMPACT</code>行格式（默认<code>InnoDB</code>格式）和可变长度字符集（例如 <code>utf8</code>或）时<code>sjis</code>， 列占据可变的空间量，但仍至少保留字节。 <a href="https://dev.mysql.com/doc/refman/5.7/en/char.html" target="_blank" rel="noopener"><code>CHAR(*N*)</code></a><em>N</em></p>
</li>
<li><p>对于大表或包含大量重复文本或数字数据的表，请考虑使用 <code>COMPRESSED</code>行格式。将数据带入缓冲池或执行全表扫描所需的磁盘I / O更少。在做出永久性决定之前，请先评估使用<code>COMPRESSED</code>vs <code>COMPACT</code>行格式可以实现的压缩量 。</p>
</li>
</ul>
<h3 id="8-5-2优化InnoDB事务管理"><a href="#8-5-2优化InnoDB事务管理" class="headerlink" title="8.5.2优化InnoDB事务管理"></a>8.5.2优化InnoDB事务管理</h3><p>要优化<code>InnoDB</code>事务处理，请在事务功能的性能开销与服务器的工作负载之间找到理想的平衡。例如，如果一个应用程序每秒提交数千次，则可能会遇到性能问题；如果仅每2-3小时提交一次，则可能会遇到不同的性能问题。</p>
<ul>
<li><p>默认的MySQL设置<code>AUTOCOMMIT=1</code> 可能会对繁忙的数据库服务器造成性能限制。在可行的情况下，通过发出<code>SET AUTOCOMMIT=0</code>或<code>START TRANSACTION</code>声明，<code>COMMIT</code>将所有相关的数据更改操作包装到单个事务中 ，然后在进行所有更改后添加一个 语句。</p>
<p><code>InnoDB</code>如果该事务对数据库进行了修改，则必须在每次事务提交时将日志刷新到磁盘。每次更改后都进行提交（与默认的自动提交设置一样）时，存储设备的I / O吞吐量将限制每秒可能进行的操作的数量。</p>
</li>
<li><p>另外，对于仅包含一个<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>语句的事务，打开它<code>AUTOCOMMIT</code>有助于 <code>InnoDB</code>识别只读事务并优化它们。有关要求<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-ro-txn.html" target="_blank" rel="noopener">，</a>请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-ro-txn.html" target="_blank" rel="noopener">第8.5.3节“优化InnoDB只读事务”</a>。</p>
</li>
<li><p>避免在插入，更新或删除大量行之后执行回滚。如果大事务减慢了服务器性能，则回滚它会使问题变得更糟，执行时间可能是原始数据更改操作的几倍。终止数据库进程无济于事，因为回滚会在服务器启动时再次开始。</p>
<p>为了最大程度地减少发生此问题的可能性：</p>
<ul>
<li>增加<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_buffer_pool" target="_blank" rel="noopener">缓冲池</a>的大小， 以便可以缓存所有数据更改更改，而不是立即将它们写入磁盘。</li>
<li>进行设置， <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_change_buffering" target="_blank" rel="noopener"><code>innodb_change_buffering=all</code></a> 以便除了插入操作外还缓冲更新和删除操作。</li>
<li>考虑<code>COMMIT</code>在大数据更改操作期间定期发布语句，可能将单个删除或更新分解为对较少行数进行操作的多个语句。</li>
</ul>
<p>要消除一旦发生的失控回滚，请增加缓冲池，以使回滚变得受CPU限制并快速运行，或者<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-recovery.html" target="_blank" rel="noopener">终止</a>服务器并重新启动 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_force_recovery" target="_blank" rel="noopener"><code>innodb_force_recovery=3</code></a>，如<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-recovery.html" target="_blank" rel="noopener">第14.19.2节“ InnoDB恢复”中所述</a>。</p>
<p>默认设置预计不会出现此问题，该默认设置 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_change_buffering" target="_blank" rel="noopener"><code>innodb_change_buffering=all</code></a>允许将更新和删除操作缓存在内存中，从而使它们首先可以更快地执行，并且在需要时可以更快地回滚。确保在处理具有许多插入，更新或删除操作的长期事务的服务器上使用此参数设置。</p>
</li>
<li><p>如果发生崩溃时，如果您可以承担一些最近提交的事务的损失，则可以将<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_flush_log_at_trx_commit" target="_blank" rel="noopener"><code>innodb_flush_log_at_trx_commit</code></a> 参数设置 为0。<code>InnoDB</code>尽管不能保证刷新，但还是尝试每秒刷新一次日志。另外，将值设置 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_support_xa" target="_blank" rel="noopener"><code>innodb_support_xa</code></a>为0，由于在磁盘数据和二进制日志上进行同步，这将减少磁盘刷新的次数。</p>
<p>注意</p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_support_xa" target="_blank" rel="noopener"><code>innodb_support_xa</code></a>已弃用，并将在以后的版本中删除。从MySQL 5.7.10开始，<code>InnoDB</code>始终启用对XA事务中两阶段提交的支持，并且<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_support_xa" target="_blank" rel="noopener"><code>innodb_support_xa</code></a>不再允许禁用 。</p>
</li>
<li><p>修改或删除行时，不会立即删除行和关联的 <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_undo_log" target="_blank" rel="noopener">撤消日志</a>，甚至不会在提交事务后立即删除。保留旧数据，直到更早或同时开始的事务完成为止，以便那些事务可以访问已修改或已删除行的先前状态。因此，长时间运行的事务可以防止<code>InnoDB</code>清除由其他事务更改的数据。</p>
</li>
<li><p>如果在长时间运行的事务中修改或删除行，则使用<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html#isolevel_read-committed" target="_blank" rel="noopener"><code>READ COMMITTED</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html#isolevel_repeatable-read" target="_blank" rel="noopener"><code>REPEATABLE READ</code></a>隔离级别的其他事务 必须读取旧的数据才能做得更多，以重建较旧的数据。</p>
</li>
<li><p>当长时间运行的事务修改表时，来自其他事务的对该表的查询不使用<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_covering_index" target="_blank" rel="noopener">覆盖索引</a>技术。通常可以从二级索引检索所有结果列，而从表数据中查找适当值的查询。</p>
<p>如果发现二级索引页面的索引 <code>PAGE_MAX_TRX_ID</code>太新，或者二级索引中的记录被删除标记，则 <code>InnoDB</code>可能需要使用聚集索引来查找记录。</p>
</li>
</ul>
<h3 id="8-5-3优化InnoDB只读事务"><a href="#8-5-3优化InnoDB只读事务" class="headerlink" title="8.5.3优化InnoDB只读事务"></a>8.5.3优化InnoDB只读事务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InnoDB&#96;可以避免与为已知为只读的[事务](https:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;5.7&#x2F;en&#x2F;glossary.html#glos_transaction_id)设置[事务ID](https:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;5.7&#x2F;en&#x2F;glossary.html#glos_transaction_id)（&#96;TRX_ID&#96;字段）相关的开销。只有可能执行写入操作或 [锁定读取](https:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;5.7&#x2F;en&#x2F;glossary.html#glos_locking_read)的[事务（](https:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;5.7&#x2F;en&#x2F;glossary.html#glos_transaction)例如） 需要事务ID 。消除不必要的事务ID可以减少每次查询或数据更改语句构造一个[读取视图](https:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;5.7&#x2F;en&#x2F;glossary.html#glos_read_view)时都要查询的内部数据结构的大小。 &#96;SELECT ... FOR UPDATE</span><br></pre></td></tr></table></figure>

<p><code>InnoDB</code> 在以下情况下检测到只读事务：</p>
<ul>
<li><p>事务从<a href="https://dev.mysql.com/doc/refman/5.7/en/commit.html" target="_blank" rel="noopener"><code>START TRANSACTION READ ONLY</code></a>语句开始 。在这种情况下，尝试对数据库（针对<code>InnoDB</code>， <code>MyISAM</code>或其他类型的表）进行更改会导致错误，并且事务将继续以只读状态运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR 1792 (25006): Cannot execute statement in a READ ONLY transaction.</span><br></pre></td></tr></table></figure>

<p>您仍然可以在只读事务中对特定于会话的临时表进行更改，或对其发出锁定查询，因为这些更改和锁定对于其他任何事务都不可见。</p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_autocommit" target="_blank" rel="noopener"><code>autocommit</code></a>启用 该设置后，保证事务是单个语句，组成事务的单个语句是“ 非锁定 ” <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>语句。也就是说， <code>SELECT</code>不使用<code>FOR UPDATE</code>or <code>LOCK IN SHARED MODE</code> 子句的a。</p>
</li>
<li><p>事务在没有该<code>READ ONLY</code>选项的情况下开始，但是尚未执行任何更新或显式锁定行的语句。在需要更新或显式锁之前，事务将保持只读模式。</p>
</li>
</ul>
<p>因此，对于诸如报告生成器之类的读取密集型应用程序，您可以<code>InnoDB</code> 通过在<a href="https://dev.mysql.com/doc/refman/5.7/en/commit.html" target="_blank" rel="noopener"><code>START TRANSACTION READ ONLY</code></a>和中 对它们进行分组来调整查询序列<a href="https://dev.mysql.com/doc/refman/5.7/en/commit.html" target="_blank" rel="noopener"><code>COMMIT</code></a>，或者通过<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_autocommit" target="_blank" rel="noopener"><code>autocommit</code></a> 在运行<code>SELECT</code>语句之前打开设置来调整查询 序列，或者简单地避免任何数据更改语句散布在查询中。</p>
<p>有关信息 <a href="https://dev.mysql.com/doc/refman/5.7/en/commit.html" target="_blank" rel="noopener"><code>START TRANSACTION</code></a>，并 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_autocommit" target="_blank" rel="noopener"><code>autocommit</code></a>请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/commit.html" target="_blank" rel="noopener">13.3.1节，“START TRANSACTION，COMMIT和ROLLBACK语句”</a>。</p>
<p>注意</p>
<p>符合自动提交，非锁定和只读（AC-NL-RO）资格的事务将保留在某些内部 <code>InnoDB</code>数据结构之外，因此不在<a href="https://dev.mysql.com/doc/refman/5.7/en/show-engine.html" target="_blank" rel="noopener"><code>SHOW ENGINE INNODB STATUS</code></a>输出中列出 。</p>
<h3 id="8-5-4优化InnoDB重做日志"><a href="#8-5-4优化InnoDB重做日志" class="headerlink" title="8.5.4优化InnoDB重做日志"></a>8.5.4优化InnoDB重做日志</h3><p>请考虑以下准则以优化重做日志记录：</p>
<ul>
<li><p>使重做日志文件变大，甚至与<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_buffer_pool" target="_blank" rel="noopener">缓冲池</a>一样大 。当 <code>InnoDB</code>写重做日志文件的完整，就必须写缓冲池到磁盘的修改内容的 <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_checkpoint" target="_blank" rel="noopener">检查点</a>。小的重做日志文件会导致许多不必要的磁盘写入。尽管历史上大的重做日志文件导致恢复时间很长，但是现在恢复速度要快得多，您可以放心地使用大的重做日志文件。</p>
<p>使用<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_log_file_size" target="_blank" rel="noopener"><code>innodb_log_file_size</code></a> 和 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_log_files_in_group" target="_blank" rel="noopener"><code>innodb_log_files_in_group</code></a> 配置选项配置重做日志文件的大小和数量。有关修改现有重做日志文件配置的信息，请参阅 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-redo-log.html#innodb-redo-log-file-reconfigure" target="_blank" rel="noopener">更改InnoDB重做日志文件的数量或大小</a>。</p>
</li>
<li><p>考虑增加<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_log_buffer" target="_blank" rel="noopener">日志缓冲区</a>的大小 。较大的日志缓冲区使大型 <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_transaction" target="_blank" rel="noopener">事务</a>可以运行，而无需在事务<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_commit" target="_blank" rel="noopener">提交</a>之前将日志写入磁盘。因此，如果您有更新，插入或删除许多行的事务，则使日志缓冲区更大可以节省磁盘I / O。使用<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_log_buffer_size" target="_blank" rel="noopener"><code>innodb_log_buffer_size</code></a> 配置选项配置日志缓冲区大小 。</p>
</li>
<li><p>配置 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_log_write_ahead_size" target="_blank" rel="noopener"><code>innodb_log_write_ahead_size</code></a> 配置选项以避免“ read-on-write ”。此选项定义重做日志的预写块大小。设置 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_log_write_ahead_size" target="_blank" rel="noopener"><code>innodb_log_write_ahead_size</code></a> 为与操作系统或文件系统缓存块大小匹配。当由于重做日志的预写块大小与操作系统或文件系统缓存块大小不匹配而导致重做日志块未完全缓存到操作系统或文件系统时，发生写时读取。</p>
<p>有效值为 日志文件块大小（2 n）的<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_log_write_ahead_size" target="_blank" rel="noopener"><code>innodb_log_write_ahead_size</code></a> 倍数。最小值是日志文件块大小（512）。指定最小值时，不会发生预写。最大值等于该 值。如果为其指定的值 大于该 值，则该 设置将被截断为该 值。 <code>InnoDB``InnoDB</code><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_page_size" target="_blank" rel="noopener"><code>innodb_page_size</code></a><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_log_write_ahead_size" target="_blank" rel="noopener"><code>innodb_log_write_ahead_size</code></a><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_page_size" target="_blank" rel="noopener"><code>innodb_page_size</code></a><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_log_write_ahead_size" target="_blank" rel="noopener"><code>innodb_log_write_ahead_size</code></a><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_page_size" target="_blank" rel="noopener"><code>innodb_page_size</code></a></p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_log_write_ahead_size" target="_blank" rel="noopener"><code>innodb_log_write_ahead_size</code></a> 相对于操作系统或文件系统缓存块大小， 将该值设置 得太低会导致写时读取。将该值设置得太高可能会<code>fsync</code>由于一次写入多个块而对日志文件写入的性能产生轻微影响 。</p>
</li>
</ul>
<h3 id="8-5-5-InnoDB表的批量数据加载"><a href="#8-5-5-InnoDB表的批量数据加载" class="headerlink" title="8.5.5 InnoDB表的批量数据加载"></a>8.5.5 InnoDB表的批量数据加载</h3><p>这些性能提示补充了<a href="https://dev.mysql.com/doc/refman/5.7/en/insert-optimization.html" target="_blank" rel="noopener">第8.2.4.1节“优化INSERT语句”中</a>有关快速插入的一般准则。</p>
<ul>
<li><p>将数据导入时<code>InnoDB</code>，请关闭自动提交模式，因为它会在每次插入时对磁盘执行日志刷新。要在导入操作期间禁用自动提交，请在其周围加上 <a href="https://dev.mysql.com/doc/refman/5.7/en/commit.html" target="_blank" rel="noopener"><code>SET autocommit</code></a>and <a href="https://dev.mysql.com/doc/refman/5.7/en/commit.html" target="_blank" rel="noopener"><code>COMMIT</code></a>语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit=<span class="number">0</span>;</span><br><span class="line">... SQL import statements ...</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>该<a href="https://dev.mysql.com/doc/refman/5.7/en/mysqldump.html" target="_blank" rel="noopener"><strong>mysqldump的</strong></a>选项 <a href="https://dev.mysql.com/doc/refman/5.7/en/mysqldump.html#option_mysqldump_opt" target="_blank" rel="noopener"><code>--opt</code></a>创建这样的快速导入到转储文件<code>InnoDB</code> 表，即使没有与他们包装 <a href="https://dev.mysql.com/doc/refman/5.7/en/commit.html" target="_blank" rel="noopener"><code>SET autocommit</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/commit.html" target="_blank" rel="noopener"><code>COMMIT</code></a>报表。</p>
</li>
<li><p>如果您<code>UNIQUE</code>对辅助键有限制，则可以通过在导入会话期间暂时关闭唯一性检查来加快表的导入：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> unique_checks=<span class="number">0</span>;</span><br><span class="line">... SQL import statements ...</span><br><span class="line"><span class="keyword">SET</span> unique_checks=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>对于大表，这可以节省大量磁盘I / O，因为 <code>InnoDB</code>可以使用其更改缓冲区批量写入辅助索引记录。确保数据不包含重复的键。</p>
</li>
<li><p>如果<code>FOREIGN KEY</code>表中有约束，可以通过在导入会话的持续时间内关闭外键检查来加快表的导入：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> foreign_key_checks=<span class="number">0</span>;</span><br><span class="line">... SQL import statements ...</span><br><span class="line"><span class="keyword">SET</span> foreign_key_checks=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>对于大表，这可以节省大量磁盘I / O。</p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a> 如果需要插入许多行， 请使用多行语法来减少客户端和服务器之间的通信开销：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> yourtable <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">2</span>), (<span class="number">5</span>,<span class="number">5</span>), ...;</span><br></pre></td></tr></table></figure>

<p>该技巧适用于插入到任何表中，而不仅仅是 <code>InnoDB</code>表。</p>
</li>
<li><p>在具有自动递增列的表中进行批量插入时，请设置 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_autoinc_lock_mode" target="_blank" rel="noopener"><code>innodb_autoinc_lock_mode</code></a>为2而不是默认值1。有关详细信息<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-auto-increment-handling.html" target="_blank" rel="noopener">，</a>请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-auto-increment-handling.html" target="_blank" rel="noopener">第14.6.1.6节“ InnoDB中的AUTO_INCREMENT处理”</a>。</p>
</li>
<li><p>执行批量插入时，按<code>PRIMARY KEY</code>顺序插入行会更快 。 <code>InnoDB</code>表使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_clustered_index" target="_blank" rel="noopener">聚集索引</a>，这使得使用数据顺序相对快<code>PRIMARY KEY</code>。<code>PRIMARY KEY</code>对于不能完全放入缓冲池中的表，按顺序执行批量插入尤为重要。</p>
</li>
<li><p>为了在将数据加载到<code>InnoDB</code> <code>FULLTEXT</code>索引中时获得最佳性能 ，请遵循以下步骤：</p>
<ol>
<li><p><code>FTS_DOC_ID</code>在创建表时 定义类型为的列<code>BIGINT UNSIGNED NOT NULL</code>，并使用名为的唯一索引 <code>FTS_DOC_ID_INDEX</code>。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (</span><br><span class="line">FTS_DOC_ID <span class="built_in">BIGINT</span> <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">title <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line"><span class="built_in">text</span> mediumtext <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`FTS_DOC_ID`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=latin1;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> FTS_DOC_ID_INDEX <span class="keyword">on</span> t1(FTS_DOC_ID);</span><br></pre></td></tr></table></figure>
</li>
<li><p>将数据加载到表中。</p>
</li>
<li><p><code>FULLTEXT</code>加载数据后 创建索引。</p>
</li>
</ol>
<p>注意</p>
<p><code>FTS_DOC_ID</code>在创建表 时添加列时，请确保在 <code>FTS_DOC_ID</code>更新<code>FULLTEXT</code>索引列时更新该 列，因为<code>FTS_DOC_ID</code>必须与<a href="https://dev.mysql.com/doc/refman/5.7/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>或 单调增加 <a href="https://dev.mysql.com/doc/refman/5.7/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a>。如果您选择不在<code>FTS_DOC_ID</code>表创建时添加，并<code>InnoDB</code>为您管理DOC ID，<code>InnoDB</code>则会<code>FTS_DOC_ID</code>在下一次<a href="https://dev.mysql.com/doc/refman/5.7/en/create-index.html" target="_blank" rel="noopener"><code>CREATE FULLTEXT INDEX</code></a>调用时将其添加 为隐藏列。但是，此方法需要重建表，这将影响性能。</p>
</li>
</ul>
<h3 id="8-5-6优化InnoDB查询"><a href="#8-5-6优化InnoDB查询" class="headerlink" title="8.5.6优化InnoDB查询"></a>8.5.6优化InnoDB查询</h3><p>要调整<code>InnoDB</code>表查询，请在每个表上创建一组适当的索引。有关详细信息<a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-indexes.html" target="_blank" rel="noopener">，</a>请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-indexes.html" target="_blank" rel="noopener">第8.3.1节“ MySQL如何使用索引”</a>。请遵循以下<code>InnoDB</code>索引准则：</p>
<ul>
<li>因为每个<code>InnoDB</code>表都有一个 <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_primary_key" target="_blank" rel="noopener">主键</a>（无论您是否请求一个<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_primary_key" target="_blank" rel="noopener">主键</a>），所以请为每个表指定一组主键列，这些列用于最重要且时间紧迫的查询中。</li>
<li>不要在主键中指定太多或太长的列，因为这些列值在每个辅助索引中都是重复的。当索引包含不必要的数据时，用于读取此数据的I / O和用于对其进行缓存的内存将降低服务器的性能和可伸缩性。</li>
<li>不要 为每一列创建单独的 <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_secondary_index" target="_blank" rel="noopener">二级索引</a>，因为每个查询只能使用一个索引。很少测试的列或只有几个不同值的列上的索引可能对任何查询都没有帮助。如果您对同一个表有很多查询，测试不同的列组合，请尝试创建少量的 <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_concatenated_index" target="_blank" rel="noopener">串联索引，</a>而不是大量的单列索引。如果索引包含结果集所需的所有列（称为 <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_covering_index" target="_blank" rel="noopener">覆盖索引</a>），则查询可能完全避免读取表数据。</li>
<li>如果索引列不能包含任何 <code>NULL</code>值，请<code>NOT NULL</code>在创建表时将其声明为。当优化器知道每一列是否包含<code>NULL</code>值时，它可以更好地确定哪个索引对查询最有效 。</li>
<li>您可以<code>InnoDB</code>使用<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-ro-txn.html" target="_blank" rel="noopener">第8.5.3节“优化InnoDB只读事务”中</a>的技术<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-ro-txn.html" target="_blank" rel="noopener">优化</a>表的 单查询事务 。</li>
</ul>
<h3 id="8-5-7优化InnoDB-DDL操作"><a href="#8-5-7优化InnoDB-DDL操作" class="headerlink" title="8.5.7优化InnoDB DDL操作"></a>8.5.7优化InnoDB DDL操作</h3><ul>
<li>对表和索引（很多DDL操作<code>CREATE</code>，<code>ALTER</code>和 <code>DROP</code>语句）可以在网上进行。有关详细信息<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-online-ddl.html" target="_blank" rel="noopener">，</a>请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-online-ddl.html" target="_blank" rel="noopener">第14.13节“ InnoDB和在线DDL”</a>。</li>
<li>在线DDL支持添加二级索引意味着您通常可以通过以下方式来创建和加载表及相关索引：创建不具有二级索引的表，然后在数据加载后添加二级索引，从而加快创建和加载表及关联索引的过程。</li>
<li>使用<a href="https://dev.mysql.com/doc/refman/5.7/en/truncate-table.html" target="_blank" rel="noopener"><code>TRUNCATE TABLE</code></a>空表，不。外键约束可以使一条语句像常规语句一样工作，在这种情况下，一系列命令可能会更快，例如 和 。 <code>DELETE FROM *tbl_name*``TRUNCATE``DELETE</code><a href="https://dev.mysql.com/doc/refman/5.7/en/drop-table.html" target="_blank" rel="noopener"><code>DROP TABLE</code></a><a href="https://dev.mysql.com/doc/refman/5.7/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a></li>
<li>因为主键对于每个<code>InnoDB</code>表的存储布局都是必不可少的，所以更改主键的定义涉及重新组织整个表，因此始终将主键设置为<a href="https://dev.mysql.com/doc/refman/5.7/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a>语句的一部分 ，并预先进行计划，这样您就不必 <code>ALTER</code>或<code>DROP</code>之后的主键。</li>
</ul>
<h3 id="8-5-8优化InnoDB磁盘I-O"><a href="#8-5-8优化InnoDB磁盘I-O" class="headerlink" title="8.5.8优化InnoDB磁盘I / O"></a>8.5.8优化InnoDB磁盘I / O</h3><ul>
<li><p>增加缓冲池大小</p>
<p>当表数据缓存在<code>InnoDB</code> 缓冲池中时，可以通过查询重复访问它，而无需任何磁盘I / O。使用<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_size" target="_blank" rel="noopener"><code>innodb_buffer_pool_size</code></a> 选项指定缓冲池的大小 。此内存区域非常重要，因此通常建议将 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_size" target="_blank" rel="noopener"><code>innodb_buffer_pool_size</code></a>其配置为系统内存的50％到75％。有关更多信息，请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/memory-use.html" target="_blank" rel="noopener">第8.12.4.1节“ MySQL如何使用内存”</a>。</p>
</li>
<li><p>调整冲洗方法</p>
<p>在某些版本的GNU / Linux和Unix中，使用Unix <code>fsync()</code>调用（ <code>InnoDB</code>默认使用）和类似方法将文件刷新到磁盘上的过程令人惊讶地缓慢。如果存在数据库写入性能问题，请使用<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_flush_method" target="_blank" rel="noopener"><code>innodb_flush_method</code></a> 参数设置为进行基准测试 <code>O_DSYNC</code>。</p>
</li>
<li><p>在Linux上将noop或截止日期I / O调度程序与本机AIO结合使用</p>
<p><code>InnoDB</code>在Linux上使用异步I / O子系统（本机AIO）来执行对数据文件页面的预读和写请求。此行为由<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_use_native_aio" target="_blank" rel="noopener"><code>innodb_use_native_aio</code></a> 配置选项控制，该选项默认情况下处于 启用状态。使用本机AIO，I / O调度程序的类型对I / O性能有更大的影响。通常，建议使用noop和截止日期I / O调度程序。进行基准测试，以确定哪个I / O调度程序为您的工作负载和环境提供最佳结果。有关更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-linux-native-aio.html" target="_blank" rel="noopener">第14.8.7节“在Linux上使用异步I / O”</a>。</p>
</li>
<li><p>在Solaris 10上对x86_64体系结构使用直接I / O</p>
<p><code>InnoDB</code>在Solaris 10的x86_64体系结构（AMD Opteron）上 使用存储引擎时，请对<code>InnoDB</code>相关文件使用直接I / O，以避免性能下降<code>InnoDB</code>。要对用于存储<code>InnoDB</code>相关文件的整个UFS文件系统使用直接I / O，请使用 <code>forcedirectio</code>选件将其挂载 。见 <code>mount_ufs(1M)</code>。（在Solaris 10 / x86_64上的默认设置是<em>不</em>使用此选项。）要仅将直接I / O应用于<code>InnoDB</code>文件操作而不是整个文件系统，请设置 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_flush_method" target="_blank" rel="noopener"><code>innodb_flush_method = O_DIRECT</code></a>。使用此设置， <code>InnoDB</code>呼叫 <code>directio()</code>代替 <code>fcntl()</code> 用于数据文件的I / O（不适用于日志文件的I / O）。</p>
</li>
<li><p>在Solaris 2.6或更高版本中将原始存储用于数据和日志文件</p>
<p>在任何Solaris 2.6和更高版本以及任何平台（sparc / x86 / x64 / amd64）上<code>InnoDB</code>使用具有高<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_size" target="_blank" rel="noopener"><code>innodb_buffer_pool_size</code></a>价值 的存储引擎时，请 <code>InnoDB</code>对原始设备或单独的直接I / O UFS上的数据文件和日志文件进行基准测试 文件系统，使用<code>forcedirectio</code>如前所述的安装选项。（<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_flush_method" target="_blank" rel="noopener"><code>innodb_flush_method</code></a>如果要为日志文件直接I / O ，则必须使用安装选项，而不是设置 。）Veritas文件系统VxFS的用户应使用 <code>convosync=direct</code>安装选项。</p>
<p>不要将其他MySQL数据文件（例如 <code>MyISAM</code>表的数据）放置在直接I / O文件系统上。可执行文件或库<em>不得</em>放置在直接I / O文件系统上。</p>
</li>
<li><p>使用其他存储设备</p>
<p>其他存储设备可用于设置RAID配置。有关相关信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/disk-issues.html" target="_blank" rel="noopener">第8.12.2节“优化磁盘I / O”</a>。</p>
<p>或者，<code>InnoDB</code>可以将表空间数据文件和日志文件放置在不同的物理磁盘上。有关更多信息，请参考以下部分：</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-init-startup-configuration.html" target="_blank" rel="noopener">第14.8.1节“ InnoDB启动配置”</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-create-table-external.html" target="_blank" rel="noopener">第14.6.1.2节“在外部创建表”</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/general-tablespaces.html#general-tablespaces-creating" target="_blank" rel="noopener">创建通用表空间</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-migration.html" target="_blank" rel="noopener">第14.6.1.4节“移动或复制InnoDB表”</a></li>
</ul>
</li>
<li><p>考虑非旋转存储</p>
<p>非旋转存储通常为随机I / O操作提供更好的性能。以及用于顺序I / O操作的旋转存储。在旋转式和非旋转式存储设备上分布数据和日志文件时，请考虑主要在每个文件上执行的I / O操作的类型。</p>
<p>面向随机I / O的文件通常包括 <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_file_per_table" target="_blank" rel="noopener">每表文件</a> 和<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_general_tablespace" target="_blank" rel="noopener">常规表空间</a>数据文件， <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_undo_tablespace" target="_blank" rel="noopener">撤消表空间</a> 文件以及 <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_temporary_tablespace" target="_blank" rel="noopener">临时表空间</a>文件。面向I / O的顺序文件包括<code>InnoDB</code> <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_system_tablespace" target="_blank" rel="noopener">系统表空间</a>文件（归因于 <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_doublewrite_buffer" target="_blank" rel="noopener">doublewrite缓冲</a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_change_buffer" target="_blank" rel="noopener">更改缓冲</a>）和日志文件，例如<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_binary_log" target="_blank" rel="noopener">二进制日志</a>文件和<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_redo_log" target="_blank" rel="noopener">重做日志</a>文件。</p>
<p>使用非旋转存储时，请查看以下配置选项的设置：</p>
<ul>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_checksum_algorithm" target="_blank" rel="noopener"><code>innodb_checksum_algorithm</code></a></p>
<p>该<code>crc32</code>选项使用更快的校验和算法，建议用于快速存储系统。</p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_flush_neighbors" target="_blank" rel="noopener"><code>innodb_flush_neighbors</code></a></p>
<p>优化旋转存储设备的I / O。禁止将其用于非旋转存储或旋转与非旋转存储的混合。</p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_io_capacity" target="_blank" rel="noopener"><code>innodb_io_capacity</code></a></p>
<p>对于较低端的非旋转存储设备，默认设置200通常就足够了。对于高端的，总线连接的设备，请考虑更高的设置，例如1000。</p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_io_capacity_max" target="_blank" rel="noopener"><code>innodb_io_capacity_max</code></a></p>
<p>默认值2000适用于使用非旋转存储的工作负载。对于高端的，总线连接的非旋转存储设备，请考虑更高的设置，例如2500。</p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_log_compressed_pages" target="_blank" rel="noopener"><code>innodb_log_compressed_pages</code></a></p>
<p>如果重做日志位于非循环存储上，请考虑禁用此选项以减少日志记录。请参阅 <a href="https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-diskio.html#innodb-disable-log-compressed-pages" target="_blank" rel="noopener">禁用压缩页面的日志记录</a>。</p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_log_file_size" target="_blank" rel="noopener"><code>innodb_log_file_size</code></a></p>
<p>如果重做日志位于非循环存储中，请配置此选项以最大化缓存和写入组合。</p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_page_size" target="_blank" rel="noopener"><code>innodb_page_size</code></a></p>
<p>考虑使用与磁盘的内部扇区大小匹配的页面大小。早期的SSD设备通常具有4KB的扇区大小。一些较新的设备具有16KB的扇区大小。默认<code>InnoDB</code> 页面大小为16KB。使页面大小接近存储设备块大小可以最大程度地减少重写到磁盘的未更改数据量。</p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/replication-options-binary-log.html#sysvar_binlog_row_image" target="_blank" rel="noopener"><code>binlog_row_image</code></a></p>
<p>如果二进制日志位于非循环存储上，并且所有表都具有主键，请考虑设置此选项<code>minimal</code>以减少日志记录。</p>
</li>
</ul>
<p>确保为您的操作系统启用了TRIM支持。通常默认情况下启用它。</p>
</li>
<li><p>增加I / O容量以避免积压</p>
<p>如果由于<code>InnoDB</code> <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_checkpoint" target="_blank" rel="noopener">检查点</a> 操作导致吞吐量周期性下降 ，请考虑增加<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_io_capacity" target="_blank" rel="noopener"><code>innodb_io_capacity</code></a> 配置选项的值 。较高的值会导致更频繁的 <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_flush" target="_blank" rel="noopener">刷新</a>，避免积压的工作量而导致工作量下降。</p>
</li>
<li><p>如果不落后冲洗，则I / O容量会降低</p>
<p>如果系统没有因<code>InnoDB</code> <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_flush" target="_blank" rel="noopener">刷新</a>操作而落后 ，请考虑降低<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_io_capacity" target="_blank" rel="noopener"><code>innodb_io_capacity</code></a> 配置选项的值 。通常，您将此选项值保持尽可能低，但又不要太低，以致导致周期性的吞吐量下降，如前面的项目符号所述。在可能降低选项值的典型情况下，您可能会在以下输出中看到类似的组合 <a href="https://dev.mysql.com/doc/refman/5.7/en/show-engine.html" target="_blank" rel="noopener"><code>SHOW ENGINE INNODB STATUS</code></a>：</p>
<ul>
<li>历史记录列表长度很低，低于几千。</li>
<li>插入缓冲区合并到插入的行附近。</li>
<li>缓冲池中的已修改页面始终远低于 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_max_dirty_pages_pct" target="_blank" rel="noopener"><code>innodb_max_dirty_pages_pct</code></a> 缓冲池。（在服务器不执行批量插入时测量；在批量插入过程中，修改后的页面百分比显着增加是正常的。）</li>
<li><code>Log sequence number - Last checkpoint</code> 小于<code>InnoDB</code> <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_log_file" target="_blank" rel="noopener">日志文件</a>总大小的7/8，或者理想情况下小于<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_log_file" target="_blank" rel="noopener">日志文件</a>总大小的6/8 。</li>
</ul>
</li>
<li><p>将系统表空间文件存储在Fusion-io设备上</p>
<p>通过在支持原子写入的Fusion-io设备上存储系统表空间文件（“ ibdata文件 ”），可以利用与双写缓冲区相关的I / O优化。在这种情况下，双写缓冲（<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_doublewrite" target="_blank" rel="noopener"><code>innodb_doublewrite</code></a>）将自动禁用，并且Fusion-io原子写操作将用于所有数据文件。此功能仅在Fusion-io硬件上受支持，并且仅在Linux上的Fusion-io NVMFS中启用。要充分利用此功能， 建议<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_flush_method" target="_blank" rel="noopener"><code>innodb_flush_method</code></a>设置<code>O_DIRECT</code>为。</p>
<p>注意</p>
<p>由于doublewrite缓冲区设置是全局的，因此对于非Fusion-io硬件上驻留的数据文件，还将禁用doublewrite缓冲。</p>
</li>
<li><p>禁用压缩页面的日志记录</p>
<p>使用<code>InnoDB</code>表 <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_compression" target="_blank" rel="noopener">压缩</a>功能时，对压缩数据进行更改时，将重新压缩的<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_page" target="_blank" rel="noopener">页面的</a>图像 写入 <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_redo_log" target="_blank" rel="noopener">重做日志</a>。此行为由控制 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_log_compressed_pages" target="_blank" rel="noopener"><code>innodb_log_compressed_pages</code></a>，默认情况下启用，以防止<code>zlib</code> 在恢复过程中使用不同版本的压缩算法时发生损坏。如果确定<code>zlib</code>版本不会更改，请禁用此选项 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_log_compressed_pages" target="_blank" rel="noopener"><code>innodb_log_compressed_pages</code></a> 以减少修改压缩数据的工作负载的重做日志生成。</p>
</li>
</ul>
<h3 id="8-5-9优化InnoDB配置变量"><a href="#8-5-9优化InnoDB配置变量" class="headerlink" title="8.5.9优化InnoDB配置变量"></a>8.5.9优化InnoDB配置变量</h3><p>与始终保持接近满负荷运行或遇到高峰活动的服务器相比，不同的设置最适合负载轻且可预测的服务器。</p>
<p>由于<code>InnoDB</code>存储引擎会自动执行许多优化，因此许多性能调整任务涉及监视以确保数据库运行良好，并在性能下降时更改配置选项。有关详细性能监控的信息<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-schema.html" target="_blank" rel="noopener">，</a>请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-schema.html" target="_blank" rel="noopener">第14.17节“ InnoDB与MySQL性能模式的集成”</a><code>InnoDB</code>。</p>
<p>您可以执行的主要配置步骤包括：</p>
<ul>
<li><code>InnoDB</code>在包含它们的系统上 启用高性能内存分配器。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-use_sys_malloc.html" target="_blank" rel="noopener">第14.8.4节“为InnoDB配置内存分配器”</a>。</li>
<li>控制数据更改操作的类型，以 <code>InnoDB</code>缓存更改的数据，以避免频繁的小磁盘写入。请参阅 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-change-buffer.html#innodb-change-buffer-configuration" target="_blank" rel="noopener">配置变更缓冲</a>。因为默认设置是缓冲所有类型的数据更改操作，所以仅在需要减少缓冲量时才更改此设置。</li>
<li>使用该<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_adaptive_hash_index" target="_blank" rel="noopener"><code>innodb_adaptive_hash_index</code></a> 选项打开和关闭自适应哈希索引功能 。有关更多信息<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-adaptive-hash.html" target="_blank" rel="noopener">，</a>请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-adaptive-hash.html" target="_blank" rel="noopener">第14.5.3节“自适应哈希索引”</a>。您可以在异常活动期间更改此设置，然后将其恢复为原始设置。</li>
<li><code>InnoDB</code>如果上下文切换是瓶颈，请 设置对处理的并发线程数的 限制。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-thread_concurrency.html" target="_blank" rel="noopener">第14.8.5节“为InnoDB配置线程并发”</a>。</li>
<li>控制<code>InnoDB</code>与其预读操作有关的预取量 。当系统具有未使用的I / O容量时，更多的预读可以提高查询的性能。过多的预读可能会导致负载较重的系统上的性能定期下降。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-read_ahead.html" target="_blank" rel="noopener">第14.8.3.4节“配置InnoDB缓冲池预取（预读）”</a>。</li>
<li>如果您具有默认值未完全利用的高端I / O子系统，则增加用于读取或写入操作的后台线程的数量。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-multiple_io_threads.html" target="_blank" rel="noopener">第14.8.6节“配置后台InnoDB I / O线程数”</a>。</li>
<li>控制<code>InnoDB</code>在后台执行多少I / O。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-configuring-io-capacity.html" target="_blank" rel="noopener">第14.8.8节“配置InnoDB I / O容量”</a>。如果观察到性能周期性下降，则可以缩减此设置。</li>
<li>控制确定何时<code>InnoDB</code>执行某些类型的后台写入的算法 。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool-flushing.html" target="_blank" rel="noopener">第14.8.3.5节“配置缓冲池刷新”</a>。该算法适用于某些类型的工作负载，但不适用于其他类型的工作负载，因此如果您观察到性能周期性下降，则可能会关闭此设置。</li>
<li>利用多核处理器及其高速缓存存储器配置来最大程度地减少上下文切换中的延迟。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-spin_lock_polling.html" target="_blank" rel="noopener">第14.8.9节“配置自旋锁定轮询”</a>。</li>
<li>防止诸如表扫描之类的一次性操作干扰存储在<code>InnoDB</code>缓冲区高速缓存中的频繁访问的数据 。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-midpoint_insertion.html" target="_blank" rel="noopener">第14.8.3.3节“使缓冲池扫描具有抵抗力”</a>。</li>
<li>将日志文件调整为对可靠性和崩溃恢复有意义的大小。<code>InnoDB</code> 日志文件通常保持较小，以避免崩溃后启动时间过长。MySQL 5.5中引入的优化加快了崩溃<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_crash_recovery" target="_blank" rel="noopener">恢复</a>过程的某些步骤 。特别是，由于改进了内存管理算法，因此扫描 <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_redo_log" target="_blank" rel="noopener">重做日志</a>和应用重做日志的速度更快。如果您人为地减少了日志文件的大小以避免启动时间过长，现在可以考虑增加日志文件的大小，以减少由于重做日志记录的回收而产生的I / O。</li>
<li>配置<code>InnoDB</code>缓冲池实例的大小和数量，这 对于具有数千兆字节缓冲池的系统而言尤其重要。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-multiple-buffer-pools.html" target="_blank" rel="noopener">第14.8.3.2节“配置多个缓冲池实例”</a>。</li>
<li>增加并发事务的最大数量，从而极大地提高了最繁忙数据库的可伸缩性。请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-undo-logs.html" target="_blank" rel="noopener">第14.6.7节“撤消日志”</a>。</li>
<li>将清除操作（一种垃圾收集）移动到后台线程中。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-purge-configuration.html" target="_blank" rel="noopener">第14.8.10节“清除配置”</a>。为了有效地测量此设置的结果，请首先调整其他与I / O相关的配置和与线程相关的配置设置。</li>
<li>减少<code>InnoDB</code>在并发线程之间进行的切换量 ，以使繁忙的服务器上的SQL操作不会排队并形成“ 流量阻塞 ”。为该<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_thread_concurrency" target="_blank" rel="noopener"><code>innodb_thread_concurrency</code></a> 选项设置一个值，对于一个高性能的现代系统，最多可以设置为 32。增加<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_concurrency_tickets" target="_blank" rel="noopener"><code>innodb_concurrency_tickets</code></a> 选项的值 ，通常到5000左右。选项的这种组合设置了线程数量的上限 <code>InnoDB</code> 进程可以随时进行处理，并允许每个线程在被换出之前做大量工作，从而使等待线程的数量保持较低水平，并且无需过多的上下文切换即可完成操作。</li>
</ul>
<h3 id="8-5-10为具有多个表的系统优化InnoDB"><a href="#8-5-10为具有多个表的系统优化InnoDB" class="headerlink" title="8.5.10为具有多个表的系统优化InnoDB"></a>8.5.10为具有多个表的系统优化InnoDB</h3><ul>
<li><p>如果您已配置 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-statistics-estimation.html" target="_blank" rel="noopener">的非持久性优化统计</a>（非默认配置）， <code>InnoDB</code>计算指标 <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_cardinality" target="_blank" rel="noopener">基数</a>值表中的第一次表，启动后访问的，而不是存储在表这样的值。在将数据划分为多个表的系统上，此步骤可能会花费大量时间。由于此开销仅适用于初始表打开操作，因此要“ 预热 ” 表以供以后使用，请在启动后立即通过发出诸如的语句来访问该表。 <code>SELECT 1 FROM *tbl_name* LIMIT 1</code></p>
<p>默认情况下，优化器统计信息会保留在磁盘上，并由<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_stats_persistent" target="_blank" rel="noopener"><code>innodb_stats_persistent</code></a> 配置选项启用 。有关持久性优化器统计信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-persistent-stats.html" target="_blank" rel="noopener">第14.8.11.1节“配置持久性优化器统计参数”</a>。</p>
</li>
</ul>
<h2 id="8-6优化MyISAM表"><a href="#8-6优化MyISAM表" class="headerlink" title="8.6优化MyISAM表"></a>8.6优化MyISAM表</h2><ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizing-queries-myisam.html" target="_blank" rel="noopener">8.6.1优化MyISAM查询</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizing-myisam-bulk-data-loading.html" target="_blank" rel="noopener">8.6.2 MyISAM表的批量数据加载</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/repair-table-optimization.html" target="_blank" rel="noopener">8.6.3优化REPAIR TABLE语句</a></li>
</ul>
<p>该<a href="https://dev.mysql.com/doc/refman/5.7/en/myisam-storage-engine.html" target="_blank" rel="noopener"><code>MyISAM</code></a>存储引擎执行最好的读数据或低并发操作，因为表锁限制进行同步更新的能力。在MySQL中，<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html" target="_blank" rel="noopener"><code>InnoDB</code></a>是默认的存储引擎，而不是<code>MyISAM</code>。</p>
<h3 id="8-6-1优化MyISAM查询"><a href="#8-6-1优化MyISAM查询" class="headerlink" title="8.6.1优化MyISAM查询"></a>8.6.1优化MyISAM查询</h3><p>一些加快<code>MyISAM</code>表查询速度的一般技巧 ：</p>
<ul>
<li><p>为了帮助MySQL更好地优化查询，<a href="https://dev.mysql.com/doc/refman/5.7/en/myisamchk.html" target="_blank" rel="noopener"><strong>请</strong></a>在对表加载数据后对表使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/analyze-table.html" target="_blank" rel="noopener"><code>ANALYZE TABLE</code></a>或运行 <a href="https://dev.mysql.com/doc/refman/5.7/en/myisamchk.html" target="_blank" rel="noopener"><strong>myisamchk –analyze</strong></a>。这将为每个索引部分更新一个值，该值指示具有相同值的平均行数。（对于唯一索引，该值始终为1。）当基于非恒定表达式联接两个表时，MySQL使用它来决定选择哪个索引。您可以通过使用和检查值来检查表分析的结果 。<a href="https://dev.mysql.com/doc/refman/5.7/en/myisamchk.html" target="_blank" rel="noopener"><strong>myisamchk –description –verbose</strong></a>显示索引分布信息。 <code>SHOW INDEX FROM *tbl_name*``Cardinality</code></p>
</li>
<li><p>要根据索引对索引和数据进行排序，请使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/myisamchk.html" target="_blank" rel="noopener"><strong>myisamchk –sort-index –sort-records = 1</strong></a> （假设您要对索引1进行排序）。如果您有唯一的索引，要根据该索引按顺序读取所有行，这是使查询更快的一种好方法。第一次以这种方式对大表进行排序可能会花费很长时间。</p>
</li>
<li><p>尝试避免<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a> 对<code>MyISAM</code>频繁更新的表进行复杂的查询，以避免由于读取器和写入器之间的争用而发生的表锁定问题。</p>
</li>
<li><p><code>MyISAM</code>支持并发插入：如果表在数据文件中间没有空闲块，则可以<a href="https://dev.mysql.com/doc/refman/5.7/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>在其他线程从表读取数据的同时向其中添加新行。如果能够做到这一点很重要，请考虑以避免删除行的方式使用表。另一种可能性是运行<a href="https://dev.mysql.com/doc/refman/5.7/en/optimize-table.html" target="_blank" rel="noopener"><code>OPTIMIZE TABLE</code></a>到整理表你已经删除了很多这行之后。通过设置<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_concurrent_insert" target="_blank" rel="noopener"><code>concurrent_insert</code></a>变量可以更改此行为 。您甚至可以在已删除行的表中强制添加新行（并因此允许并发插入）。请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/concurrent-inserts.html" target="_blank" rel="noopener">第8.11.3节“并发插入”</a>。</p>
</li>
<li><p>对于<code>MyISAM</code>表经常变化的，尽量避免所有变长列（<a href="https://dev.mysql.com/doc/refman/5.7/en/char.html" target="_blank" rel="noopener"><code>VARCHAR</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/blob.html" target="_blank" rel="noopener"><code>BLOB</code></a>，和 <a href="https://dev.mysql.com/doc/refman/5.7/en/blob.html" target="_blank" rel="noopener"><code>TEXT</code></a>）。如果该表甚至包含单个可变长度列，则使用动态行格式。请参阅<a href="https://dev.mysql.com/doc/refman/5.7/en/storage-engines.html" target="_blank" rel="noopener">第15章，<em>备用存储引擎</em></a>。</p>
</li>
<li><p>通常，仅由于行变大而将表拆分为不同的表是没有用的。在访问一行时，最大的性能损失是找到该行第一个字节所需的磁盘搜索。找到数据后，大多数现代磁盘可以以足够快的速度读取整个行，以适合大多数应用程序。拆分表的唯一情况是<code>MyISAM</code>，可以更改为固定行大小的表是使用动态行格式的 表，还是经常需要扫描表但不需要大多数列的表。请参阅<a href="https://dev.mysql.com/doc/refman/5.7/en/storage-engines.html" target="_blank" rel="noopener">第15章，<em>备用存储引擎</em></a>。</p>
</li>
<li><p>通常用于按顺序检索行时 使用。通过在对该表进行大量更改之后使用此选项，您可能可以获得更高的性能。 <code>ALTER TABLE ... ORDER BY *expr1*, *expr2*, ...``*expr1*, *expr2*, ...</code></p>
</li>
<li><p>如果您经常需要基于许多行中的信息来计算结果（例如计数），则最好引入一个新表并实时更新计数器。以下表格的更新非常快：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> tbl_name <span class="keyword">SET</span> count_col=count_col+<span class="number">1</span> <span class="keyword">WHERE</span> key_col=<span class="keyword">constant</span>;</span><br></pre></td></tr></table></figure>

<p>当您使用MySQL存储引擎（例如<code>MyISAM</code>仅具有表级锁定（具有单个编写器的多个读取器））时，这非常重要。这也使大多数数据库系统具有更好的性能，因为在这种情况下，行锁定管理器的工作量减少了。</p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/optimize-table.html" target="_blank" rel="noopener"><code>OPTIMIZE TABLE</code></a> 定期 使用以避免动态格式<code>MyISAM</code>表的碎片化 。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/myisam-table-formats.html" target="_blank" rel="noopener">第15.2.3节“ MyISAM表存储格式”</a>。</p>
</li>
<li><p><code>MyISAM</code>使用 <code>DELAY_KEY_WRITE=1</code>table选项 声明表可以使索引更新更快，因为在关闭表之前它们不会刷新到磁盘。不利的一面是，如果在打开此类表的过程中某人杀死了服务器，则必须通过<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_myisam_recover_options" target="_blank" rel="noopener"><code>myisam_recover_options</code></a> 设置系统变量集运行服务器或在重新启动服务器之前运行 <a href="https://dev.mysql.com/doc/refman/5.7/en/myisamchk.html" target="_blank" rel="noopener"><strong>myisamchk</strong></a>来确保该表正常 。（但是，即使在这种情况下，也不要通过使用来丢失任何内容<code>DELAY_KEY_WRITE</code>，因为密钥信息始终可以从数据行中生成。）</p>
</li>
<li><p>字符串会在<code>MyISAM</code>索引中自动压缩前缀和结尾空间。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/create-index.html" target="_blank" rel="noopener">第13.1.14节“ CREATE INDEX语句”</a>。</p>
</li>
<li><p>您可以通过在应用程序中缓存查询或答案，然后一起执行许多插入或更新操作来提高性能。在此操作期间锁定表可确保索引缓存在所有更新后仅刷新一次。您还可以利用MySQL的查询缓存来获得相似的结果。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/query-cache.html" target="_blank" rel="noopener">第8.10.3节“ MySQL查询缓存”</a>。</p>
</li>
</ul>
<h3 id="8-6-2-MyISAM表的批量数据加载"><a href="#8-6-2-MyISAM表的批量数据加载" class="headerlink" title="8.6.2 MyISAM表的批量数据加载"></a>8.6.2 MyISAM表的批量数据加载</h3><p>这些性能提示补充了<a href="https://dev.mysql.com/doc/refman/5.7/en/insert-optimization.html" target="_blank" rel="noopener">第8.2.4.1节“优化INSERT语句”中</a>有关快速插入的一般准则。</p>
<ul>
<li><p>对于<code>MyISAM</code>表，<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>如果数据文件中间没有删除的行，则可以在语句运行的同时使用并发插入来添加行 。请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/concurrent-inserts.html" target="_blank" rel="noopener">第8.11.3节“并发插入”</a>。</p>
</li>
<li><p>通过做一些额外的工作，可以在表具有多个索引的情况下使 表的<a href="https://dev.mysql.com/doc/refman/5.7/en/load-data.html" target="_blank" rel="noopener"><code>LOAD DATA</code></a>运行速度更快<code>MyISAM</code>。使用以下过程：</p>
<ol>
<li>执行一条<a href="https://dev.mysql.com/doc/refman/5.7/en/flush.html#flush-tables" target="_blank" rel="noopener"><code>FLUSH TABLES</code></a> 语句或一个<a href="https://dev.mysql.com/doc/refman/5.7/en/mysqladmin.html" target="_blank" rel="noopener"><strong>mysqladmin flush-tables</strong></a>命令。</li>
<li>使用<a href="https://dev.mysql.com/doc/refman/5.7/en/myisamchk.html" target="_blank" rel="noopener"><strong>myisamchk –keys-used = 0 -rq /path/to/db/tbl_name</strong></a> 删除表的所有索引使用。</li>
<li>使用将数据插入表中 <a href="https://dev.mysql.com/doc/refman/5.7/en/load-data.html" target="_blank" rel="noopener"><code>LOAD DATA</code></a>。这不会更新任何索引，因此非常快。</li>
<li>如果将来只打算从表中读取，请使用<a href="https://dev.mysql.com/doc/refman/5.7/en/myisampack.html" target="_blank" rel="noopener"><strong>myisampack对其</strong></a>进行压缩。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/compressed-format.html" target="_blank" rel="noopener">第15.2.3.3节“压缩表特性”</a>。</li>
<li>使用<a href="https://dev.mysql.com/doc/refman/5.7/en/myisamchk.html" target="_blank" rel="noopener"><strong>myisamchk -rq /path/to/db/tbl_name</strong></a>重新创建索引。这样可以在将索引树写入磁盘之前在内存中创建索引树，这比更新索引树期间快得多，<a href="https://dev.mysql.com/doc/refman/5.7/en/load-data.html" target="_blank" rel="noopener"><code>LOAD DATA</code></a>因为它避免了很多磁盘寻道。生成的索引树也完美平衡。</li>
<li>执行一条<a href="https://dev.mysql.com/doc/refman/5.7/en/flush.html#flush-tables" target="_blank" rel="noopener"><code>FLUSH TABLES</code></a> 语句或一个<a href="https://dev.mysql.com/doc/refman/5.7/en/mysqladmin.html" target="_blank" rel="noopener"><strong>mysqladmin flush-tables</strong></a>命令。</li>
</ol>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/load-data.html" target="_blank" rel="noopener"><code>LOAD DATA</code></a>如果<code>MyISAM</code>要向其中插入数据的表为空，则会自动执行上述优化 。自动优化与显式使用该过程之间的主要区别在于，与让服务器在执行语句时为索引重新创建分配的空间相比，可以使 <a href="https://dev.mysql.com/doc/refman/5.7/en/myisamchk.html" target="_blank" rel="noopener"><strong>myisamchk</strong></a>为索引创建分配的临时内存要多得多 <a href="https://dev.mysql.com/doc/refman/5.7/en/load-data.html" target="_blank" rel="noopener"><code>LOAD DATA</code></a>。</p>
<p>您还可以<code>MyISAM</code>使用以下语句而不是<a href="https://dev.mysql.com/doc/refman/5.7/en/myisamchk.html" target="_blank" rel="noopener"><strong>myisamchk</strong></a>来禁用或启用表的非唯一索引 。如果使用这些语句，则可以跳过以下 <a href="https://dev.mysql.com/doc/refman/5.7/en/flush.html#flush-tables" target="_blank" rel="noopener"><code>FLUSH TABLES</code></a>操作：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">DISABLE</span> <span class="keyword">KEYS</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">ENABLE</span> <span class="keyword">KEYS</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>要加快<a href="https://dev.mysql.com/doc/refman/5.7/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>对非事务性表使用多个语句执行的操作，请锁定表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LOCK</span> <span class="keyword">TABLES</span> a WRITE;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> a <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">23</span>),(<span class="number">2</span>,<span class="number">34</span>),(<span class="number">4</span>,<span class="number">33</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> a <span class="keyword">VALUES</span> (<span class="number">8</span>,<span class="number">26</span>),(<span class="number">6</span>,<span class="number">29</span>);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">UNLOCK</span> <span class="keyword">TABLES</span>;</span><br></pre></td></tr></table></figure>

<p>这将提高性能，因为在所有<a href="https://dev.mysql.com/doc/refman/5.7/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>语句完成后，索引缓冲区仅刷新一次到磁盘 。通常，索引缓冲区刷新与<a href="https://dev.mysql.com/doc/refman/5.7/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a> 语句数量一样多。如果您可以使用插入所有行，则不需要显式锁定语句 <a href="https://dev.mysql.com/doc/refman/5.7/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>。</p>
<p>锁定还减少了多连接测试的总时间，尽管单个连接的最大等待时间可能会增加，因为它们会等待锁定。假设五个客户端尝试同时执行插入，如下所示：</p>
<ul>
<li>连接1可插入1000次</li>
<li>连接2、3和4做1插入</li>
<li>连接5可插入1000次</li>
</ul>
<p>如果不使用锁定，则连接2、3和4会在1和5之前完成。如果使用锁定，则连接2、3和4可能不会在1或5之前完成，但是总时间应为40％快点。</p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>，， <a href="https://dev.mysql.com/doc/refman/5.7/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/delete.html" target="_blank" rel="noopener"><code>DELETE</code></a>操作在MySQL中非常快，但是您可以通过在执行大约五个以上的连续插入或更新的所有操作周围添加锁来获得更好的整体性能。如果您执行了很多连续的插入操作，则可以<a href="https://dev.mysql.com/doc/refman/5.7/en/lock-tables.html" target="_blank" rel="noopener"><code>LOCK TABLES</code></a>不时进行 <a href="https://dev.mysql.com/doc/refman/5.7/en/lock-tables.html" target="_blank" rel="noopener"><code>UNLOCK TABLES</code></a>一次之后的操作（每行1,000行左右），以允许其他线程访问表。这仍然会带来不错的性能提升。</p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a><a href="https://dev.mysql.com/doc/refman/5.7/en/load-data.html" target="_blank" rel="noopener"><code>LOAD DATA</code></a>即使使用上述策略，加载数据的速度仍然比慢得多。</p>
</li>
<li><p>为了提高<code>MyISAM</code> 表的性能，对于<a href="https://dev.mysql.com/doc/refman/5.7/en/load-data.html" target="_blank" rel="noopener"><code>LOAD DATA</code></a> 和<a href="https://dev.mysql.com/doc/refman/5.7/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>，都可以通过增加<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_key_buffer_size" target="_blank" rel="noopener"><code>key_buffer_size</code></a>系统变量来扩大键缓存 。请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/server-configuration.html" target="_blank" rel="noopener">第5.1.1节“配置服务器”</a>。</p>
</li>
</ul>
<h3 id="8-6-3优化REPAIR-TABLE语句"><a href="#8-6-3优化REPAIR-TABLE语句" class="headerlink" title="8.6.3优化REPAIR TABLE语句"></a>8.6.3优化REPAIR TABLE语句</h3><p><a href="https://dev.mysql.com/doc/refman/5.7/en/repair-table.html" target="_blank" rel="noopener"><code>REPAIR TABLE</code></a>用于 <code>MyISAM</code>表的操作类似于使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/myisamchk.html" target="_blank" rel="noopener"><strong>myisamchk</strong></a>进行修复操作，并且应用了一些相同的性能优化：</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/myisamchk.html" target="_blank" rel="noopener"><strong>myisamchk</strong></a>具有控制内存分配的变量。您可以通过设置这些变量来提高性能，如 <a href="https://dev.mysql.com/doc/refman/5.7/en/myisamchk-memory.html" target="_blank" rel="noopener">第4.6.3.6节“ myisamchk内存使用情况”中所述</a>。</li>
<li>对于<a href="https://dev.mysql.com/doc/refman/5.7/en/repair-table.html" target="_blank" rel="noopener"><code>REPAIR TABLE</code></a>，应用相同的原理，但是由于修复是由服务器完成的，因此您可以设置服务器系统变量而不是 <a href="https://dev.mysql.com/doc/refman/5.7/en/myisamchk.html" target="_blank" rel="noopener"><strong>myisamchk</strong></a>变量。此外，除了设置内存分配变量外，增加 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_myisam_max_sort_file_size" target="_blank" rel="noopener"><code>myisam_max_sort_file_size</code></a> 系统变量还增加了修复将使用较快的文件排序方法的可能性，并避免了通过键缓存方法进行较慢的修复。在检查以确保有足够的可用空间来保存表文件的副本之后，将变量设置为系统的最大文件大小。可用空间在包含原始表文件的文件系统中必须可用。</li>
</ul>
<p>假设使用以下选项来设置<a href="https://dev.mysql.com/doc/refman/5.7/en/myisamchk.html" target="_blank" rel="noopener"><strong>myisamchk</strong></a>表修复操作，以设置其内存分配变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--key_buffer_size&#x3D;128M --myisam_sort_buffer_size&#x3D;256M</span><br><span class="line">--read_buffer_size&#x3D;64M --write_buffer_size&#x3D;64M</span><br></pre></td></tr></table></figure>

<p>其中一些<a href="https://dev.mysql.com/doc/refman/5.7/en/myisamchk.html" target="_blank" rel="noopener"><strong>myisamchk</strong></a>变量对应于服务器系统变量：</p>
<table>
<thead>
<tr>
<th><a href="https://dev.mysql.com/doc/refman/5.7/en/myisamchk.html" target="_blank" rel="noopener"><strong>myisamchk</strong></a>变量</th>
<th>系统变量</th>
</tr>
</thead>
<tbody><tr>
<td><code>key_buffer_size</code></td>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_key_buffer_size" target="_blank" rel="noopener"><code>key_buffer_size</code></a></td>
</tr>
<tr>
<td><code>myisam_sort_buffer_size</code></td>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_myisam_sort_buffer_size" target="_blank" rel="noopener"><code>myisam_sort_buffer_size</code></a></td>
</tr>
<tr>
<td><code>read_buffer_size</code></td>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_read_buffer_size" target="_blank" rel="noopener"><code>read_buffer_size</code></a></td>
</tr>
<tr>
<td><code>write_buffer_size</code></td>
<td>没有</td>
</tr>
</tbody></table>
<p>每个服务器系统变量都可以在运行时进行设置，其中一些（<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_myisam_sort_buffer_size" target="_blank" rel="noopener"><code>myisam_sort_buffer_size</code></a>，<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_read_buffer_size" target="_blank" rel="noopener"><code>read_buffer_size</code></a>）除了全局值外， 还具有会话值。设置会话值将限制更改对当前会话的影响，并且不会影响其他用户。更改全局唯一的变量（<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_key_buffer_size" target="_blank" rel="noopener"><code>key_buffer_size</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_myisam_max_sort_file_size" target="_blank" rel="noopener"><code>myisam_max_sort_file_size</code></a>）会影响其他用户也是如此。对于 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_key_buffer_size" target="_blank" rel="noopener"><code>key_buffer_size</code></a>，您必须考虑与这些用户共享缓冲区。例如，如果将<a href="https://dev.mysql.com/doc/refman/5.7/en/myisamchk.html" target="_blank" rel="noopener"><strong>myisamchk</strong></a> <code>key_buffer_size</code>变量设置为128MB，则可以设置相应的 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_key_buffer_size" target="_blank" rel="noopener"><code>key_buffer_size</code></a>大于此值的系统变量（如果尚未将其设置得更大），以允许其他会话中的活动使用键缓冲区。但是，更改全局密钥缓冲区的大小会使缓冲区无效，从而导致磁盘I / O增加和其他会话速度降低。避免此问题的另一种方法是使用单独的键高速缓存，将要修复的表中的索引分配给它，并在修复完成后将其释放。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/multiple-key-caches.html" target="_blank" rel="noopener">第8.10.2.2节“多键缓存”</a>。</p>
<p>根据以上说明，<a href="https://dev.mysql.com/doc/refman/5.7/en/repair-table.html" target="_blank" rel="noopener"><code>REPAIR TABLE</code></a>可以使用类似于<a href="https://dev.mysql.com/doc/refman/5.7/en/myisamchk.html" target="_blank" rel="noopener"><strong>myisamchk</strong></a>命令的设置进行以下操作。这里分配了一个单独的128MB密钥缓冲区，并且假定文件系统允许文件大小至少为100GB。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">SESSION</span> myisam_sort_buffer_size = <span class="number">256</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">SESSION</span> read_buffer_size = <span class="number">64</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> myisam_max_sort_file_size = <span class="number">100</span>*<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> repair_cache.key_buffer_size = <span class="number">128</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">CACHE</span> <span class="keyword">INDEX</span> tbl_name <span class="keyword">IN</span> repair_cache;</span><br><span class="line"><span class="keyword">LOAD</span> <span class="keyword">INDEX</span> <span class="keyword">INTO</span> <span class="keyword">CACHE</span> tbl_name;</span><br><span class="line"><span class="keyword">REPAIR</span> <span class="keyword">TABLE</span> tbl_name ;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> repair_cache.key_buffer_size = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>如果您打算更改全局变量，但只希望在操作过程中进行更改，<a href="https://dev.mysql.com/doc/refman/5.7/en/repair-table.html" target="_blank" rel="noopener"><code>REPAIR TABLE</code></a>以最小程度地影响其他用户，则将其值保存在用户变量中，然后再进行恢复。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> @old_myisam_sort_buffer_size = @@GLOBAL.myisam_max_sort_file_size;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> myisam_max_sort_file_size = <span class="number">100</span>*<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">REPAIR</span> <span class="keyword">TABLE</span> tbl_name ;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> myisam_max_sort_file_size = @old_myisam_max_sort_file_size;</span><br></pre></td></tr></table></figure>

<p><a href="https://dev.mysql.com/doc/refman/5.7/en/repair-table.html" target="_blank" rel="noopener"><code>REPAIR TABLE</code></a>如果希望这些值在默认情况下有效，则可以在服务器启动时全局设置 影响的系统变量。例如，将这些行添加到服务器<code>my.cnf</code>文件中：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">myisam_sort_buffer_size</span>=<span class="number">256</span>M</span><br><span class="line"><span class="attr">key_buffer_size</span>=<span class="number">1</span>G</span><br><span class="line"><span class="attr">myisam_max_sort_file_size</span>=<span class="number">100</span>G</span><br></pre></td></tr></table></figure>

<p>这些设置不包括 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_read_buffer_size" target="_blank" rel="noopener"><code>read_buffer_size</code></a>。<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_read_buffer_size" target="_blank" rel="noopener"><code>read_buffer_size</code></a>全局设置 为所有会话都使用较大的值，并且由于为具有多个同时会话的服务器分配过多的内存，可能会导致性能下降。</p>
<h2 id="8-7优化内存表"><a href="#8-7优化内存表" class="headerlink" title="8.7优化内存表"></a>8.7优化内存表</h2><p>考虑将<code>MEMORY</code>表用于经常访问，只读或很少更新的非关键数据。在实际工作负载下，将应用程序与等效表<code>InnoDB</code>或基准进行基准测试 <code>MyISAM</code>，以确认任何额外的性能值得承担丢失数据的风险，或者值得在应用程序启动时从基于磁盘的表复制数据的开销。</p>
<p>为了使<code>MEMORY</code>表获得最佳性能，请检查针对每个表的查询类型，并指定用于每个关联索引（B树索引或哈希索引）的类型。在<a href="https://dev.mysql.com/doc/refman/5.7/en/create-index.html" target="_blank" rel="noopener"><code>CREATE INDEX</code></a> 语句上，使用<code>USING BTREE</code>或 子句<code>USING HASH</code>。对于通过诸如<code>&gt;</code>或的运算符进行大于或小于比较的查询，B树索引的速度很快<code>BETWEEN</code>。哈希索引仅适用于通过<code>=</code>运算符查找单个值或通过运算符查找一组受限值的查询<code>IN</code>。有关为什么 <code>USING BTREE</code>通常比默认选项更好的选择<code>USING HASH</code>，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/table-scan-avoidance.html" target="_blank" rel="noopener">第8.2.1.20节“避免全表扫描”</a>。有关不同类型<code>MEMORY</code>索引的实现细节，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/index-btree-hash.html" target="_blank" rel="noopener">第8.3.8节“ B树和哈希索引的比较”</a>。</p>
<h2 id="8-8了解查询执行计划"><a href="#8-8了解查询执行计划" class="headerlink" title="8.8了解查询执行计划"></a>8.8了解查询执行计划</h2><ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/using-explain.html" target="_blank" rel="noopener">8.8.1使用EXPLAIN优化查询</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html" target="_blank" rel="noopener">8.8.2说明输出格式</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-extended.html" target="_blank" rel="noopener">8.8.3扩展的EXPLAIN输出格式</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-for-connection.html" target="_blank" rel="noopener">8.8.4获取命名连接的执行计划信息</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/estimating-performance.html" target="_blank" rel="noopener">8.8.5估计查询性能</a></li>
</ul>
<p>根据表，列，索引的详细信息以及<code>WHERE</code>子句中的条件，MySQL优化器考虑了许多技术来有效执行SQL查询中涉及的查找。无需读取所有行即可执行对巨大表的查询；可以在不比较行的每个组合的情况下执行涉及多个表的联接。优化器选择执行最有效查询的一组操作称为“ 查询执行计划 ”，也称为 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>计划。您的目标是认识到 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a> 表示查询优化的计划，如果发现一些低效的操作，请学习SQL语法和索引技术以改进计划。</p>
<h3 id="8-8-1使用EXPLAIN优化查询"><a href="#8-8-1使用EXPLAIN优化查询" class="headerlink" title="8.8.1使用EXPLAIN优化查询"></a>8.8.1使用EXPLAIN优化查询</h3><ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>作品有 <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/delete.html" target="_blank" rel="noopener"><code>DELETE</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/replace.html" target="_blank" rel="noopener"><code>REPLACE</code></a>，和 <a href="https://dev.mysql.com/doc/refman/5.7/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a>语句。</li>
<li>当<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>与可解释的语句一起使用时，MySQL将显示来自优化器的有关语句执行计划的信息。也就是说，MySQL解释了它将如何处理该语句，包括有关如何连接表以及以何种顺序连接表的信息。有关 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>用于获取执行计划信息的信息，请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html" target="_blank" rel="noopener">第8.8.2节“ EXPLAIN输出格式”</a>。</li>
<li>当<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>与 而不是可解释的语句一起使用时，它将显示在命名连接中执行的语句的执行计划。请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-for-connection.html" target="_blank" rel="noopener">第8.8.4节“获取命名连接的执行计划信息”</a>。 <code>FOR CONNECTION *connection_id*</code></li>
<li>对于<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>语句， <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>生成可使用来显示的其他执行计划信息 <a href="https://dev.mysql.com/doc/refman/5.7/en/show-warnings.html" target="_blank" rel="noopener"><code>SHOW WARNINGS</code></a>。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-extended.html" target="_blank" rel="noopener">第8.8.3节“扩展的EXPLAIN输出格式”</a>。</li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>对于检查涉及分区表的查询很有用。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/partitioning-info.html" target="_blank" rel="noopener">第22.3.5节“获取有关分区的信息”</a>。</li>
<li>该<code>FORMAT</code>选项可用于选择输出格式。<code>TRADITIONAL</code>以表格格式显示输出。如果不<code>FORMAT</code>存在任何选项，则为默认设置 。 <code>JSON</code>format以JSON格式显示信息。</li>
</ul>
<p>在的帮助下<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>，您可以看到应该在表中添加索引的位置，以便通过使用索引查找行来使语句更快地执行。您还可以 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>用来检查优化器是否以最佳顺序联接表。要提示优化器使用连接顺序，该连接顺序与<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>语句中表的命名顺序相对应，请以 <code>SELECT STRAIGHT_JOIN</code>而不是just 开头<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>。（请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener">第13.2.9节“ SELECT语句”</a>。）但是，<code>STRAIGHT_JOIN</code>由于它禁用了半联接转换，因此 可能会阻止使用索引。看到 <a href="https://dev.mysql.com/doc/refman/5.7/en/semijoins.html" target="_blank" rel="noopener">第8.2.2.1节“使用半联接转换优化子查询，派生表和视图引用”</a>。</p>
<p>优化程序跟踪有时可能提供与补充的信息<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>。但是，优化程序的跟踪格式和内容在版本之间可能会发生变化。有关详细信息，请参见 <a href="https://dev.mysql.com/doc/internals/en/optimizer-tracing.html" target="_blank" rel="noopener">MySQL内部：跟踪优化器</a>。</p>
<p>如果您在认为应该使用索引时遇到问题，请运行<a href="https://dev.mysql.com/doc/refman/5.7/en/analyze-table.html" target="_blank" rel="noopener"><code>ANALYZE TABLE</code></a>以更新表统计信息，例如键的基数，这可能会影响优化器的选择。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/analyze-table.html" target="_blank" rel="noopener">第13.7.2.1节“ ANALYZE TABLE语句”</a>。</p>
<p>注意</p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>也可以用于获取有关表中列的信息。 是和的 同义词。有关更多信息，请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/describe.html" target="_blank" rel="noopener">第13.8.1节“ DESCRIBE语句”</a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/show-columns.html" target="_blank" rel="noopener">第13.7.5.5节“ SHOW COLUMNS语句”</a>。 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN *tbl_name*</code></a><code>DESCRIBE *tbl_name*``SHOW COLUMNS FROM *tbl_name*</code></p>
<h3 id="8-8-2说明输出格式"><a href="#8-8-2说明输出格式" class="headerlink" title="8.8.2说明输出格式"></a>8.8.2说明输出格式</h3><p>该<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>语句提供有关MySQL如何执行语句的信息。 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>作品有 <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/delete.html" target="_blank" rel="noopener"><code>DELETE</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/replace.html" target="_blank" rel="noopener"><code>REPLACE</code></a>，和 <a href="https://dev.mysql.com/doc/refman/5.7/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a>语句。</p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>为<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>语句中使用的每个表返回一行信息 。它按照MySQL在处理语句时读取它们的顺序列出了输出中的表。MySQL使用嵌套循环连接方法解析所有连接。这意味着MySQL从第一个表中读取一行，然后在第二个表，第三个表中找到匹配的行，依此类推。处理完所有表后，MySQL将通过表列表输出选定的列和回溯，直到找到一个表，其中存在更多匹配的行。从该表中读取下一行，然后继续下一个表。</p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>输出包括分区信息。此外，对于<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a> 语句，<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>产生可与被显示扩展信息 <a href="https://dev.mysql.com/doc/refman/5.7/en/show-warnings.html" target="_blank" rel="noopener"><code>SHOW WARNINGS</code></a>之后的 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>（见 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-extended.html" target="_blank" rel="noopener">第8.8.3，“扩展EXPLAIN输出格式”</a>）。</p>
<p>注意</p>
<p>在较早的MySQL版本中，分区和扩展信息是使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN PARTITIONS</code></a>和生成的 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN EXTENDED</code></a>。仍然可以识别这些语法的向后兼容性，但是默认情况下现在启用了分区和扩展输出，因此<code>PARTITIONS</code> 和<code>EXTENDED</code>关键字已不再使用。使用它们会导致警告，并且<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>在将来的MySQL版本中会将其从语法中删除。</p>
<p>你不能使用已弃用<code>PARTITIONS</code> ，并<code>EXTENDED</code>在相同的关键字共同 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>声明。此外，这些关键字都不能与该<code>FORMAT</code>选项一起使用 。</p>
<p>注意</p>
<p>MySQL Workbench具有视觉解释功能，可提供<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>输出的视觉表示 。请参见 <a href="https://dev.mysql.com/doc/workbench/en/wb-tutorial-visual-explain-dbt3.html" target="_blank" rel="noopener">教程：使用解释来提高查询性能</a>。</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain-output-columns" target="_blank" rel="noopener">解释输出列</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain-join-types" target="_blank" rel="noopener">说明联接类型</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain-extra-information" target="_blank" rel="noopener">了解更多信息</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain-output-interpretation" target="_blank" rel="noopener">解释输出解释</a></li>
</ul>
<h4 id="解释输出列"><a href="#解释输出列" class="headerlink" title="解释输出列"></a>解释输出列</h4><p>本节介绍产生的输出列 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>。后面的部分提供有关<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain-join-types" target="_blank" rel="noopener"><code>type</code></a> 和 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain-extra-information" target="_blank" rel="noopener"><code>Extra</code></a> 列的其他信息 。</p>
<p>的每个输出行<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a> 提供有关一个表的信息。每行包含<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain-output-column-table" target="_blank" rel="noopener">表8.1“ EXPLAIN输出列”中</a>概述的值 ，并在表后更详细地描述。列名显示在表的第一列中；第二列提供<code>FORMAT=JSON</code>使用时输出中显示的等效属性名称 。</p>
<p><strong>表8.1 EXPLAIN输出列</strong></p>
<table>
<thead>
<tr>
<th>柱</th>
<th>JSON名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_id" target="_blank" rel="noopener"><code>id</code></a></td>
<td><code>select_id</code></td>
<td>该<code>SELECT</code>标识符</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_select_type" target="_blank" rel="noopener"><code>select_type</code></a></td>
<td>没有</td>
<td>该<code>SELECT</code>类型</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_table" target="_blank" rel="noopener"><code>table</code></a></td>
<td><code>table_name</code></td>
<td>输出行表</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_partitions" target="_blank" rel="noopener"><code>partitions</code></a></td>
<td><code>partitions</code></td>
<td>匹配的分区</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_type" target="_blank" rel="noopener"><code>type</code></a></td>
<td><code>access_type</code></td>
<td>联接类型</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_possible_keys" target="_blank" rel="noopener"><code>possible_keys</code></a></td>
<td><code>possible_keys</code></td>
<td>可能的索引选择</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_key" target="_blank" rel="noopener"><code>key</code></a></td>
<td><code>key</code></td>
<td>实际选择的索引</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_key_len" target="_blank" rel="noopener"><code>key_len</code></a></td>
<td><code>key_length</code></td>
<td>所选键的长度</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_ref" target="_blank" rel="noopener"><code>ref</code></a></td>
<td><code>ref</code></td>
<td>与索引比较的列</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_rows" target="_blank" rel="noopener"><code>rows</code></a></td>
<td><code>rows</code></td>
<td>估计要检查的行</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_filtered" target="_blank" rel="noopener"><code>filtered</code></a></td>
<td><code>filtered</code></td>
<td>按表条件过滤的行百分比</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_extra" target="_blank" rel="noopener"><code>Extra</code></a></td>
<td>没有</td>
<td>附加信息</td>
</tr>
</tbody></table>
<p>注意</p>
<p>JSON属性<code>NULL</code>不会显示在JSON格式的<code>EXPLAIN</code> 输出中。</p>
<ul>
<li><p><code>id</code>（JSON名： <code>select_id</code>）</p>
<p>的<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>标识符。这是<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>查询中的序号 。<code>NULL</code>如果该行引用其他行的并集结果，则该值为。在这种情况下，该 <code>table</code>列显示的值类似于 表明该行引用的行的并 集是和的值 。 <code>&lt;union*M*,*N*&gt;``id</code><em>M**N</em></p>
</li>
<li><p><code>select_type</code> （JSON名称：无）</p>
<p>的类型<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>，可以是下表中显示的任何类型。JSON格式<code>EXPLAIN</code>将<code>SELECT</code>类型公开 为a的属性 <code>query_block</code>，除非它为 <code>SIMPLE</code>或<code>PRIMARY</code>。表格中还会显示JSON名称（如果适用）。</p>
<table>
<thead>
<tr>
<th><code>select_type</code> 值</th>
<th>JSON名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>SIMPLE</code></td>
<td>没有</td>
<td>简单<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>（不使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/union.html" target="_blank" rel="noopener"><code>UNION</code></a>或子查询）</td>
</tr>
<tr>
<td><code>PRIMARY</code></td>
<td>没有</td>
<td>最外层 <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a></td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/union.html" target="_blank" rel="noopener"><code>UNION</code></a></td>
<td>没有</td>
<td>第二个或之后的<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>陈述 <a href="https://dev.mysql.com/doc/refman/5.7/en/union.html" target="_blank" rel="noopener"><code>UNION</code></a></td>
</tr>
<tr>
<td><code>DEPENDENT UNION</code></td>
<td><code>dependent</code>（<code>true</code>）</td>
<td>中的第二个或更高版本的<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>语句 <a href="https://dev.mysql.com/doc/refman/5.7/en/union.html" target="_blank" rel="noopener"><code>UNION</code></a>，取决于外部查询</td>
</tr>
<tr>
<td><code>UNION RESULT</code></td>
<td><code>union_result</code></td>
<td>的结果<a href="https://dev.mysql.com/doc/refman/5.7/en/union.html" target="_blank" rel="noopener"><code>UNION</code></a>。</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-subquery" target="_blank" rel="noopener"><code>SUBQUERY</code></a></td>
<td>没有</td>
<td>首先<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>在子查询</td>
</tr>
<tr>
<td><code>DEPENDENT SUBQUERY</code></td>
<td><code>dependent</code>（<code>true</code>）</td>
<td>首先<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>在子查询中，取决于外部查询</td>
</tr>
<tr>
<td><code>DERIVED</code></td>
<td>没有</td>
<td>派生表</td>
</tr>
<tr>
<td><code>MATERIALIZED</code></td>
<td><code>materialized_from_subquery</code></td>
<td>物化子查询</td>
</tr>
<tr>
<td><code>UNCACHEABLE SUBQUERY</code></td>
<td><code>cacheable</code>（<code>false</code>）</td>
<td>子查询，其结果无法缓存，必须针对外部查询的每一行重新进行评估</td>
</tr>
<tr>
<td><code>UNCACHEABLE UNION</code></td>
<td><code>cacheable</code>（<code>false</code>）</td>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/union.html" target="_blank" rel="noopener"><code>UNION</code></a> 属于不可缓存子查询的中的第二个或更高版本的选择（请参阅参考资料 <code>UNCACHEABLE SUBQUERY</code>）</td>
</tr>
</tbody></table>
</li>
</ul>
<p>  <code>DEPENDENT</code>通常表示使用相关子查询。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/correlated-subqueries.html" target="_blank" rel="noopener">第13.2.10.7节“相关子查询”</a>。</p>
<p>  <code>DEPENDENT SUBQUERY</code>评估不同于<code>UNCACHEABLE SUBQUERY</code>评估。对于<code>DEPENDENT SUBQUERY</code>，子查询对于来自其外部上下文的变量的每个不同值集仅重新评估一次。对于 <code>UNCACHEABLE SUBQUERY</code>，将为外部上下文的每一行重新评估子查询。</p>
<p>  子查询的可缓存性与查询结果在查询缓存中的缓存不同（<a href="https://dev.mysql.com/doc/refman/5.7/en/query-cache-operation.html" target="_blank" rel="noopener">第8.10.3.1节“查询缓存的操作方式”中</a>对此进行了描述 ）。子查询缓存在查询执行期间发生，而查询缓存仅在查询执行完成后才用于存储结果。</p>
<p>  当您指定<code>FORMAT=JSON</code>with时 <code>EXPLAIN</code>，输出没有直接等同于<code>select_type</code>;的单个属性 。该 <code>query_block</code>属性对应于给定<code>SELECT</code>。与<code>SELECT</code>刚刚显示的大多数子查询类型等效的属性可用（一个示例 <code>materialized_from_subquery</code>针对 <code>MATERIALIZED</code>），并在适当时显示。没有<code>SIMPLE</code>或的JSON等效项 <code>PRIMARY</code>。</p>
<p>  <code>select_type</code>非<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>语句 的值显示受影响表的语句类型。例如，<code>select_type</code>是 <code>DELETE</code>对 <a href="https://dev.mysql.com/doc/refman/5.7/en/delete.html" target="_blank" rel="noopener"><code>DELETE</code></a>报表。</p>
<ul>
<li><p><code>table</code>（JSON名： <code>table_name</code>）</p>
<p>输出行所引用的表的名称。这也可以是以下值之一：</p>
<ul>
<li><code>&lt;union*M*,*N*&gt;</code>：该行指的是具有和<code>id</code>值的行 的 <em>M</em>并集 <em>N</em>。</li>
<li><code>&lt;derived*N*&gt;</code>：该行是指用于与该行的派生表结果<code>id</code>的值 <em>N</em>。派生表可能来自（例如）<code>FROM</code>子句中的子查询 。</li>
<li><code>&lt;subquery*N*&gt;</code>：该行是指该行的物化子查询的结果，其<code>id</code> 值为<em>N</em>。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/subquery-materialization.html" target="_blank" rel="noopener">第8.2.2.2节“通过实现来优化子查询”</a>。</li>
</ul>
</li>
<li><p><code>partitions</code>（JSON名： <code>partitions</code>）</p>
<p>查询将从中匹配记录的分区。该值适用<code>NULL</code>于未分区的表。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/partitioning-info.html" target="_blank" rel="noopener">第22.3.5节“获取有关分区的信息”</a>。</p>
</li>
<li><p><code>type</code>（JSON名： <code>access_type</code>）</p>
<p>联接类型。有关不同类型的描述，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain-join-types" target="_blank" rel="noopener"><code>EXPLAIN</code> 连接类型</a>。</p>
</li>
<li><p><code>possible_keys</code>（JSON名： <code>possible_keys</code>）</p>
<p>该<code>possible_keys</code>列指示MySQL可以选择从中查找表中各行的索引。请注意，此列完全独立于表的顺序，如的输出所示 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>。这意味着<code>possible_keys</code>在实践中，某些键可能无法与生成的表顺序一起使用。</p>
<p>如果此列是<code>NULL</code>（或在JSON格式的输出中未定义），则没有相关的索引。在这种情况下，您可以通过检查该<code>WHERE</code> 子句以检查它是否引用了某些适合索引的列，从而提高查询性能。如果是这样，请创建一个适当的索引并<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>再次检查查询 。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/alter-table.html" target="_blank" rel="noopener">第13.1.8节“ ALTER TABLE语句”</a>。</p>
<p>要查看表具有哪些索引，请使用。 <code>SHOW INDEX FROM *tbl_name*</code></p>
</li>
<li><p><code>key</code>（JSON名：<code>key</code>）</p>
<p>该<code>key</code>列指示MySQL实际决定使用的键（索引）。如果MySQL决定使用<code>possible_keys</code> 索引之一来查找行，则将该索引列为键值。</p>
<p>可能<code>key</code>会命名该值中不存在的索引 <code>possible_keys</code>。如果没有一个<code>possible_keys</code>索引适合查找行，但是查询选择的所有列都是某个其他索引的列，则可能发生这种情况。也就是说，命名索引覆盖了选定的列，因此尽管不使用索引来确定要检索的行，但是索引扫描比数据行扫描更有效。</p>
<p>对于<code>InnoDB</code>，即使查询也选择了主键，辅助索引也可能覆盖选定的列，因为<code>InnoDB</code>主键值与每个辅助索引一起存储。如果 <code>key</code>为<code>NULL</code>，则MySQL没有找到可用于更有效地执行查询的索引。</p>
<p>要强制MySQL使用或忽略列出的索引 <code>possible_keys</code>列，使用 <code>FORCE INDEX</code>，<code>USE INDEX</code>或<code>IGNORE INDEX</code>在您的查询。请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/index-hints.html" target="_blank" rel="noopener">第8.9.4节“索引提示”</a>。</p>
<p>对于<code>MyISAM</code>表，运行 <a href="https://dev.mysql.com/doc/refman/5.7/en/analyze-table.html" target="_blank" rel="noopener"><code>ANALYZE TABLE</code></a>有助于优化器选择更好的索引。对于 <code>MyISAM</code>表，<a href="https://dev.mysql.com/doc/refman/5.7/en/myisamchk.html" target="_blank" rel="noopener"><strong>myisamchk –analyze也是</strong></a>如此。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/analyze-table.html" target="_blank" rel="noopener">第13.7.2.1节“ ANALYZE TABLE语句”</a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/myisam-table-maintenance.html" target="_blank" rel="noopener">第7.6节“ MyISAM表维护和崩溃恢复”</a>。</p>
</li>
<li><p><code>key_len</code>（JSON名： <code>key_length</code>）</p>
<p>该<code>key_len</code>列指示MySQL决定使用的密钥的长度。的值 <code>key_len</code>使您能够确定MySQL实际使用的多部分键的多少部分。如果该<code>key</code>列显示 <code>NULL</code>，则该<code>key_len</code> 列也显示<code>NULL</code>。</p>
<p>由于密钥存储格式的原因，一列可以使用的密钥长度<code>NULL</code> 比一<code>NOT NULL</code>列大。</p>
</li>
<li><p><code>ref</code>（JSON名：<code>ref</code>）</p>
<p>该<code>ref</code>列显示将哪些列或常量与该<code>key</code>列中命名的索引进行比较，以 从表中选择行。</p>
<p>如果值为<code>func</code>，则使用的值是某些函数的结果。要查看哪个功能，请使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/show-warnings.html" target="_blank" rel="noopener"><code>SHOW WARNINGS</code></a>以下 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>命令查看扩展 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>输出。该函数实际上可能是算术运算符之类的运算符。</p>
</li>
<li><p><code>rows</code>（JSON名： <code>rows</code>）</p>
<p>该<code>rows</code>列指示MySQL认为执行查询必须检查的行数。</p>
<p>对于<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html" target="_blank" rel="noopener"><code>InnoDB</code></a>表，此数字是估计值，可能并不总是准确的。</p>
</li>
<li><p><code>filtered</code>（JSON名： <code>filtered</code>）</p>
<p>该<code>filtered</code>列指示将被表条件过滤的表行的估计百分比。最大值为100，这表示未过滤行。值从100减小表示过滤量增加。 <code>rows</code>显示检查的估计行数，<code>rows</code>× <code>filtered</code>显示将与下表连接的行数。例如，如果 <code>rows</code>为1000且 <code>filtered</code>为50.00（50％），则与下表连接的行数为1000×50％= 500。</p>
</li>
<li><p><code>Extra</code> （JSON名称：无）</p>
<p>此列包含有关MySQL如何解析查询的其他信息。有关不同值的说明，请参见“ <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain-extra-information" target="_blank" rel="noopener"><code>EXPLAIN</code> 其他信息”</a>。</p>
<p>该<code>Extra</code>列没有对应的JSON属性 ；但是，此列中可能出现的值显示为JSON属性或该<code>message</code>属性的文本。</p>
</li>
</ul>
<h4 id="说明联接类型"><a href="#说明联接类型" class="headerlink" title="说明联接类型"></a>说明联接类型</h4><p>该<code>type</code>列 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>输出介绍如何联接表。在JSON格式的输出中，这些作为<code>access_type</code>属性的值找到。以下列表描述了连接类型，从最佳类型到最差类型：</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_system" target="_blank" rel="noopener"><code>system</code></a></li>
</ul>
<p>  该表只有一行（=系统表）。这是<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_const" target="_blank" rel="noopener"><code>const</code></a>联接类型的特例 。</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_const" target="_blank" rel="noopener"><code>const</code></a></li>
</ul>
<p>  该表最多具有一个匹配行，该行在查询开始时读取。因为只有一行，所以优化器的其余部分可以将这一行中列的值视为常量。 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_const" target="_blank" rel="noopener"><code>const</code></a>表非常快，因为它们只能读取一次。</p>
<p>  <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_const" target="_blank" rel="noopener"><code>const</code></a>在将a <code>PRIMARY KEY</code>或 <code>UNIQUE</code>index的所有部分与常数值进行比较时使用。在以下查询中，<em>tbl_name</em>可以用作<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_const" target="_blank" rel="noopener"><code>const</code></a> 表：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> primary_key=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> primary_key_part1=<span class="number">1</span> <span class="keyword">AND</span> primary_key_part2=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_eq_ref" target="_blank" rel="noopener"><code>eq_ref</code></a></li>
</ul>
<p>  对于先前表中的每行组合，从此表中读取一行。除了 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_system" target="_blank" rel="noopener"><code>system</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_const" target="_blank" rel="noopener"><code>const</code></a>类型，这是最好的联接类型。当连接使用索引的所有部分并且索引为a <code>PRIMARY KEY</code>或<code>UNIQUE NOT NULL</code>index时使用。</p>
<p>  <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_eq_ref" target="_blank" rel="noopener"><code>eq_ref</code></a>可用于使用<code>=</code>运算符进行比较的索引列 。比较值可以是常量，也可以是使用在此表之前读取的表中列的表达式。在以下示例中，MySQL可以使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_eq_ref" target="_blank" rel="noopener"><code>eq_ref</code></a>联接进行处理 <em>ref_table</em>：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table,other_table</span><br><span class="line">  <span class="keyword">WHERE</span> ref_table.key_column=other_table.column;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table,other_table</span><br><span class="line">  <span class="keyword">WHERE</span> ref_table.key_column_part1=other_table.column</span><br><span class="line">  <span class="keyword">AND</span> ref_table.key_column_part2=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_ref" target="_blank" rel="noopener"><code>ref</code></a></li>
</ul>
<p>  对于先前表中的每个行组合，将从该表中读取具有匹配索引值的所有行。<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_ref" target="_blank" rel="noopener"><code>ref</code></a>如果联接仅使用键的最左前缀，或者如果键不是a <code>PRIMARY KEY</code>或 <code>UNIQUE</code>索引（换句话说，如果联接无法根据键值选择单个行），则使用。如果使用的键仅匹配几行，则这是一种很好的联接类型。</p>
<p>  <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_ref" target="_blank" rel="noopener"><code>ref</code></a>可以用于使用<code>=</code>或<code>&lt;=&gt;</code> 运算符进行比较的索引列 。在以下示例中，MySQL可以使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_ref" target="_blank" rel="noopener"><code>ref</code></a>联接进行处理 <em>ref_table</em>：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table <span class="keyword">WHERE</span> key_column=expr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table,other_table</span><br><span class="line">  <span class="keyword">WHERE</span> ref_table.key_column=other_table.column;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table,other_table</span><br><span class="line">  <span class="keyword">WHERE</span> ref_table.key_column_part1=other_table.column</span><br><span class="line">  <span class="keyword">AND</span> ref_table.key_column_part2=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_fulltext" target="_blank" rel="noopener"><code>fulltext</code></a></li>
</ul>
<p>  使用<code>FULLTEXT</code> 索引执行联接。</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_ref_or_null" target="_blank" rel="noopener"><code>ref_or_null</code></a></li>
</ul>
<p>  这种连接类型类似于 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_ref" target="_blank" rel="noopener"><code>ref</code></a>，但是除了MySQL会额外搜索包含<code>NULL</code>值的行。此联接类型优化最常用于解析子查询。在以下示例中，MySQL可以使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_ref_or_null" target="_blank" rel="noopener"><code>ref_or_null</code></a>联接进行处理<em>ref_table</em>：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table</span><br><span class="line">  <span class="keyword">WHERE</span> key_column=expr <span class="keyword">OR</span> key_column <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>  请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/is-null-optimization.html" target="_blank" rel="noopener">第8.2.1.13节“ IS NULL优化”</a>。</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_index_merge" target="_blank" rel="noopener"><code>index_merge</code></a></li>
</ul>
<p>  此联接类型指示使用索引合并优化。在这种情况下，<code>key</code>输出行中的列包含使用的索引列表，并<code>key_len</code>包含使用的索引 的最长键部分的列表。有关更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/index-merge-optimization.html" target="_blank" rel="noopener">第8.2.1.3节“索引合并优化”</a>。</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_unique_subquery" target="_blank" rel="noopener"><code>unique_subquery</code></a></li>
</ul>
<p>  此类型替换 以下形式的<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_eq_ref" target="_blank" rel="noopener"><code>eq_ref</code></a>某些 <code>IN</code>子查询：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value IN (<span class="keyword">SELECT</span> primary_key <span class="keyword">FROM</span> single_table <span class="keyword">WHERE</span> some_expr)</span><br></pre></td></tr></table></figure>

<p>  <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_unique_subquery" target="_blank" rel="noopener"><code>unique_subquery</code></a> 只是一个索引查找函数，它完全替代了子查询以提高效率。</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_index_subquery" target="_blank" rel="noopener"><code>index_subquery</code></a></li>
</ul>
<p>  此连接类型类似于 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_unique_subquery" target="_blank" rel="noopener"><code>unique_subquery</code></a>。它替换<code>IN</code>子查询，但适用于以下形式的子查询中的非唯一索引：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value IN (<span class="keyword">SELECT</span> key_column <span class="keyword">FROM</span> single_table <span class="keyword">WHERE</span> some_expr)</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_range" target="_blank" rel="noopener"><code>range</code></a></li>
</ul>
<p>  使用索引选择行，仅检索给定范围内的行。的<code>key</code> 输出行中的列指示使用哪个索引。将<code>key_len</code>包含已使用的时间最长的关键部分。该<code>ref</code>列 <code>NULL</code>适用于此类型。</p>
<p>  <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_range" target="_blank" rel="noopener"><code>range</code></a>当一个键列使用任何的相比于恒定可使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_equal" target="_blank" rel="noopener"><code>=</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_not-equal" target="_blank" rel="noopener"><code>&lt;&gt;</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_greater-than" target="_blank" rel="noopener"><code>&gt;</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_greater-than-or-equal" target="_blank" rel="noopener"><code>&gt;=</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_less-than" target="_blank" rel="noopener"><code>&lt;</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_less-than-or-equal" target="_blank" rel="noopener"><code>&lt;=</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_is-null" target="_blank" rel="noopener"><code>IS NULL</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_equal-to" target="_blank" rel="noopener"><code>&lt;=&gt;</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_between" target="_blank" rel="noopener"><code>BETWEEN</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/string-comparison-functions.html#operator_like" target="_blank" rel="noopener"><code>LIKE</code></a>，或 <a href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_in" target="_blank" rel="noopener"><code>IN()</code></a>运营商：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> key_column = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> key_column <span class="keyword">BETWEEN</span> <span class="number">10</span> <span class="keyword">and</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> key_column <span class="keyword">IN</span> (<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> key_part1 = <span class="number">10</span> <span class="keyword">AND</span> key_part2 <span class="keyword">IN</span> (<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_index" target="_blank" rel="noopener"><code>index</code></a></li>
</ul>
<p>  该<code>index</code>联接类型是一样的 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_all" target="_blank" rel="noopener"><code>ALL</code></a>，只是索引树被扫描。这发生两种方式：</p>
<ul>
<li><p>如果索引是查询的覆盖索引，并且可用于满足表中所需的所有数据，则仅扫描索引树。在这种情况下，<code>Extra</code>列为 <code>Using index</code>。仅索引扫描通常比索引扫描更快， <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_all" target="_blank" rel="noopener"><code>ALL</code></a>因为索引的大小通常小于表数据。</p>
</li>
<li><p>使用对索引的读取执行全表扫描，以按索引顺序查找数据行。 <code>Uses index</code>没有出现在 <code>Extra</code>列中。</p>
<p>当查询仅使用属于单个索引一部分的列时，MySQL可以使用此联接类型。</p>
</li>
</ul>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_all" target="_blank" rel="noopener"><code>ALL</code></a></li>
</ul>
<p>  对来自先前表的行的每个组合进行全表扫描。如果该表是未标记的第一个表 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_const" target="_blank" rel="noopener"><code>const</code></a>，则通常不好，在其他所有情况下通常 <em>非常</em>糟糕。通常，可以<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_all" target="_blank" rel="noopener"><code>ALL</code></a>通过添加索引来避免这种情况，这些 索引允许基于早期表中的常量值或列值从表中检索行。</p>
<h4 id="了解更多信息"><a href="#了解更多信息" class="headerlink" title="了解更多信息"></a>了解更多信息</h4><p>该<code>Extra</code>列 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>输出包含MySQL解决查询的额外信息。以下列表说明了可以在此列中显示的值。每个项目还针对JSON格式的输出指示哪个属性显示<code>Extra</code>值。对于其中一些，有一个特定的属性。其他显示为<code>message</code> 属性的文本。</p>
<p>如果你想使你的查询尽可能快，看出来<code>Extra</code>的列值<code>Using filesort</code>和<code>Using temporary</code>，或在JSON格式的<code>EXPLAIN</code>输出，用于 <code>using_filesort</code>和 <code>using_temporary_table</code>性能等于 <code>true</code>。</p>
<ul>
<li><p><code>Child of &#39;*table*&#39; pushed join@1</code>（JSON：<code>message</code> 文本）</p>
<p>该表是<em>table</em>可以向下推到NDB内核的联接中的子级引用 。启用下推联接时，仅适用于NDB群集。有关<a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-cluster-options-variables.html#sysvar_ndb_join_pushdown" target="_blank" rel="noopener"><code>ndb_join_pushdown</code></a>更多信息和示例，请参见服务器系统变量的描述 。</p>
</li>
<li><p><code>const row not found</code>（JSON属性： <code>const_row_not_found</code>）</p>
<p>对于诸如之类的查询，该表为空。 <code>SELECT ... FROM *tbl_name*</code></p>
</li>
<li><p><code>Deleting all rows</code>（JSON属性： <code>message</code>）</p>
<p>对于<a href="https://dev.mysql.com/doc/refman/5.7/en/delete.html" target="_blank" rel="noopener"><code>DELETE</code></a>，某些存储引擎（如<a href="https://dev.mysql.com/doc/refman/5.7/en/myisam-storage-engine.html" target="_blank" rel="noopener"><code>MyISAM</code></a>）支持一种处理程序方法，该方法以一种简单而快速的方式删除所有表行。<code>Extra</code>如果引擎使用此优化，则显示此值。</p>
</li>
<li><p><code>Distinct</code>（JSON属性： <code>distinct</code>）</p>
<p>MySQL正在寻找不同的值，因此在找到第一个匹配的行后，它将停止为当前行组合搜索更多行。</p>
</li>
<li><p><code>FirstMatch(*tbl_name*)</code> （JSON属性：<code>first_match</code>）</p>
<p>半连接FirstMatch连接快捷方式策略用于<em>tbl_name</em>。</p>
</li>
<li><p><code>Full scan on NULL key</code>（JSON属性： <code>message</code>）</p>
<p>当优化器无法使用索引查找访问方法时，这会作为子查询优化的后备策略而发生。</p>
</li>
<li><p><code>Impossible HAVING</code>（JSON属性： <code>message</code>）</p>
<p>该<code>HAVING</code>子句始终为false，无法选择任何行。</p>
</li>
<li><p><code>Impossible WHERE</code>（JSON属性： <code>message</code>）</p>
<p>该<code>WHERE</code>子句始终为false，无法选择任何行。</p>
</li>
<li><p><code>Impossible WHERE noticed after reading const tables</code>（JSON属性： <code>message</code>）</p>
<p>MySQL已经读取了所有 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_const" target="_blank" rel="noopener"><code>const</code></a>（和 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_system" target="_blank" rel="noopener"><code>system</code></a>）表，并注意到该<code>WHERE</code>子句始终为false。</p>
</li>
<li><p><code>LooseScan(*m*..*n*)</code> （JSON属性：<code>message</code>）</p>
<p>使用半连接的LooseScan策略。 <em>m</em>和 <em>n</em>是关键零件号。</p>
</li>
<li><p><code>No matching min/max row</code>（JSON属性： <code>message</code>）</p>
<p>没有行满足查询的条件，例如 。 <code>SELECT MIN(...) FROM ... WHERE *condition*</code></p>
</li>
<li><p><code>no matching row in const table</code>（JSON属性：<code>message</code>）</p>
<p>对于具有联接的查询，存在一个空表或一个表中没有满足唯一索引条件的行。</p>
</li>
<li><p><code>No matching rows after partition pruning</code>（JSON属性： <code>message</code>）</p>
<p>对于<a href="https://dev.mysql.com/doc/refman/5.7/en/delete.html" target="_blank" rel="noopener"><code>DELETE</code></a>或 <a href="https://dev.mysql.com/doc/refman/5.7/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a>，优化器在分区修剪后找不到要删除或更新的内容。它的含义类似于<code>Impossible WHERE</code> for <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>语句。</p>
</li>
<li><p><code>No tables used</code>（JSON属性： <code>message</code>）</p>
<p>查询没有<code>FROM</code>子句，或者有 <code>FROM DUAL</code>子句。</p>
<p>对于<a href="https://dev.mysql.com/doc/refman/5.7/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>或 <a href="https://dev.mysql.com/doc/refman/5.7/en/replace.html" target="_blank" rel="noopener"><code>REPLACE</code></a>语句， <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>在没有任何<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a> 部分时显示此值。例如，出现的<code>EXPLAIN INSERT INTO t VALUES(10)</code>原因是因为等同于 <code>EXPLAIN INSERT INTO t SELECT 10 FROM DUAL</code>。</p>
</li>
<li><p><code>Not exists</code>（JSON属性： <code>message</code>）</p>
<p>MySQL能够对<code>LEFT JOIN</code> 查询进行优化，并且在找到符合<code>LEFT JOIN</code>条件的一行后，不检查该表中的更多行是否为上一行。这是可以通过这种方式优化的查询类型的示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> t2 <span class="keyword">ON</span> t1.id=t2.id</span><br><span class="line">  <span class="keyword">WHERE</span> t2.id <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>假设<code>t2.id</code>定义为 <code>NOT NULL</code>。在这种情况下，MySQL 使用的值 扫描 <code>t1</code>并查找行 。如果MySQL在中找到匹配的行 ，它将知道它 永远不会是 ，并且不会扫描具有相同值的其余行。换句话说，对于in中的每一行，MySQL 实际上只需进行一次查找，无论in中实际匹配多少行。 <code>t2``t1.id``t2``t2.id``NULL``t2``id``t1``t2``t2</code></p>
</li>
<li><p><code>Plan isn&#39;t ready yet</code> （JSON属性：无）</p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-for-connection.html" target="_blank" rel="noopener"><code>EXPLAIN FOR CONNECTION</code></a>当优化器尚未完成为在命名连接中执行的语句创建执行计划时， 就会出现此值。如果执行计划输出包含多行，则<code>Extra</code>取决于优化程序确定完整执行计划的进度，其中任何一行或所有行都可以具有此 值。</p>
</li>
<li><p><code>Range checked for each record (index map: *N*)</code>（JSON属性： <code>message</code>）</p>
<p>MySQL找不到很好的索引来使用，但是发现一些索引可以在已知先前表中的列值之后使用。对于上表中的每个行组合，MySQL检查是否可以使用<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_range" target="_blank" rel="noopener"><code>range</code></a>或 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_index_merge" target="_blank" rel="noopener"><code>index_merge</code></a>访问方法来检索行。这不是很快，但是比完全没有索引的连接要快。适用标准如 <a href="https://dev.mysql.com/doc/refman/5.7/en/range-optimization.html" target="_blank" rel="noopener">第8.2.1.2节“范围优化”</a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/index-merge-optimization.html" target="_blank" rel="noopener">第8.2.1.3节“索引合并优化”中所述</a>，除了上表的所有列值都是已知的并且被视为常量。</p>
<p>索引从1开始编号，其顺序<a href="https://dev.mysql.com/doc/refman/5.7/en/show-index.html" target="_blank" rel="noopener"><code>SHOW INDEX</code></a>与表中显示的顺序相同。索引图值 <em>N</em>是指示哪些索引为候选的位掩码值。例如，值<code>0x19</code>（二进制11001）表示将考虑索引1、4和5。</p>
</li>
<li><p><code>Scanned *N* databases</code>（JSON属性： <code>message</code>）</p>
<p>这表示在处理<code>INFORMATION_SCHEMA</code>表查询时服务器执行了多少目录扫描 ，如<a href="https://dev.mysql.com/doc/refman/5.7/en/information-schema-optimization.html" target="_blank" rel="noopener">第8.2.3节“优化INFORMATION_SCHEMA查询”中所述</a>。的值<em>N</em>可以是0、1或 <code>all</code>。</p>
</li>
<li><p><code>Select tables optimized away</code>（JSON属性：<code>message</code>）</p>
<p>优化器确定1）最多应返回一行，以及2）要生成该行，必须读取确定的行集。当在优化阶段可以读取要读取的行时（例如，通过读取索引行），则在查询执行期间无需读取任何表。</p>
<p>当查询被隐式分组（包含聚合函数但没有<code>GROUP BY</code>子句）时，满足第一个条件 。当每个使用的索引执行一次行查找时，满足第二个条件。读取的索引数决定了要读取的行数。</p>
<p>考虑以下隐式分组查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MIN</span>(c1), <span class="keyword">MIN</span>(c2) <span class="keyword">FROM</span> t1;</span><br></pre></td></tr></table></figure>

<p>假设<code>MIN(c1)</code>可以通过读取一个索引行<code>MIN(c2)</code> 来检索，并且可以通过从另一索引中读取一行来进行检索。即，对于每一列<code>c1</code>和 <code>c2</code>，存在其中列是索引的第一列的索引。在这种情况下，将通过读取两个确定性行来返回一行。</p>
<p><code>Extra</code>如果要读取的行不确定，则不会出现 此值。考虑以下查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MIN</span>(c2) <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c1 &lt;= <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>假设这<code>(c1, c2)</code>是一个覆盖指数。使用此索引，<code>c1 &lt;= 10</code>必须扫描所有具有的行以找到最小值 <code>c2</code>。相比之下，请考虑以下查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MIN</span>(c2) <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c1 = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，第一个索引行<code>c1 = 10</code>包含最小值<code>c2</code> 。仅一行必须读取才能产生返回的行。</p>
<p>对于每个表都具有精确行数的存储引擎（例如<code>MyISAM</code>，但不是 <code>InnoDB</code>），对于缺少该子句或始终为true且没有 子句的查询，<code>Extra</code> 可能会出现此值。（这是一个隐式分组查询的实例，其中存储引擎影响是否可以读取确定数量的行。） <code>COUNT(*)``WHERE``GROUP BY</code></p>
</li>
<li><p><code>Skip_open_table</code>， <code>Open_frm_only</code>， <code>Open_full_table</code>（JSON属性： <code>message</code>）</p>
<p>这些值指示适用于<code>INFORMATION_SCHEMA</code> 表查询的文件打开优化，如 <a href="https://dev.mysql.com/doc/refman/5.7/en/information-schema-optimization.html" target="_blank" rel="noopener">第8.2.3节“优化INFORMATION_SCHEMA查询”中所述</a>。</p>
<ul>
<li><code>Skip_open_table</code>：不需要打开表文件。通过扫描数据库目录，该信息已在查询中可用。</li>
<li><code>Open_frm_only</code>：仅<code>.frm</code>需要打开表的文件。</li>
<li><code>Open_full_table</code>：未优化的信息查找。的<code>.frm</code>， <code>.MYD</code>和 <code>.MYI</code>文件必须被打开。</li>
</ul>
</li>
<li><p><code>Start temporary</code>，<code>End temporary</code>（JSON属性： <code>message</code>）</p>
<p>这表明临时表用于半联接重复淘汰策略。</p>
</li>
<li><p><code>unique row not found</code>（JSON属性： <code>message</code>）</p>
<p>对于诸如的查询，没有行满足 索引或表中的条件。 <code>SELECT ... FROM *tbl_name*``UNIQUE``PRIMARY KEY</code></p>
</li>
<li><p><code>Using filesort</code>（JSON属性： <code>using_filesort</code>）</p>
<p>MySQL必须额外进行一遍，以找出如何按排序顺序检索行。排序是通过根据联接类型遍历所有行并存储与该<code>WHERE</code>子句匹配的所有行的排序键和指向该行的指针来完成的。然后对键进行排序，并按排序顺序检索行。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/order-by-optimization.html" target="_blank" rel="noopener">第8.2.1.14节“按优化排序”</a>。</p>
</li>
<li><p><code>Using index</code>（JSON属性： <code>using_index</code>）</p>
<p>仅使用索引树中的信息从表中检索列信息，而不必进行其他查找以读取实际行。当查询仅使用属于单个索引的列时，可以使用此策略。</p>
<p>对于<code>InnoDB</code>具有用户定义的聚集索引的表，即使列中<code>Using index</code>不存在 该索引也可以使用<code>Extra</code>。如果<code>type</code>is <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_index" target="_blank" rel="noopener"><code>index</code></a>和 <code>key</code>is 就是这种情况 <code>PRIMARY</code>。</p>
</li>
<li><p><code>Using index condition</code>（JSON属性： <code>using_index_condition</code>）</p>
<p>通过访问索引元组并首先对其进行测试以确定是否读取完整的表行来读取表。这样，除非必要，否则索引信息将用于延迟（“ 下推 ”）读取整个表行。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/index-condition-pushdown-optimization.html" target="_blank" rel="noopener">第8.2.1.5节“索引条件下推优化”</a>。</p>
</li>
<li><p><code>Using index for group-by</code>（JSON属性：<code>using_index_for_group_by</code>）</p>
<p>与<code>Using index</code>表访问方法类似，<code>Using index for group-by</code> 表示MySQL找到了一个索引，该索引可用于检索a <code>GROUP BY</code>或 <code>DISTINCT</code>查询的所有列，而无需对实际表进行任何额外的磁盘访问。此外，以最有效的方式使用索引，因此对于每个组，仅读取少数索引条目。有关详细信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/group-by-optimization.html" target="_blank" rel="noopener">第8.2.1.15节“通过优化组”</a>。</p>
</li>
<li><p><code>Using join buffer (Block Nested Loop)</code>， <code>Using join buffer (Batched Key Access)</code> （JSON属性：<code>using_join_buffer</code>）</p>
<p>来自较早联接的表被部分读取到联接缓冲区中，然后从缓冲区中使用它们的行来执行与当前表的联接。 <code>(Block Nested Loop)</code>表示使用块嵌套循环算法，并<code>(Batched Key Access)</code>表示使用批处理密钥访问算法。即，<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>缓冲输出的前一行中的表中的键 ，并从出现行所在的表中批量提取匹配的行 <code>Using join buffer</code>。</p>
<p>在JSON格式的输出中，的值 <code>using_join_buffer</code>始终为<code>Block Nested Loop</code>或之一 <code>Batched Key Access</code>。</p>
<p>有关这些算法的更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/nested-loop-joins.html#block-nested-loop-join-algorithm" target="_blank" rel="noopener">块嵌套循环联接算法</a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/bnl-bka-optimization.html#bka-optimization" target="_blank" rel="noopener">批量密钥访问联接</a>。</p>
</li>
<li><p><code>Using MRR</code>（JSON属性： <code>message</code>）</p>
<p>使用多范围读取优化策略读取表。请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/mrr-optimization.html" target="_blank" rel="noopener">第8.2.1.10节“多范围读取优化”</a>。</p>
</li>
<li><p><code>Using sort_union(...)</code>，<code>Using union(...)</code>，<code>Using intersect(...)</code>（JSON属性： <code>message</code>）</p>
<p>这些指示了特定算法，该算法显示了如何针对<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_index_merge" target="_blank" rel="noopener"><code>index_merge</code></a>联接类型合并索引扫描 。请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/index-merge-optimization.html" target="_blank" rel="noopener">第8.2.1.3节“索引合并优化”</a>。</p>
</li>
<li><p><code>Using temporary</code>（JSON属性： <code>using_temporary_table</code>）</p>
<p>为了解决该查询，MySQL需要创建一个临时表来保存结果。如果查询包含<code>GROUP BY</code>和 <code>ORDER BY</code>子句以不同的方式列出列，通常会发生这种情况。</p>
</li>
<li><p><code>Using where</code>（JSON属性： <code>attached_condition</code>）</p>
<p>甲<code>WHERE</code>子句用于限制来匹配下一个表或发送到客户端的行。除非您特别打算从表中获取或检查所有行，否则如果查询中的<code>Extra</code>值不是 <code>Using where</code>并且表连接类型为<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_all" target="_blank" rel="noopener"><code>ALL</code></a>或 ，则 查询中可能会出错<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_index" target="_blank" rel="noopener"><code>index</code></a>。</p>
<p><code>Using where</code>在JSON格式的输出中没有直接对应的内容；该 <code>attached_condition</code>属性包含使用的任何<code>WHERE</code>条件。</p>
</li>
<li><p><code>Using where with pushed condition</code>（JSON属性：<code>message</code>）</p>
<p>此产品适用于<a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-cluster.html" target="_blank" rel="noopener"><code>NDB</code></a> 表<em>只</em>。这意味着NDB Cluster正在使用条件下推优化来提高在非索引列和常量之间进行直接比较的效率。在这种情况下，条件被“ 下推 ”到群集的数据节点，并同时在所有数据节点上进行评估。这样就无需通过网络发送不匹配的行，并且在可以但不使用条件下推的情况下，可以将此类查询的速度提高5到10倍。有关更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/condition-pushdown-optimization.html" target="_blank" rel="noopener">第8.2.1.4节“发动机状况下推优化”</a>。</p>
</li>
<li><p><code>Zero limit</code>（JSON属性： <code>message</code>）</p>
<p>该查询有一个<code>LIMIT 0</code>子句，不能选择任何行。</p>
</li>
</ul>
<h4 id="解释输出解释"><a href="#解释输出解释" class="headerlink" title="解释输出解释"></a>解释输出解释</h4><p>通过获取输出<code>rows</code> 列中值的乘积，可以很好地表明联接的良好程度<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>。这应该大致告诉您MySQL必须检查多少行才能执行查询。如果使用<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_max_join_size" target="_blank" rel="noopener"><code>max_join_size</code></a>系统变量限制查询，则 此行乘积还用于确定<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a> 执行哪些多表语句以及中止哪个多表语句。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-configuration.html" target="_blank" rel="noopener">第5.1.1节“配置服务器”</a>。</p>
<p>以下示例显示了如何根据提供的信息逐步优化多表联接 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>。</p>
<p>假设您在<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>此处显示了该 语句，并计划使用进行检查 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> tt.TicketNumber, tt.TimeIn,</span><br><span class="line">               tt.ProjectReference, tt.EstimatedShipDate,</span><br><span class="line">               tt.ActualShipDate, tt.ClientID,</span><br><span class="line">               tt.ServiceCodes, tt.RepetitiveID,</span><br><span class="line">               tt.CurrentProcess, tt.CurrentDPPerson,</span><br><span class="line">               tt.RecordVolume, tt.DPPrinted, et.COUNTRY,</span><br><span class="line">               et_1.COUNTRY, do.CUSTNAME</span><br><span class="line">        <span class="keyword">FROM</span> tt, et, et <span class="keyword">AS</span> et_1, <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">WHERE</span> tt.SubmitTime <span class="keyword">IS</span> <span class="literal">NULL</span></span><br><span class="line">          <span class="keyword">AND</span> tt.ActualPC = et.EMPLOYID</span><br><span class="line">          <span class="keyword">AND</span> tt.AssignedPC = et_1.EMPLOYID</span><br><span class="line">          <span class="keyword">AND</span> tt.ClientID = do.CUSTNMBR;</span><br></pre></td></tr></table></figure>

<p>对于此示例，进行以下假设：</p>
<ul>
<li><p>被比较的列已声明如下。</p>
<table>
<thead>
<tr>
<th>表</th>
<th>柱</th>
<th>数据类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>tt</code></td>
<td><code>ActualPC</code></td>
<td><code>CHAR(10)</code></td>
</tr>
<tr>
<td><code>tt</code></td>
<td><code>AssignedPC</code></td>
<td><code>CHAR(10)</code></td>
</tr>
<tr>
<td><code>tt</code></td>
<td><code>ClientID</code></td>
<td><code>CHAR(10)</code></td>
</tr>
<tr>
<td><code>et</code></td>
<td><code>EMPLOYID</code></td>
<td><code>CHAR(15)</code></td>
</tr>
<tr>
<td><code>do</code></td>
<td><code>CUSTNMBR</code></td>
<td><code>CHAR(15)</code></td>
</tr>
</tbody></table>
</li>
<li><p>这些表具有以下索引。</p>
<table>
<thead>
<tr>
<th>表</th>
<th>指数</th>
</tr>
</thead>
<tbody><tr>
<td><code>tt</code></td>
<td><code>ActualPC</code></td>
</tr>
<tr>
<td><code>tt</code></td>
<td><code>AssignedPC</code></td>
</tr>
<tr>
<td><code>tt</code></td>
<td><code>ClientID</code></td>
</tr>
<tr>
<td><code>et</code></td>
<td><code>EMPLOYID</code> （首要的关键）</td>
</tr>
<tr>
<td><code>do</code></td>
<td><code>CUSTNMBR</code> （首要的关键）</td>
</tr>
</tbody></table>
</li>
<li><p>这些<code>tt.ActualPC</code>值分布不均。</p>
</li>
</ul>
<p>最初，在执行任何优化之前，该 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>语句会产生以下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">table type possible_keys key  key_len ref  rows  Extra</span><br><span class="line">et    ALL  PRIMARY       NULL NULL    NULL 74</span><br><span class="line">do    ALL  PRIMARY       NULL NULL    NULL 2135</span><br><span class="line">et_1  ALL  PRIMARY       NULL NULL    NULL 74</span><br><span class="line">tt    ALL  AssignedPC,   NULL NULL    NULL 3872</span><br><span class="line">           ClientID,</span><br><span class="line">           ActualPC</span><br><span class="line">      Range checked for each record (index map: 0x23)</span><br></pre></td></tr></table></figure>

<p>因为<code>type</code>是 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_all" target="_blank" rel="noopener"><code>ALL</code></a>针对每个表的，所以此输出表明MySQL正在生成所有表的笛卡尔积；也就是说，行的每种组合。这需要相当长的时间，因为必须检查每个表中的行数的乘积。对于当前情况，此乘积为74×2135×74×3872 = 45,268,558,720行。如果桌子更大，您只能想象需要多长时间。</p>
<p>这里的一个问题是，如果将索引声明为相同的类型和大小，则MySQL可以更有效地在列上使用索引。在这种情况下，<a href="https://dev.mysql.com/doc/refman/5.7/en/char.html" target="_blank" rel="noopener"><code>VARCHAR</code></a>与 <a href="https://dev.mysql.com/doc/refman/5.7/en/char.html" target="_blank" rel="noopener"><code>CHAR</code></a>被认为是相同的，如果它们被声明为相同的大小。 <code>tt.ActualPC</code>声明为 <code>CHAR(10)</code>和<code>et.EMPLOYID</code> 是<code>CHAR(15)</code>，因此长度不匹配。</p>
<p>要解决此列长度之间的差异，请使用 从10个字符<a href="https://dev.mysql.com/doc/refman/5.7/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>延长 <code>ActualPC</code>到15个字符：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE tt MODIFY ActualPC VARCHAR(15);</span><br></pre></td></tr></table></figure>

<p>现在<code>tt.ActualPC</code>和 <code>et.EMPLOYID</code>都是 <code>VARCHAR(15)</code>。<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>再次执行该 语句将产生以下结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">table type   possible_keys key     key_len ref         rows    Extra</span><br><span class="line">tt    ALL    AssignedPC,   NULL    NULL    NULL        3872    Using</span><br><span class="line">             ClientID,                                         where</span><br><span class="line">             ActualPC</span><br><span class="line">do    ALL    PRIMARY       NULL    NULL    NULL        2135</span><br><span class="line">      Range checked for each record (index map: 0x1)</span><br><span class="line">et_1  ALL    PRIMARY       NULL    NULL    NULL        74</span><br><span class="line">      Range checked for each record (index map: 0x1)</span><br><span class="line">et    eq_ref PRIMARY       PRIMARY 15      tt.ActualPC 1</span><br></pre></td></tr></table></figure>

<p>这不是完美的，但是更好：<code>rows</code>值的乘积 少了74倍。此版本在几秒钟内执行。</p>
<p>可以进行第二种更改以消除<code>tt.AssignedPC = et_1.EMPLOYID</code>和<code>tt.ClientID = do.CUSTNMBR</code>比较的列长不匹配：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE tt MODIFY AssignedPC VARCHAR(15),</span><br><span class="line">                      MODIFY ClientID   VARCHAR(15);</span><br></pre></td></tr></table></figure>

<p>修改之后， <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>产生如下所示的输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">table type   possible_keys key      key_len ref           rows Extra</span><br><span class="line">et    ALL    PRIMARY       NULL     NULL    NULL          74</span><br><span class="line">tt    ref    AssignedPC,   ActualPC 15      et.EMPLOYID   52   Using</span><br><span class="line">             ClientID,                                         where</span><br><span class="line">             ActualPC</span><br><span class="line">et_1  eq_ref PRIMARY       PRIMARY  15      tt.AssignedPC 1</span><br><span class="line">do    eq_ref PRIMARY       PRIMARY  15      tt.ClientID   1</span><br></pre></td></tr></table></figure>

<p>在这一点上，查询尽可能地被优化。剩下的问题是，默认情况下，MySQL假定<code>tt.ActualPC</code> 列中的值是均匀分布的，而表则不是这种情况<code>tt</code>。幸运的是，很容易告诉MySQL分析密钥分布：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ANALYZE TABLE tt;</span><br></pre></td></tr></table></figure>

<p>使用附加的索引信息，联接是完美的，并 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>产生以下结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">table type   possible_keys key     key_len ref           rows Extra</span><br><span class="line">tt    ALL    AssignedPC    NULL    NULL    NULL          3872 Using</span><br><span class="line">             ClientID,                                        where</span><br><span class="line">             ActualPC</span><br><span class="line">et    eq_ref PRIMARY       PRIMARY 15      tt.ActualPC   1</span><br><span class="line">et_1  eq_ref PRIMARY       PRIMARY 15      tt.AssignedPC 1</span><br><span class="line">do    eq_ref PRIMARY       PRIMARY 15      tt.ClientID   1</span><br></pre></td></tr></table></figure>

<p>在<code>rows</code>从输出列 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>是一个受过教育的猜测从MySQL联接优化。通过将<code>rows</code>乘积与查询返回的实际行数进行比较，检查数字是否接近真实 值。如果数字完全不同，则可以通过<code>STRAIGHT_JOIN</code>在 <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>语句中使用并尝试在<code>FROM</code>子句中以不同顺序列出表来 获得更好的性能 。（但是，<code>STRAIGHT_JOIN</code>由于它禁用了半<a href="https://dev.mysql.com/doc/refman/5.7/en/semijoins.html" target="_blank" rel="noopener">联接转换</a>， 可能会阻止使用索引。请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/semijoins.html" target="_blank" rel="noopener">第8.2.2.1节“</a>使用半 <a href="https://dev.mysql.com/doc/refman/5.7/en/semijoins.html" target="_blank" rel="noopener">联接转换优化子查询，派生表和视图引用”）</a>）</p>
<p>在某些情况下，可能会执行<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN SELECT</code></a>与子查询一起使用时会修改数据的语句。有关更多信息，请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/derived-tables.html" target="_blank" rel="noopener">第13.2.10.8节“派生表”</a>。</p>
<h3 id="8-8-3扩展的EXPLAIN输出格式"><a href="#8-8-3扩展的EXPLAIN输出格式" class="headerlink" title="8.8.3扩展的EXPLAIN输出格式"></a>8.8.3扩展的EXPLAIN输出格式</h3><p>对于<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>语句，该 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>语句会产生额外的（“ 扩展的 ”）信息，这些信息不是<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>输出的一部分， 但可以通过在<a href="https://dev.mysql.com/doc/refman/5.7/en/show-warnings.html" target="_blank" rel="noopener"><code>SHOW WARNINGS</code></a> 以下语句发出来查看<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>。输出中的 <code>Message</code>值<a href="https://dev.mysql.com/doc/refman/5.7/en/show-warnings.html" target="_blank" rel="noopener"><code>SHOW WARNINGS</code></a>显示优化器如何限定<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>语句 中的表名和列名， <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>应用重写和优化规则后的外观以及有关优化过程的其他注释。</p>
<p>可在<a href="https://dev.mysql.com/doc/refman/5.7/en/show-warnings.html" target="_blank" rel="noopener"><code>SHOW WARNINGS</code></a>语句后面 显示的扩展信息 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>仅针对 <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>语句生成。 <a href="https://dev.mysql.com/doc/refman/5.7/en/show-warnings.html" target="_blank" rel="noopener"><code>SHOW WARNINGS</code></a>显示其他可解释语句空结果（<a href="https://dev.mysql.com/doc/refman/5.7/en/delete.html" target="_blank" rel="noopener"><code>DELETE</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/replace.html" target="_blank" rel="noopener"><code>REPLACE</code></a>，和 <a href="https://dev.mysql.com/doc/refman/5.7/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a>）。</p>
<p>注意</p>
<p>在较早的MySQL版本中，使用产生了扩展信息<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN EXTENDED</code></a>。仍然可以识别该语法以实现向后兼容性，但是默认情况下现在启用了扩展输出，因此该<code>EXTENDED</code>关键字是多余的并且已弃用。它的使用会导致警告，并且它将<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a> 在将来的MySQL版本中从语法中删除。</p>
<p>这是扩展<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>输出的示例 ：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN</span><br><span class="line">       <span class="keyword">SELECT</span> t1.a, t1.a <span class="keyword">IN</span> (<span class="keyword">SELECT</span> t2.a <span class="keyword">FROM</span> t2) <span class="keyword">FROM</span> t1\G</span><br><span class="line">*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">           <span class="keyword">id</span>: <span class="number">1</span></span><br><span class="line">  select_type: PRIMARY</span><br><span class="line">        <span class="keyword">table</span>: t1</span><br><span class="line">         <span class="keyword">type</span>: <span class="keyword">index</span></span><br><span class="line">possible_keys: <span class="literal">NULL</span></span><br><span class="line">          <span class="keyword">key</span>: PRIMARY</span><br><span class="line">      key_len: <span class="number">4</span></span><br><span class="line">          <span class="keyword">ref</span>: <span class="literal">NULL</span></span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">4</span></span><br><span class="line">     filtered: <span class="number">100.00</span></span><br><span class="line">        Extra: <span class="keyword">Using</span> <span class="keyword">index</span></span><br><span class="line">*************************** <span class="number">2.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">           <span class="keyword">id</span>: <span class="number">2</span></span><br><span class="line">  select_type: SUBQUERY</span><br><span class="line">        <span class="keyword">table</span>: t2</span><br><span class="line">         <span class="keyword">type</span>: <span class="keyword">index</span></span><br><span class="line">possible_keys: a</span><br><span class="line">          <span class="keyword">key</span>: a</span><br><span class="line">      key_len: <span class="number">5</span></span><br><span class="line">          <span class="keyword">ref</span>: <span class="literal">NULL</span></span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">3</span></span><br><span class="line">     filtered: <span class="number">100.00</span></span><br><span class="line">        Extra: <span class="keyword">Using</span> <span class="keyword">index</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">SHOW</span> <span class="keyword">WARNINGS</span>\G</span><br><span class="line">*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">  <span class="keyword">Level</span>: Note</span><br><span class="line">   Code: <span class="number">1003</span></span><br><span class="line">Message: <span class="comment">/* select#1 */</span> <span class="keyword">select</span> <span class="string">`test`</span>.<span class="string">`t1`</span>.<span class="string">`a`</span> <span class="keyword">AS</span> <span class="string">`a`</span>,</span><br><span class="line">         &lt;in_optimizer&gt;(<span class="string">`test`</span>.<span class="string">`t1`</span>.<span class="string">`a`</span>,<span class="string">`test`</span>.<span class="string">`t1`</span>.<span class="string">`a`</span> <span class="keyword">in</span></span><br><span class="line">         ( &lt;materialize&gt; (<span class="comment">/* select#2 */</span> <span class="keyword">select</span> <span class="string">`test`</span>.<span class="string">`t2`</span>.<span class="string">`a`</span></span><br><span class="line">         <span class="keyword">from</span> <span class="string">`test`</span>.<span class="string">`t2`</span> <span class="keyword">where</span> <span class="number">1</span> <span class="keyword">having</span> <span class="number">1</span> ),</span><br><span class="line">         &lt;primary_index_lookup&gt;(<span class="string">`test`</span>.<span class="string">`t1`</span>.<span class="string">`a`</span> <span class="keyword">in</span></span><br><span class="line">         &lt;<span class="keyword">temporary</span> <span class="keyword">table</span>&gt; <span class="keyword">on</span> &lt;auto_key&gt;</span><br><span class="line">         <span class="keyword">where</span> ((<span class="string">`test`</span>.<span class="string">`t1`</span>.<span class="string">`a`</span> = <span class="string">`materialized-subquery`</span>.<span class="string">`a`</span>))))) <span class="keyword">AS</span> <span class="string">`t1.a</span></span><br><span class="line"><span class="string">         IN (SELECT t2.a FROM t2)`</span> <span class="keyword">from</span> <span class="string">`test`</span>.<span class="string">`t1`</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>由于显示的语句<a href="https://dev.mysql.com/doc/refman/5.7/en/show-warnings.html" target="_blank" rel="noopener"><code>SHOW WARNINGS</code></a>可能包含特殊标记以提供有关查询重写或优化程序操作的信息，因此该语句不一定是有效的SQL，也不打算执行。输出中可能还包含带有<code>Message</code>值的行，这些 值提供有关优化程序采取的操作的其他非SQL解释性说明。</p>
<p>以下列表描述了特殊的标记，这些标记可以出现在由<a href="https://dev.mysql.com/doc/refman/5.7/en/show-warnings.html" target="_blank" rel="noopener"><code>SHOW WARNINGS</code></a>下列显示的扩展输出中：</p>
<ul>
<li><p><code>&lt;auto_key&gt;</code></p>
<p>自动生成的临时表密钥。</p>
</li>
<li><p><code>&lt;cache&gt;(*expr*)</code></p>
<p>表达式（例如标量子查询）执行一次，结果值保存在内存中以备后用。对于包含多个值的结果，可能会创建一个临时表，您将会看到<code>&lt;temporary table&gt;</code>。</p>
</li>
<li><p><code>&lt;exists&gt;(*query fragment*)</code></p>
<p>子查询谓词被转换为 <code>EXISTS</code>谓词，并且子查询被转换为可以与<code>EXISTS</code>谓词一起使用 。</p>
</li>
<li><p><code>&lt;in_optimizer&gt;(*query fragment*)</code></p>
<p>这是一个内部优化器对象，对用户没有任何意义。</p>
</li>
<li><p><code>&lt;index_lookup&gt;(*query fragment*)</code></p>
<p>使用索引查找来处理查询片段以查找合格的行。</p>
</li>
<li><p><code>&lt;if&gt;(*condition*, *expr1*, *expr2*)</code></p>
<p>如果条件为true，则求值为 <em>expr1</em>，否则为 <em>expr2</em>。</p>
</li>
<li><p><code>&lt;is_not_null_test&gt;(*expr*)</code></p>
<p>验证表达式不等于的测试 <code>NULL</code>。</p>
</li>
<li><p><code>&lt;materialize&gt;(*query fragment*)</code></p>
<p>使用子查询实现。</p>
</li>
<li><p>``materialized-subquery<code>.*col_name*</code></p>
<p>实现了<em>col_name</em>对内部临时表中列的引用， 以保存评估子查询的结果。</p>
</li>
<li><p><code>&lt;primary_index_lookup&gt;(*query fragment*)</code></p>
<p>使用主键查找来处理查询片段以查找合格的行。</p>
</li>
<li><p><code>&lt;ref_null_helper&gt;(*expr*)</code></p>
<p>这是一个内部优化器对象，对用户没有任何意义。</p>
</li>
<li><p><code>/* select#*N* */ *select_stmt*</code></p>
<p>将<code>SELECT</code>与在非扩展的行相关联<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>，其具有一输出<code>id</code>的值 <em>N</em>。</p>
</li>
<li><p><code>*outer_tables* semi join (*inner_tables*)</code></p>
<p>半联接操作。 <em>inner_tables</em>显示未拉出的表。请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/semijoins.html" target="_blank" rel="noopener">第8.2.2.1节“使用半联接转换优化子查询，派生表和视图引用”</a>。</p>
</li>
<li><p><code>&lt;temporary table&gt;</code></p>
<p>这表示为缓存中间结果而创建的内部临时表。</p>
</li>
</ul>
<p>当某些表属于<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_const" target="_blank" rel="noopener"><code>const</code></a> 或<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_system" target="_blank" rel="noopener"><code>system</code></a>类型时，涉及这些表中的列的表达式将由优化器尽早评估，并且不属于所显示语句的一部分。但是，使用时<code>FORMAT=JSON</code>，某些 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_const" target="_blank" rel="noopener"><code>const</code></a>表访问将显示为<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_ref" target="_blank" rel="noopener"><code>ref</code></a>使用const值的访问。</p>
<h3 id="8-8-4获取命名连接的执行计划信息"><a href="#8-8-4获取命名连接的执行计划信息" class="headerlink" title="8.8.4获取命名连接的执行计划信息"></a>8.8.4获取命名连接的执行计划信息</h3><p>要获得在命名连接中执行的可解释语句的执行计划，请使用以下语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> [options] <span class="keyword">FOR</span> <span class="keyword">CONNECTION</span> connection_id;</span><br></pre></td></tr></table></figure>

<p><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-for-connection.html" target="_blank" rel="noopener"><code>EXPLAIN FOR CONNECTION</code></a>返回<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>当前在给定连接中用于执行查询的信息。由于数据（和支持统计数据）的更改，它可能会产生与<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>在等效查询文本上运行不同的结果 。行为上的这种差异对于诊断更多瞬时性能问题很有用。例如，如果您在一个会话中运行需要很长时间才能完成的语句，则<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-for-connection.html" target="_blank" rel="noopener"><code>EXPLAIN FOR CONNECTION</code></a>在另一个会话中使用该语句可能会产生有关延迟原因的有用信息。</p>
<p><em>connection_id</em>是从<code>INFORMATION_SCHEMA</code> <a href="https://dev.mysql.com/doc/refman/5.7/en/processlist-table.html" target="_blank" rel="noopener"><code>PROCESSLIST</code></a>表或 <a href="https://dev.mysql.com/doc/refman/5.7/en/show-processlist.html" target="_blank" rel="noopener"><code>SHOW PROCESSLIST</code></a>语句获得的连接标识符 。如果您有<a href="https://dev.mysql.com/doc/refman/5.7/en/privileges-provided.html#priv_process" target="_blank" rel="noopener"><code>PROCESS</code></a>特权，则可以为任何连接指定标识符。否则，您只能为自己的连接指定标识符。</p>
<p>如果命名连接未执行语句，则结果为空。否则，<code>EXPLAIN FOR CONNECTION</code> 仅当在命名连接中执行的语句是可解释的时才适用。这包括 <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/delete.html" target="_blank" rel="noopener"><code>DELETE</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/replace.html" target="_blank" rel="noopener"><code>REPLACE</code></a>，和 <a href="https://dev.mysql.com/doc/refman/5.7/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a>。（但是， <code>EXPLAIN FOR CONNECTION</code>不适用于预备语句，甚至不适用于这些类型的预备语句。）</p>
<p>如果命名连接正在执行一条可解释的语句，则输出将是您<code>EXPLAIN</code>在语句本身上使用所获得的结果 。</p>
<p>如果命名连接正在执行不可解释的语句，则会发生错误。例如，由于<code>EXPLAIN</code>无法解释，因此无法命名当前会话的连接标识符 ：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT CONNECTION_ID();</span><br><span class="line">+<span class="comment">-----------------+</span></span><br><span class="line">| CONNECTION_ID() |</span><br><span class="line">+<span class="comment">-----------------+</span></span><br><span class="line">|             373 |</span><br><span class="line">+<span class="comment">-----------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">EXPLAIN</span> <span class="keyword">FOR</span> <span class="keyword">CONNECTION</span> <span class="number">373</span>;</span><br><span class="line">ERROR 1889 (HY000): <span class="keyword">EXPLAIN</span> <span class="keyword">FOR</span> <span class="keyword">CONNECTION</span> command <span class="keyword">is</span> supported</span><br><span class="line"><span class="keyword">only</span> <span class="keyword">for</span> <span class="keyword">SELECT</span>/<span class="keyword">UPDATE</span>/<span class="keyword">INSERT</span>/<span class="keyword">DELETE</span>/<span class="keyword">REPLACE</span></span><br></pre></td></tr></table></figure>

<p>该<code>Com_explain_other</code>状态变量表示的数 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN FOR CONNECTION</code></a>执行的语句。</p>
<h3 id="8-8-5估计查询性能"><a href="#8-8-5估计查询性能" class="headerlink" title="8.8.5估计查询性能"></a>8.8.5估计查询性能</h3><p>在大多数情况下，您可以通过计算磁盘搜索次数来估计查询性能。对于小型表，通常可以在一个磁盘搜索中找到一行（因为索引可能已缓存）。对于更大的表，您可以估计，使用B树索引，您需要进行许多查找才能找到行： 。 <code>log(*row_count*) / log(*index_block_length* / 3 * 2 / (*index_length* + *data_pointer_length*)) + 1</code></p>
<p>在MySQL中，索引块通常为1,024字节，数据指针通常为四个字节。对于500,000行的键值长度为三个字节（的大小 <a href="https://dev.mysql.com/doc/refman/5.7/en/integer-types.html" target="_blank" rel="noopener"><code>MEDIUMINT</code></a>）的表，该公式表示 <code>log(500,000)/log(1024/3*2/(3+4)) + 1</code>=搜索 <code>4</code>。</p>
<p>该索引将需要大约500,000 * 7 * 3/2 = 5.2MB的存储空间（假设典型的索引缓冲区填充率为2/3），因此您可能在内存中拥有很多索引，因此只需要一个或两个调用即可读取数据以查找行。</p>
<p>但是，对于写操作，您需要四个搜索请求以查找在何处放置新索引值，通常需要两个搜索来更新索引并写入行。</p>
<p>前面的讨论并不意味着您的应用程序性能会因log缓慢下降 <em>N</em>。只要所有内容都由OS或MySQL服务器缓存，随着表的增大，事情只会变得稍微慢一些。在数据变得太大而无法缓存之后，事情开始变得缓慢得多，直到您的应用程序仅受磁盘搜索约束（随日志增长 <em>N</em>）。为避免这种情况，请随着数据的增长而增加密钥缓存的大小。对于<code>MyISAM</code> 表，键缓存大小由<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_key_buffer_size" target="_blank" rel="noopener"><code>key_buffer_size</code></a>系统变量控制 。请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/server-configuration.html" target="_blank" rel="noopener">第5.1.1节“配置服务器”</a>。</p>
<h2 id="8-9控制查询优化器"><a href="#8-9控制查询优化器" class="headerlink" title="8.9控制查询优化器"></a>8.9控制查询优化器</h2><ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/controlling-query-plan-evaluation.html" target="_blank" rel="noopener">8.9.1控制查询计划评估</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/switchable-optimizations.html" target="_blank" rel="noopener">8.9.2可切换的优化</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html" target="_blank" rel="noopener">8.9.3优化器提示</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/index-hints.html" target="_blank" rel="noopener">8.9.4索引提示</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/cost-model.html" target="_blank" rel="noopener">8.9.5优化器成本模型</a></li>
</ul>
<p>MySQL通过系统变量提供优化器控制，这些系统变量会影响如何评估查询计划，可切换的优化，优化器和索引提示以及优化器成本模型。</p>
<h3 id="8-9-1控制查询计划评估"><a href="#8-9-1控制查询计划评估" class="headerlink" title="8.9.1控制查询计划评估"></a>8.9.1控制查询计划评估</h3><p>查询优化器的任务是找到执行SQL查询的最佳计划。因为“ 好 ”和“ 坏 ”之间的性能差异计划可能是一个数量级（即几秒钟相对于几小时甚至几天），大多数查询优化器（包括MySQL）在所有可能的查询评估计划中或多或少地穷举搜索最佳计划。对于联接查询，MySQL优化器调查的可能计划的数量与查询中引用的表的数量成指数增长。对于少量表（通常少于7到10），这不是问题。但是，提交较大的查询时，花在查询优化上的时间可能很容易成为服务器性能的主要瓶颈。</p>
<p>一种更灵活的查询优化方法，使用户可以控制优化程序在搜索最佳查询评估计划时的详尽程度。通常的想法是，优化器调查的计划越少，则编译查询所花费的时间就越少。另一方面，由于优化器跳过了一些计划，因此可能会找不到最佳计划。</p>
<p>可以使用两个系统变量来控制优化器相对于评估的计划数量的行为：</p>
<ul>
<li>该<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_optimizer_prune_level" target="_blank" rel="noopener"><code>optimizer_prune_level</code></a> 变量告诉优化器根据对每个表访问的行数的估计来跳过某些计划。我们的经验表明，这种“有根据的猜测 ”很少会错过最佳计划，并且可能会大大减少查询的编译时间。这就是为什么此选项<code>optimizer_prune_level=1</code>默认为（）的原因。但是，如果您认为优化器错过了更好的查询计划，则可以关闭此选项（<code>optimizer_prune_level=0</code>），可能会导致查询编译花费更长的时间。请注意，即使使用这种启发式方法，优化器仍会探索大约指数级的计划。</li>
<li>该<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_optimizer_search_depth" target="_blank" rel="noopener"><code>optimizer_search_depth</code></a> 变量告诉优化器应该评估每个不完整计划的“ 未来 ”有多远，以评估是否应进一步扩展它。较小的值 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_optimizer_search_depth" target="_blank" rel="noopener"><code>optimizer_search_depth</code></a>可能会导致查询编译时间缩短几个数量级。例如，如果<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_optimizer_search_depth" target="_blank" rel="noopener"><code>optimizer_search_depth</code></a>查询的表数接近12个，13个或更多，则很容易需要几个小时甚至几天来进行编译 。同时，如果用 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_optimizer_search_depth" target="_blank" rel="noopener"><code>optimizer_search_depth</code></a> 等于3或4，对于同一查询，优化器可以在不到一分钟的时间内完成编译。如果不确定什么是合理的值 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_optimizer_search_depth" target="_blank" rel="noopener"><code>optimizer_search_depth</code></a>，可以将此变量设置为0，以告知优化器自动确定该值。</li>
</ul>
<h3 id="8-9-2可切换的优化"><a href="#8-9-2可切换的优化" class="headerlink" title="8.9.2可切换的优化"></a>8.9.2可切换的优化</h3><p>要查看当前的优化器标志集，请选择变量值：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT @@optimizer_switch\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@optimizer_switch: index_merge=on,index_merge_union=on,</span><br><span class="line">                    index_merge_sort_union=on,</span><br><span class="line">                    index_merge_intersection=on,</span><br><span class="line">                    engine_condition_pushdown=on,</span><br><span class="line">                    index_condition_pushdown=on,</span><br><span class="line">                    mrr=on,mrr_cost_based=on,</span><br><span class="line">                    block_nested_loop=on,batched_key_access=off,</span><br><span class="line">                    materialization=on,semijoin=on,loosescan=on,</span><br><span class="line">                    firstmatch=on,duplicateweedout=on,</span><br><span class="line">                    subquery_materialization_cost_based=on,</span><br><span class="line">                    use_index_extensions=on,</span><br><span class="line">                    condition_fanout_filter=on,derived_merge=on</span><br></pre></td></tr></table></figure>

<p>要更改的值 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_optimizer_switch" target="_blank" rel="noopener"><code>optimizer_switch</code></a>，请分配一个值，该值由一个或多个命令的逗号分隔列表组成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> [<span class="keyword">GLOBAL</span>|<span class="keyword">SESSION</span>] optimizer_switch=<span class="string">'command[,command]...'</span>;</span><br></pre></td></tr></table></figure>

<p>每个<em>command</em>值应具有下表中显示的格式之一。</p>
<table>
<thead>
<tr>
<th>命令语法</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>default</code></td>
<td>将每个优化重置为其默认值</td>
</tr>
<tr>
<td><code>*opt_name*=default</code></td>
<td>将命名的优化设置为其默认值</td>
</tr>
<tr>
<td><code>*opt_name*=off</code></td>
<td>禁用命名优化</td>
</tr>
<tr>
<td><code>*opt_name*=on</code></td>
<td>启用命名的优化</td>
</tr>
</tbody></table>
<p>值中命令的顺序无关紧要，尽管<code>default</code>如果存在则先执行命令。设置<em>opt_name<em>标志以 <code>default</code>将其 设置为默认值<code>on</code>或<code>off</code>任意值。</em>opt_name</em> 不允许在值中多次指定任何给定值，这会导致错误。值中的任何错误都会导致分配失败并显示错误，而值 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_optimizer_switch" target="_blank" rel="noopener"><code>optimizer_switch</code></a>保持不变。</p>
<p>下表描述了<em>opt_name</em>按优化策略分组的允许 标志名称：</p>
<ul>
<li><p>批处理密钥访问标志</p>
<ul>
<li><p><code>batched_key_access</code>（默认 <code>off</code>）</p>
<p>控制BKA连接算法的使用。</p>
</li>
</ul>
<p>为<code>batched_key_access</code>使设置为有效<code>on</code>，该 <code>mrr</code>标记还必须为 <code>on</code>。当前，MRR的成本估算过于悲观。因此，也有必要对 <code>mrr_cost_based</code>要 <code>off</code>用于要使用的BKA。</p>
<p>有关更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/bnl-bka-optimization.html" target="_blank" rel="noopener">第8.2.1.11节“阻止嵌套循环和批处理键访问联接”</a>。</p>
</li>
<li><p>块嵌套循环标志</p>
<ul>
<li><p><code>block_nested_loop</code>（默认 <code>on</code>）</p>
<p>控制BNL连接算法的使用。</p>
</li>
</ul>
<p>有关更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/bnl-bka-optimization.html" target="_blank" rel="noopener">第8.2.1.11节“阻止嵌套循环和批处理键访问联接”</a>。</p>
</li>
<li><p>条件过滤标志</p>
<ul>
<li><p><code>condition_fanout_filter</code>（默认 <code>on</code>）</p>
<p>控制条件过滤的使用。</p>
</li>
</ul>
<p>有关更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/condition-filtering.html" target="_blank" rel="noopener">第8.2.1.12节“条件过滤”</a>。</p>
</li>
<li><p>派生表合并标志</p>
<ul>
<li><p><code>derived_merge</code>（默认 <code>on</code>）</p>
<p>控制派生表和视图合并到外部查询块中。</p>
</li>
</ul>
<p><code>derived_merge</code>假设没有其他规则阻止合并，则 该标志控制优化器是否尝试将派生表和视图引用合并到外部查询块中。例如，<code>ALGORITHM</code>视图的 指令优先于<code>derived_merge</code> 设置。默认情况下，该标志<code>on</code>用于启用合并。</p>
<p>有关更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/derived-table-optimization.html" target="_blank" rel="noopener">第8.2.2.4节“通过合并或实现来优化派生表和视图引用”</a>。</p>
</li>
<li><p>发动机状态下推标志</p>
<ul>
<li><p><code>engine_condition_pushdown</code>（默认 <code>on</code>）</p>
<p>控制发动机状态下推。</p>
</li>
</ul>
<p>有关更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/condition-pushdown-optimization.html" target="_blank" rel="noopener">第8.2.1.4节“引擎状态下推优化”</a>。</p>
</li>
<li><p>索引条件下推标志</p>
<ul>
<li><p><code>index_condition_pushdown</code>（默认 <code>on</code>）</p>
<p>控制索引条件下推。</p>
</li>
</ul>
<p>有关更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/index-condition-pushdown-optimization.html" target="_blank" rel="noopener">第8.2.1.5节“索引条件下推优化”</a>。</p>
</li>
<li><p>索引扩展标志</p>
<ul>
<li><p><code>use_index_extensions</code>（默认 <code>on</code>）</p>
<p>控制索引扩展的使用。</p>
</li>
</ul>
<p>有关更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/index-extensions.html" target="_blank" rel="noopener">第8.3.9节“索引扩展的使用”</a>。</p>
</li>
<li><p>索引合并标志</p>
<ul>
<li><p><code>index_merge</code>（默认 <code>on</code>）</p>
<p>控制所有索引合并优化。</p>
</li>
<li><p><code>index_merge_intersection</code>（默认 <code>on</code>）</p>
<p>控制索引合并路口访问优化。</p>
</li>
<li><p><code>index_merge_sort_union</code>（默认 <code>on</code>）</p>
<p>控制索引合并排序联盟访问优化。</p>
</li>
<li><p><code>index_merge_union</code>（默认 <code>on</code>）</p>
<p>控制索引合并联合访问优化。</p>
</li>
</ul>
<p>有关更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/index-merge-optimization.html" target="_blank" rel="noopener">第8.2.1.3节“索引合并优化”</a>。</p>
</li>
<li><p>多范围读取标志</p>
<ul>
<li><p><code>mrr</code>（默认<code>on</code>）</p>
<p>控制多范围读取策略。</p>
</li>
<li><p><code>mrr_cost_based</code>（默认 <code>on</code>）</p>
<p>如果，则控制基于成本的MRR的使用 <code>mrr=on</code>。</p>
</li>
</ul>
<p>有关更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/mrr-optimization.html" target="_blank" rel="noopener">第8.2.1.10节“多范围读取优化”</a>。</p>
</li>
<li><p>半连接标志</p>
<ul>
<li><p><code>semijoin</code>（默认 <code>on</code>）</p>
<p>控制所有半联接策略。</p>
</li>
<li><p><code>duplicateweedout</code>（默认 <code>on</code>）</p>
<p>控制半联接重复除草策略。</p>
</li>
<li><p><code>firstmatch</code>（默认 <code>on</code>）</p>
<p>控制半联接的FirstMatch策略。</p>
</li>
<li><p><code>loosescan</code>（默认 <code>on</code>）</p>
<p>控制半联接的LooseScan策略（不要与Loose Index Scan for混淆<code>GROUP BY</code>）。</p>
</li>
</ul>
<p>在<code>semijoin</code>， <code>firstmatch</code>，<code>loosescan</code>，和<code>duplicateweedout</code>标志启用过的半连接策略控制。该<code>semijoin</code> 标志控制是否使用半联接。如果将其设置为 <code>on</code>，则<code>firstmatch</code>和 <code>loosescan</code>标志可对允许的半联接策略进行更好的控制。</p>
<p>如果<code>duplicateweedout</code>禁用了半连接策略，则除非所有其他适用的策略也都被禁用，否则将不使用它。</p>
<p>如果<code>semijoin</code>和 <code>materialization</code>均为 <code>on</code>，则半联接在适用的情况下也使用物化。这些标志是<code>on</code>默认设置。</p>
<p>有关更多信息，请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/semijoins.html" target="_blank" rel="noopener">第8.2.2.1节“使用半联接转换优化子查询，派生表和视图引用”</a>。</p>
</li>
<li><p>子查询实现标志</p>
<ul>
<li><p><code>materialization</code>（默认 <code>on</code>）</p>
<p>控制实现（包括半联接实现）。</p>
</li>
<li><p><code>subquery_materialization_cost_based</code> （默认<code>on</code>）</p>
<p>使用基于成本的物化选择。</p>
</li>
</ul>
<p>该<code>materialization</code>标志控制是否使用子查询实现。如果 <code>semijoin</code>和 <code>materialization</code>均为 <code>on</code>，则半联接在适用的情况下也使用物化。这些标志是<code>on</code>默认设置。</p>
<p>该<code>subquery_materialization_cost_based</code> 标志使您可以控制子查询实现和<code>IN</code>-to- <code>EXISTS</code>subquery转换之间的选择 。如果该标志是<code>on</code>（缺省值），则优化器将在子查询实现和<code>IN</code>-to- <code>EXISTS</code>subquery转换之间执行基于成本的选择（ 如果可以使用这两种方法）。如果标志是<code>off</code>，优化器选择子查询物化了 <code>IN</code>-到- <code>EXISTS</code>子查询的转变。</p>
<p>有关更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/subquery-optimization.html" target="_blank" rel="noopener">第8.2.2节“优化子查询，派生表和视图引用”</a>。</p>
</li>
</ul>
<p>当您为分配值时 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_optimizer_switch" target="_blank" rel="noopener"><code>optimizer_switch</code></a>，未提及的标志将保留其当前值。这样就可以在单个语句中启用或禁用特定的优化器行为，而不会影响其他行为。该语句不取决于存在其他优化器标志以及它们的值是什么。假设所有索引合并优化均已启用：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT @@optimizer_switch\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@optimizer_switch: index_merge=on,index_merge_union=on,</span><br><span class="line">                    index_merge_sort_union=on,</span><br><span class="line">                    index_merge_intersection=on,</span><br><span class="line">                    engine_condition_pushdown=on,</span><br><span class="line">                    index_condition_pushdown=on,</span><br><span class="line">                    mrr=on,mrr_cost_based=on,</span><br><span class="line">                    block_nested_loop=on,batched_key_access=off,</span><br><span class="line">                    materialization=on,semijoin=on,loosescan=on,</span><br><span class="line">                    firstmatch=on,</span><br><span class="line">                    subquery_materialization_cost_based=on,</span><br><span class="line">                    use_index_extensions=on,</span><br><span class="line">                    condition_fanout_filter=on</span><br></pre></td></tr></table></figure>

<p>如果服务器对某些查询使用索引合并联合或索引合并排序联合访问方法，并且您要检查优化器在没有它们的情况下是否会更好地执行，请按如下所示设置变量值：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET optimizer_switch='index_merge_union=off,index_merge_sort_union=off';</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT @@optimizer_switch\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">@@optimizer_switch: index_merge=on,index_merge_union=off,</span><br><span class="line">                    index_merge_sort_union=off,</span><br><span class="line">                    index_merge_intersection=on,</span><br><span class="line">                    engine_condition_pushdown=on,</span><br><span class="line">                    index_condition_pushdown=on,</span><br><span class="line">                    mrr=on,mrr_cost_based=on,</span><br><span class="line">                    block_nested_loop=on,batched_key_access=off,</span><br><span class="line">                    materialization=on,semijoin=on,loosescan=on,</span><br><span class="line">                    firstmatch=on,</span><br><span class="line">                    subquery_materialization_cost_based=on,</span><br><span class="line">                    use_index_extensions=on,</span><br><span class="line">                    condition_fanout_filter=on</span><br></pre></td></tr></table></figure>

<h3 id="8-9-3优化器提示"><a href="#8-9-3优化器提示" class="headerlink" title="8.9.3优化器提示"></a>8.9.3优化器提示</h3><p>控制优化器的另一种方法是使用优化器提示，该提示可以在单个语句中指定。由于优化程序提示是基于每个语句应用的，因此它们提供了比使用更好的控制语句执行计划 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_optimizer_switch" target="_blank" rel="noopener"><code>optimizer_switch</code></a>。例如，您可以在语句中为一个表启用优化，而对另一表禁用优化。语句中的提示优先于 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_optimizer_switch" target="_blank" rel="noopener"><code>optimizer_switch</code></a>标志。</p>
<p>例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ NO_RANGE_OPTIMIZATION(t3 PRIMARY, f2_idx) */</span> f1</span><br><span class="line">  <span class="keyword">FROM</span> t3 <span class="keyword">WHERE</span> f1 &gt; <span class="number">30</span> <span class="keyword">AND</span> f1 &lt; <span class="number">33</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ BKA(t1) NO_BKA(t2) */</span> * <span class="keyword">FROM</span> t1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> t2 <span class="keyword">WHERE</span> ...;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ NO_ICP(t1, t2) */</span> * <span class="keyword">FROM</span> t1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> t2 <span class="keyword">WHERE</span> ...;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ SEMIJOIN(FIRSTMATCH, LOOSESCAN) */</span> * <span class="keyword">FROM</span> t1 ...;</span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> <span class="comment">/*+ NO_ICP(t1) */</span> * <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> ...;</span><br></pre></td></tr></table></figure>

<p>注意</p>
<p>默认情况下 ，<a href="https://dev.mysql.com/doc/refman/5.7/en/mysql.html" target="_blank" rel="noopener"><strong>MySQL</strong></a>客户端会剥离发送到服务器的SQL语句中的注释（包括优化程序提示），直到MySQL 5.7.7更改为将优化程序提示传递给服务器为止。如果使用的是较旧版本的<a href="https://dev.mysql.com/doc/refman/5.7/en/mysql.html" target="_blank" rel="noopener"><strong>mysql</strong></a>客户端和理解优化器提示的服务器版本，请确保不剥离 优化器提示，并使用 选项调用 <a href="https://dev.mysql.com/doc/refman/5.7/en/mysql.html" target="_blank" rel="noopener"><strong>mysql</strong></a><a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-command-options.html#option_mysql_comments" target="_blank" rel="noopener"><code>--comments</code></a>。</p>
<p>此处描述的优化器提示与<a href="https://dev.mysql.com/doc/refman/5.7/en/index-hints.html" target="_blank" rel="noopener">第8.9.4节“索引提示”中</a>描述的<a href="https://dev.mysql.com/doc/refman/5.7/en/index-hints.html" target="_blank" rel="noopener">索引提示不同</a>。优化程序和索引提示可以单独使用，也可以一起使用。</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-overview" target="_blank" rel="noopener">优化程序提示概述</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-syntax" target="_blank" rel="noopener">优化程序提示语法</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-table-level" target="_blank" rel="noopener">表级优化器提示</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-index-level" target="_blank" rel="noopener">索引级优化器提示</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-subquery" target="_blank" rel="noopener">子查询优化器提示</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-execution-time" target="_blank" rel="noopener">语句执行时间优化器提示</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-query-block-naming" target="_blank" rel="noopener">用于命名查询块的优化器提示</a></li>
</ul>
<h4 id="优化程序提示概述"><a href="#优化程序提示概述" class="headerlink" title="优化程序提示概述"></a>优化程序提示概述</h4><p>优化器提示适用于不同的作用域级别：</p>
<ul>
<li>全局：提示会影响整个语句</li>
<li>查询块：提示会影响语句中的特定查询块</li>
<li>表级别：提示会影响查询块中的特定表</li>
<li>索引级：提示会影响表中的特定索引</li>
</ul>
<p>下表总结了可用的优化器提示，它们影响的优化器策略以及它们应用的范围。稍后给出更多细节。</p>
<p><strong>表8.2可用的优化程序提示</strong></p>
<table>
<thead>
<tr>
<th>提示名称</th>
<th>描述</th>
<th>适用范围</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-table-level" target="_blank" rel="noopener"><code>BKA</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-table-level" target="_blank" rel="noopener"><code>NO_BKA</code></a></td>
<td>影响批量密钥访问联接处理</td>
<td>查询块，表</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-table-level" target="_blank" rel="noopener"><code>BNL</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-table-level" target="_blank" rel="noopener"><code>NO_BNL</code></a></td>
<td>影响块嵌套循环连接处理</td>
<td>查询块，表</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-execution-time" target="_blank" rel="noopener"><code>MAX_EXECUTION_TIME</code></a></td>
<td>限制语句执行时间</td>
<td>全球</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-index-level" target="_blank" rel="noopener"><code>MRR</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-index-level" target="_blank" rel="noopener"><code>NO_MRR</code></a></td>
<td>影响多范围读取优化</td>
<td>表，索引</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-index-level" target="_blank" rel="noopener"><code>NO_ICP</code></a></td>
<td>影响索引条件下推式优化</td>
<td>表，索引</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-index-level" target="_blank" rel="noopener"><code>NO_RANGE_OPTIMIZATION</code></a></td>
<td>影响范围优化</td>
<td>表，索引</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-query-block-naming" target="_blank" rel="noopener"><code>QB_NAME</code></a></td>
<td>为查询块分配名称</td>
<td>查询块</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-subquery" target="_blank" rel="noopener"><code>SEMIJOIN</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-subquery" target="_blank" rel="noopener"><code>NO_SEMIJOIN</code></a></td>
<td>影响半联接策略</td>
<td>查询块</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-subquery" target="_blank" rel="noopener"><code>SUBQUERY</code></a></td>
<td>影响物化， <code>IN</code>至- <code>EXISTS</code> 子查询配置的对策探讨</td>
<td>查询块</td>
</tr>
</tbody></table>
<p>禁用优化会阻止优化器使用它。启用优化意味着，如果优化器适用于语句执行，则它可以自由使用该策略，而不是优化器必然会使用它。</p>
<h4 id="优化程序提示语法"><a href="#优化程序提示语法" class="headerlink" title="优化程序提示语法"></a>优化程序提示语法</h4><p>MySQL支持SQL语句中的注释，如 <a href="https://dev.mysql.com/doc/refman/5.7/en/comments.html" target="_blank" rel="noopener">第9.6节“注释语法”中所述</a>。必须在<code>/*+ ... */</code>注释中指定优化程序提示。也就是说，优化程序提示使用<code>/* ... */</code> C样式注释语法的变体，并<code>+</code>在<code>/*</code>注释打开序列之后添加一个字符。例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*+ BKA(t1) */</span></span><br><span class="line"><span class="comment">/*+ BNL(t1, t2) */</span></span><br><span class="line"><span class="comment">/*+ NO_RANGE_OPTIMIZATION(t4 PRIMARY) */</span></span><br><span class="line"><span class="comment">/*+ QB_NAME(qb2) */</span></span><br></pre></td></tr></table></figure>

<p><code>+</code> 字符 后允许有空格。</p>
<p>解析器承认优化的初始关键字后暗示的意见<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/replace.html" target="_blank" rel="noopener"><code>REPLACE</code></a>，和 <a href="https://dev.mysql.com/doc/refman/5.7/en/delete.html" target="_blank" rel="noopener"><code>DELETE</code></a>语句。在以下情况下允许提示：</p>
<ul>
<li><p>在查询和数据更改语句的开头：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ ... */</span> ...</span><br><span class="line"><span class="keyword">INSERT</span> <span class="comment">/*+ ... */</span> ...</span><br><span class="line"><span class="keyword">REPLACE</span> <span class="comment">/*+ ... */</span> ...</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="comment">/*+ ... */</span> ...</span><br><span class="line"><span class="keyword">DELETE</span> <span class="comment">/*+ ... */</span> ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>在查询块的开头：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">SELECT</span> <span class="comment">/*+ ... */</span> ... )</span><br><span class="line">(<span class="keyword">SELECT</span> ... ) <span class="keyword">UNION</span> (<span class="keyword">SELECT</span> <span class="comment">/*+ ... */</span> ... )</span><br><span class="line">(<span class="keyword">SELECT</span> <span class="comment">/*+ ... */</span> ... ) <span class="keyword">UNION</span> (<span class="keyword">SELECT</span> <span class="comment">/*+ ... */</span> ... )</span><br><span class="line"><span class="keyword">UPDATE</span> ... <span class="keyword">WHERE</span> x <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="comment">/*+ ... */</span> ...)</span><br><span class="line"><span class="keyword">INSERT</span> ... <span class="keyword">SELECT</span> <span class="comment">/*+ ... */</span> ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>在以开头的暗示性声明中 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> <span class="comment">/*+ ... */</span> ...</span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">UPDATE</span> ... <span class="keyword">WHERE</span> x <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="comment">/*+ ... */</span> ...)</span><br></pre></td></tr></table></figure>

<p>这意味着您可以 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>用来查看优化器提示如何影响执行计划。<a href="https://dev.mysql.com/doc/refman/5.7/en/show-warnings.html" target="_blank" rel="noopener"><code>SHOW WARNINGS</code></a>之后立即使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a>以查看提示的使用方式。<code>EXPLAIN</code> 以下<a href="https://dev.mysql.com/doc/refman/5.7/en/show-warnings.html" target="_blank" rel="noopener"><code>SHOW WARNINGS</code></a>显示的扩展输出指示使用了哪些提示。不显示忽略的提示。</p>
</li>
</ul>
<p>提示注释可以包含多个提示，但是查询块不能包含多个提示注释。这是有效的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ BNL(t1) BKA(t2) */</span> ...</span><br></pre></td></tr></table></figure>

<p>但这是无效的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ BNL(t1) */</span> <span class="comment">/* BKA(t2) */</span> ...</span><br></pre></td></tr></table></figure>

<p>当提示注释包含多个提示时，存在重复和冲突的可能性。以下一般准则适用。对于特定的提示类型，可能会应用其他规则，如提示说明中所述。</p>
<ul>
<li>重复提示：对于诸如的提示<code>/*+ MRR(idx1) MRR(idx1) */</code>，MySQL使用第一个提示并发出有关重复提示的警告。</li>
<li>冲突的提示：对于诸如的提示<code>/*+ MRR(idx1) NO_MRR(idx1) */</code>，MySQL使用第一个提示，并发出有关第二个冲突的提示的警告。</li>
</ul>
<p>查询块名称是标识符，并遵循关于哪些名称有效以及如何引用它们的常规规则（请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/identifiers.html" target="_blank" rel="noopener">第9.2节“模式对象名称”</a>）。</p>
<p>提示名称，查询块名称和策略名称不区分大小写。对表和索引名称的引用遵循通常的标识符区分大小写规则（请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/identifier-case-sensitivity.html" target="_blank" rel="noopener">第9.2.3节“标识符区分大小写”</a>）。</p>
<h4 id="表级优化器提示"><a href="#表级优化器提示" class="headerlink" title="表级优化器提示"></a>表级优化器提示</h4><p>表级提示影响块嵌套循环（BNL）和批处理键访问（BKA）<a href="https://dev.mysql.com/doc/refman/5.7/en/bnl-bka-optimization.html" target="_blank" rel="noopener">联接</a>处理算法的使用（请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/bnl-bka-optimization.html" target="_blank" rel="noopener">第8.2.1.11节“块嵌套环和批处理键访问联接”</a>）。这些提示类型适用于特定表或查询块中的所有表。</p>
<p>表级提示的语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hint_name([@query_block_name] [tbl_name [, tbl_name] ...])</span><br><span class="line">hint_name([tbl_name@query_block_name [, tbl_name@query_block_name] ...])</span><br></pre></td></tr></table></figure>

<p>语法涉及以下术语：</p>
<ul>
<li><p><em>hint_name</em>：允许这些提示名称：</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-table-level" target="_blank" rel="noopener"><code>BKA</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-table-level" target="_blank" rel="noopener"><code>NO_BKA</code></a>：为指定的表启用或禁用BKA。</li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-table-level" target="_blank" rel="noopener"><code>BNL</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-table-level" target="_blank" rel="noopener"><code>NO_BNL</code></a>：为指定的表启用或禁用BNL。</li>
</ul>
<p>注意</p>
<p>若要使用BNL或BKA提示为外部联接的任何内部表启用联接缓冲，必须为外部联接的所有内部表启用联接缓冲。</p>
</li>
<li><p><em>tbl_name</em>：语句中使用的表的名称。提示适用于它命名的所有表。如果提示未命名表，则该提示将应用于出现该查询的查询块的所有表。</p>
<p>如果表具有别名，则提示必须引用别名，而不是表名称。</p>
<p>提示中的表名不能用架构名称限定。</p>
</li>
<li><p><em>query_block_name<em>：提示适用于的查询块。如果提示中不包含前导 ，则该提示适用于出现该查询的查询块。对于 语法，该提示适用于命名查询块中的命名表。要将名称分配给查询块，请参阅 <a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-query-block-naming" target="_blank" rel="noopener">命名查询块的优化器提示</a>。 `@</em>query_block_name<em>``</em>tbl_name</em>@<em>query_block_name</em>`</p>
</li>
</ul>
<p>例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ NO_BKA(t1, t2) */</span> t1.* <span class="keyword">FROM</span> t1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> t2 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> t3;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ NO_BNL() BKA(t1) */</span> t1.* <span class="keyword">FROM</span> t1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> t2 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> t3;</span><br></pre></td></tr></table></figure>

<p>表级提示适用于从先前的表而非发送方表接收记录的表。考虑以下语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ BNL(t2) */</span> <span class="keyword">FROM</span> t1, t2;</span><br></pre></td></tr></table></figure>

<p>如果优化器选择首先处理<code>t1</code> ，它将在开始读取之前 <code>t2</code>对行进行缓冲，从而将“块嵌套循环”联接应用于 该行 。如果优化程序选择先处理，则该提示无效，因为它是发送方表。 <code>t1``t2``t2``t2</code></p>
<h4 id="索引级优化器提示"><a href="#索引级优化器提示" class="headerlink" title="索引级优化器提示"></a>索引级优化器提示</h4><p>索引级提示会影响优化器针对特定表或索引使用的索引处理策略。这些提示类型会影响索引条件下推（ICP），多范围读取（MRR）和范围优化的使用（请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/select-optimization.html" target="_blank" rel="noopener">第8.2.1节“优化SELECT语句”</a>）。</p>
<p>索引级提示的语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hint_name([@query_block_name] tbl_name [index_name [, index_name] ...])</span><br><span class="line">hint_name(tbl_name@query_block_name [index_name [, index_name] ...])</span><br></pre></td></tr></table></figure>

<p>语法涉及以下术语：</p>
<ul>
<li><p><em>hint_name</em>：允许这些提示名称：</p>
<ul>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-index-level" target="_blank" rel="noopener"><code>MRR</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-index-level" target="_blank" rel="noopener"><code>NO_MRR</code></a>：启用或禁用指定表或索引的MRR。MRR提示仅适用于<code>InnoDB</code>和 <code>MyISAM</code>表。</p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-index-level" target="_blank" rel="noopener"><code>NO_ICP</code></a>：对指定的表或索引禁用ICP。默认情况下，ICP是一种候选优化策略，因此没有启用它的提示。</p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-index-level" target="_blank" rel="noopener"><code>NO_RANGE_OPTIMIZATION</code></a>：禁用指定表或索引的索引范围访问。此提示还禁用了表或索引的索引合并和松散索引扫描。默认情况下，范围访问是一种候选优化策略，因此没有启用它的提示。</p>
<p>当范围数可能很高并且范围优化将需要许多资源时，此提示可能会很有用。</p>
</li>
</ul>
</li>
<li><p><em>tbl_name</em>：提示适用的表格。</p>
</li>
<li><p><em>index_name</em>：命名表中索引的名称。提示适用于它命名的所有索引。如果提示未命名索引，则它将应用于表中的所有索引。</p>
<p>要引用主键，请使用名称 <code>PRIMARY</code>。要查看表的索引名称，请使用<a href="https://dev.mysql.com/doc/refman/5.7/en/show-index.html" target="_blank" rel="noopener"><code>SHOW INDEX</code></a>。</p>
</li>
<li><p><em>query_block_name<em>：提示适用于的查询块。如果提示中不包含前导 ，则该提示适用于出现该查询的查询块。对于 语法，该提示适用于命名查询块中的命名表。要将名称分配给查询块，请参阅 <a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-query-block-naming" target="_blank" rel="noopener">命名查询块的优化器提示</a>。 `@</em>query_block_name<em>``</em>tbl_name</em>@<em>query_block_name</em>`</p>
</li>
</ul>
<p>例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ MRR(t1) */</span> * <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> f2 &lt;= <span class="number">3</span> <span class="keyword">AND</span> <span class="number">3</span> &lt;= f3;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ NO_RANGE_OPTIMIZATION(t3 PRIMARY, f2_idx) */</span> f1</span><br><span class="line">  <span class="keyword">FROM</span> t3 <span class="keyword">WHERE</span> f1 &gt; <span class="number">30</span> <span class="keyword">AND</span> f1 &lt; <span class="number">33</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t3(f1, f2, f3)</span><br><span class="line">  (<span class="keyword">SELECT</span> <span class="comment">/*+ NO_ICP(t2) */</span> t2.f1, t2.f2, t2.f3 <span class="keyword">FROM</span> t1,t2</span><br><span class="line">   <span class="keyword">WHERE</span> t1.f1=t2.f1 <span class="keyword">AND</span> t2.f2 <span class="keyword">BETWEEN</span> t1.f1</span><br><span class="line">   <span class="keyword">AND</span> t1.f2 <span class="keyword">AND</span> t2.f2 + <span class="number">1</span> &gt;= t1.f1 + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h4 id="子查询优化器提示"><a href="#子查询优化器提示" class="headerlink" title="子查询优化器提示"></a>子查询优化器提示</h4><p>子查询提示会影响是否使用半联接转换以及允许使用的半联接策略，以及在不使用半联接时，是否使用子查询实现或 <code>IN</code>-to- <code>EXISTS</code> 转换。有关这些优化的更多信息，请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/subquery-optimization.html" target="_blank" rel="noopener">第8.2.2节“优化子查询，派生表和视图引用”</a>。</p>
<p>影响半联接策略的提示语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hint_name([@query_block_name] [strategy [, strategy] ...])</span><br></pre></td></tr></table></figure>

<p>语法涉及以下术语：</p>
<ul>
<li><p><em>hint_name</em>：允许这些提示名称：</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-subquery" target="_blank" rel="noopener"><code>SEMIJOIN</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-subquery" target="_blank" rel="noopener"><code>NO_SEMIJOIN</code></a>：启用或禁用命名的半联接策略。</li>
</ul>
</li>
<li><p><em>strategy</em>：要启用或禁用的半连接策略。这些策略名允许：<code>DUPSWEEDOUT</code>， <code>FIRSTMATCH</code>， <code>LOOSESCAN</code>， <code>MATERIALIZATION</code>。</p>
<p>对于<a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-subquery" target="_blank" rel="noopener"><code>SEMIJOIN</code></a>提示，如果未命名策略，则根据<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_optimizer_switch" target="_blank" rel="noopener"><code>optimizer_switch</code></a>系统变量启用的策略（如果可能）使用半联接 。如果策略已命名但不适用于该语句，<code>DUPSWEEDOUT</code>则使用。</p>
<p>对于<a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-subquery" target="_blank" rel="noopener"><code>NO_SEMIJOIN</code></a>提示，如果未命名策略，则不使用半联接。如果命名策略，则排除该语句的所有适用策略 <code>DUPSWEEDOUT</code>。</p>
</li>
</ul>
<p>如果一个子查询嵌套在另一个子查询中，并且两个子查询都合并到外部查询的半联接中，则将忽略最内部查询的任何半联接策略规范。 <a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-subquery" target="_blank" rel="noopener"><code>SEMIJOIN</code></a>并且 <a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-subquery" target="_blank" rel="noopener"><code>NO_SEMIJOIN</code></a>提示仍然可以用于启用或禁用此类嵌套子查询的半联接转换。</p>
<p>如果<code>DUPSWEEDOUT</code>已禁用，则有时优化器可能会生成一个远非最佳的查询计划。发生这种情况的原因是贪婪搜索期间的启发式修剪，可以通过设置来避免 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_optimizer_prune_level" target="_blank" rel="noopener"><code>optimizer_prune_level=0</code></a>。</p>
<p>例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ NO_SEMIJOIN(@subq1 FIRSTMATCH, LOOSESCAN) */</span> * <span class="keyword">FROM</span> t2</span><br><span class="line">  <span class="keyword">WHERE</span> t2.a <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="comment">/*+ QB_NAME(subq1) */</span> a <span class="keyword">FROM</span> t3);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ SEMIJOIN(@subq1 MATERIALIZATION, DUPSWEEDOUT) */</span> * <span class="keyword">FROM</span> t2</span><br><span class="line">  <span class="keyword">WHERE</span> t2.a <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="comment">/*+ QB_NAME(subq1) */</span> a <span class="keyword">FROM</span> t3);</span><br></pre></td></tr></table></figure>

<p>影响是否使用子查询实现或<code>IN</code>-to- <code>EXISTS</code> 转换的提示的语法 ：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBQUERY([@query_block_name] strategy)</span><br></pre></td></tr></table></figure>

<p>提示名称始终为 <a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-subquery" target="_blank" rel="noopener"><code>SUBQUERY</code></a>。</p>
<p>对于<a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-subquery" target="_blank" rel="noopener"><code>SUBQUERY</code></a>提示，可以使用以下 <em>strategy</em>值： <code>INTOEXISTS</code>， <code>MATERIALIZATION</code>。</p>
<p>例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, a <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="comment">/*+ SUBQUERY(MATERIALIZATION) */</span> a <span class="keyword">FROM</span> t1) <span class="keyword">FROM</span> t2;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t2 <span class="keyword">WHERE</span> t2.a <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="comment">/*+ SUBQUERY(INTOEXISTS) */</span> a <span class="keyword">FROM</span> t1);</span><br></pre></td></tr></table></figure>

<p>对于半联接和<a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-subquery" target="_blank" rel="noopener"><code>SUBQUERY</code></a> 提示，前导 指定提示适用于的查询块。如果提示中不包含前导 ，则该提示适用于出现该查询的查询块。要将名称分配给查询块，请参阅 <a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-query-block-naming" target="_blank" rel="noopener">命名查询块的优化器提示</a>。 <code>@*query_block_name*``@*query_block_name*</code></p>
<p>如果提示注释包含多个子查询提示，则使用第一个。如果还有其他以下类型的提示，则会产生警告。其他类型的以下提示将被忽略。</p>
<h4 id="语句执行时间优化器提示"><a href="#语句执行时间优化器提示" class="headerlink" title="语句执行时间优化器提示"></a>语句执行时间优化器提示</h4><p>该<a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-execution-time" target="_blank" rel="noopener"><code>MAX_EXECUTION_TIME</code></a>提示仅适用于<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a> 语句。它<em>N</em>为服务器终止该语句之前允许执行一条语句设置了一个限制（超时值（以毫秒为单位））：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAX_EXECUTION_TIME(N)</span><br></pre></td></tr></table></figure>

<p>超时为1秒（1000毫秒）的示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ MAX_EXECUTION_TIME(1000) */</span> * <span class="keyword">FROM</span> t1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> t2 <span class="keyword">WHERE</span> ...</span><br></pre></td></tr></table></figure>

<p>该 提示设置的语句执行超时 毫秒。如果此选项不存在或为0，则应用系统变量建立的语句超时 。 <a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-execution-time" target="_blank" rel="noopener"><code>MAX_EXECUTION_TIME(*N*)</code></a><em>N**N</em><a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_max_execution_time" target="_blank" rel="noopener"><code>max_execution_time</code></a></p>
<p>该<a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-execution-time" target="_blank" rel="noopener"><code>MAX_EXECUTION_TIME</code></a>提示适用于以下情况：</p>
<ul>
<li>对于具有多个<code>SELECT</code> 关键字的语句，例如并集或带有子查询的语句， <a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-execution-time" target="_blank" rel="noopener"><code>MAX_EXECUTION_TIME</code></a> 将应用于整个语句，并且必须出现在第一个之后<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>。</li>
<li>它适用于只读 <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>语句。非只读的语句是那些调用存储函数修改数据的副作用的语句。</li>
<li>它不适用于<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a> 存储程序中的语句，将被忽略。</li>
</ul>
<h4 id="用于命名查询块的优化器提示"><a href="#用于命名查询块的优化器提示" class="headerlink" title="用于命名查询块的优化器提示"></a>用于命名查询块的优化器提示</h4><p>表级，索引级和子查询优化器提示允许将特定查询块命名为其参数语法的一部分。要创建这些名称，请使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-query-block-naming" target="_blank" rel="noopener"><code>QB_NAME</code></a>提示，该提示将名称分配给出现该名称的查询块：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QB_NAME(name)</span><br></pre></td></tr></table></figure>

<p><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-query-block-naming" target="_blank" rel="noopener"><code>QB_NAME</code></a>提示可用于以明确的方式使之明确，哪些查询将阻止其他提示应用于该查询。它们还允许在单个提示注释中指定所有非查询块名称提示，以便于理解复杂的语句。考虑以下语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ...</span><br><span class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> ...</span><br><span class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ...)) ...</span><br></pre></td></tr></table></figure>

<p><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-query-block-naming" target="_blank" rel="noopener"><code>QB_NAME</code></a> 提示为语句中的查询块分配名称：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ QB_NAME(qb1) */</span> ...</span><br><span class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="comment">/*+ QB_NAME(qb2) */</span> ...</span><br><span class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="comment">/*+ QB_NAME(qb3) */</span> ... <span class="keyword">FROM</span> ...)) ...</span><br></pre></td></tr></table></figure>

<p>然后其他提示可以使用这些名称来引用适当的查询块：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ QB_NAME(qb1) MRR(@qb1 t1) BKA(@qb2) NO_MRR(@qb3t1 idx1, id2) */</span> ...</span><br><span class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="comment">/*+ QB_NAME(qb2) */</span> ...</span><br><span class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="comment">/*+ QB_NAME(qb3) */</span> ... <span class="keyword">FROM</span> ...)) ...</span><br></pre></td></tr></table></figure>

<p>产生的效果如下：</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-index-level" target="_blank" rel="noopener"><code>MRR(@qb1 t1)</code></a>适用<code>t1</code>于查询块中的 表<code>qb1</code>。</li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-table-level" target="_blank" rel="noopener"><code>BKA(@qb2)</code></a>适用于查询块<code>qb2</code>。</li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-index-level" target="_blank" rel="noopener"><code>NO_MRR(@qb3 t1 idx1, id2)</code></a>适用于索引<code>idx1</code> 和 查询块<code>idx2</code>中的表。 <code>t1``qb3</code></li>
</ul>
<p>查询块名称是标识符，并遵循关于哪些名称有效以及如何引用它们的常规规则（请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/identifiers.html" target="_blank" rel="noopener">第9.2节“模式对象名称”</a>）。例如，必须引用包含空格的查询块名称，这可以使用反引号来完成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ BKA(@`my hint name`) */</span> ...</span><br><span class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="comment">/*+ QB_NAME(`my hint name`) */</span> ...) ...</span><br></pre></td></tr></table></figure>

<p>如果<a href="https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html#sqlmode_ansi_quotes" target="_blank" rel="noopener"><code>ANSI_QUOTES</code></a>启用了SQL模式，则还可以在双引号中用引号引起来的查询块名称：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ BKA(@"my hint name") */</span> ...</span><br><span class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="comment">/*+ QB_NAME("my hint name") */</span> ...) ...</span><br></pre></td></tr></table></figure>

<h3 id="8-9-4索引提示"><a href="#8-9-4索引提示" class="headerlink" title="8.9.4索引提示"></a>8.9.4索引提示</h3><p>索引提示仅适用于<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a> 和<a href="https://dev.mysql.com/doc/refman/5.7/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a>语句。</p>
<p>在表名后指定索引提示。（有关在语句中指定表的一般语法 <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/join.html" target="_blank" rel="noopener">第13.2.9.2节“ JOIN子句”</a>。）引用单个表（包括索引提示）的语法如下所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tbl_name [[AS] alias] [index_hint_list]</span><br><span class="line"></span><br><span class="line">index_hint_list:</span><br><span class="line">    index_hint [index_hint] ...</span><br><span class="line"></span><br><span class="line">index_hint:</span><br><span class="line">    <span class="keyword">USE</span> &#123;<span class="keyword">INDEX</span>|<span class="keyword">KEY</span>&#125;</span><br><span class="line">      [<span class="keyword">FOR</span> &#123;<span class="keyword">JOIN</span>|<span class="keyword">ORDER</span> <span class="keyword">BY</span>|<span class="keyword">GROUP</span> <span class="keyword">BY</span>&#125;] ([index_list])</span><br><span class="line">  | &#123;<span class="keyword">IGNORE</span>|<span class="keyword">FORCE</span>&#125; &#123;<span class="keyword">INDEX</span>|<span class="keyword">KEY</span>&#125;</span><br><span class="line">      [<span class="keyword">FOR</span> &#123;<span class="keyword">JOIN</span>|<span class="keyword">ORDER</span> <span class="keyword">BY</span>|<span class="keyword">GROUP</span> <span class="keyword">BY</span>&#125;] (index_list)</span><br><span class="line"></span><br><span class="line">index_list:</span><br><span class="line">    index_name [, index_name] ...</span><br></pre></td></tr></table></figure>

<p>该提示告诉MySQL仅使用命名索引之一来查找表中的行。替代语法告诉MySQL不要使用某些特定的索引。如果显示MySQL使用的索引可能不正确，则这些提示很有用。 <code>USE INDEX (*index_list*)``IGNORE INDEX (*index_list*)</code><a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a></p>
<p>该<code>FORCE INDEX</code>提示的作用就像，增加表扫描被认为是 <em>非常<em>昂贵的。换句话说，仅当无法使用命名索引之一在表中查找行时才使用表扫描。 `USE INDEX (</em>index_list</em>)`</p>
<p>每个提示都需要索引名称，而不是列名称。要引用主键，请使用名称<code>PRIMARY</code>。要查看表的索引名称，请使用<a href="https://dev.mysql.com/doc/refman/5.7/en/show-index.html" target="_blank" rel="noopener"><code>SHOW INDEX</code></a>语句或 <a href="https://dev.mysql.com/doc/refman/5.7/en/statistics-table.html" target="_blank" rel="noopener"><code>INFORMATION_SCHEMA.STATISTICS</code></a> 表。</p>
<p>的<em>index_name</em>价值不一定是完整的索引名。它可以是索引名称的明确前缀。如果前缀不明确，则会发生错误。</p>
<p>例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table1 <span class="keyword">USE</span> <span class="keyword">INDEX</span> (col1_index,col2_index)</span><br><span class="line">  <span class="keyword">WHERE</span> col1=<span class="number">1</span> <span class="keyword">AND</span> col2=<span class="number">2</span> <span class="keyword">AND</span> col3=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table1 <span class="keyword">IGNORE</span> <span class="keyword">INDEX</span> (col3_index)</span><br><span class="line">  <span class="keyword">WHERE</span> col1=<span class="number">1</span> <span class="keyword">AND</span> col2=<span class="number">2</span> <span class="keyword">AND</span> col3=<span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>索引提示的语法具有以下特征：</p>
<ul>
<li><p>省略语法上是有效 <em>index_list</em>的<code>USE INDEX</code>，这意味着“不使用索引。” 省略<em>index_list</em>的 <code>FORCE INDEX</code>或者<code>IGNORE INDEX</code>是一个语法错误。</p>
</li>
<li><p>您可以通过<code>FOR</code>在提示中添加一个子句来指定索引提示的范围 。这为查询处理的各个阶段提供了对执行计划的优化器选择的更细粒度控制。要仅影响MySQL决定如何在表中查找行以及如何处理联接时使用的索引，请使用<code>FOR JOIN</code>。要影响索引对行进行排序或分组的用法，请使用<code>FOR ORDER BY</code>或 <code>FOR GROUP BY</code>。</p>
</li>
<li><p>您可以指定多个索引提示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 <span class="keyword">USE</span> <span class="keyword">INDEX</span> (i1) <span class="keyword">IGNORE</span> <span class="keyword">INDEX</span> <span class="keyword">FOR</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> (i2) <span class="keyword">ORDER</span> <span class="keyword">BY</span> a;</span><br></pre></td></tr></table></figure>

<p>在多个提示中命名相同的索引（即使在同一提示中）也不是错误：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 <span class="keyword">USE</span> <span class="keyword">INDEX</span> (i1) <span class="keyword">USE</span> <span class="keyword">INDEX</span> (i1,i1);</span><br></pre></td></tr></table></figure>

<p>但是，它是混合错误<code>USE INDEX</code> 和<code>FORCE INDEX</code>同一个表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 <span class="keyword">USE</span> <span class="keyword">INDEX</span> <span class="keyword">FOR</span> <span class="keyword">JOIN</span> (i1) <span class="keyword">FORCE</span> <span class="keyword">INDEX</span> <span class="keyword">FOR</span> <span class="keyword">JOIN</span> (i2);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>如果索引提示不包含任何<code>FOR</code>子句，则提示的范围将应用于语句的所有部分。例如，以下提示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IGNORE INDEX (i1)</span><br></pre></td></tr></table></figure>

<p>等效于以下提示组合：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IGNORE INDEX FOR JOIN (i1)</span><br><span class="line">IGNORE INDEX FOR ORDER BY (i1)</span><br><span class="line">IGNORE INDEX FOR GROUP BY (i1)</span><br></pre></td></tr></table></figure>

<p>在MySQL 5.0中，没有<code>FOR</code>子句的提示作用域仅适用于行检索。若要在不存在<code>FOR</code>子句时使服务器使用此较旧的行为，请<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_old" target="_blank" rel="noopener"><code>old</code></a>在服务器启动时启用系统变量。请注意在复制设置中启用此变量。使用基于语句的二进制日志记录，对主服务器和从服务器使用不同的模式可能会导致复制错误。</p>
<p>当索引提示进行处理，它们被收集在由类型的单个列表（<code>USE</code>，<code>FORCE</code>， <code>IGNORE</code>）和范围（<code>FOR JOIN</code>，<code>FOR ORDER BY</code>，<code>FOR GROUP BY</code>）。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1</span><br><span class="line">  <span class="keyword">USE</span> <span class="keyword">INDEX</span> () <span class="keyword">IGNORE</span> <span class="keyword">INDEX</span> (i2) <span class="keyword">USE</span> <span class="keyword">INDEX</span> (i1) <span class="keyword">USE</span> <span class="keyword">INDEX</span> (i2);</span><br></pre></td></tr></table></figure>

<p>等效于：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1</span><br><span class="line">   <span class="keyword">USE</span> <span class="keyword">INDEX</span> (i1,i2) <span class="keyword">IGNORE</span> <span class="keyword">INDEX</span> (i2);</span><br></pre></td></tr></table></figure>

<p>然后按以下顺序将索引提示应用于每个范围：</p>
<ol>
<li><p><code>{USE|FORCE} INDEX</code>如果存在，则应用。（如果不是，则使用优化程序确定的索引集。）</p>
</li>
<li><p><code>IGNORE INDEX</code>将应用于上一步的结果。例如，以下两个查询是等效的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 <span class="keyword">USE</span> <span class="keyword">INDEX</span> (i1) <span class="keyword">IGNORE</span> <span class="keyword">INDEX</span> (i2) <span class="keyword">USE</span> <span class="keyword">INDEX</span> (i2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1 <span class="keyword">USE</span> <span class="keyword">INDEX</span> (i1);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>对于<code>FULLTEXT</code>搜索，索引提示的工作方式如下：</p>
<ul>
<li><p>对于自然语言模式搜索，将无提示地忽略索引提示。例如，<code>IGNORE INDEX(i1)</code>在没有警告的情况下被忽略，并且索引仍在使用。</p>
</li>
<li><p>对于布尔模式搜索，带有<code>FOR ORDER BY</code>或的索引提示将<code>FOR GROUP BY</code>被静默忽略。索引提示带有<code>FOR JOIN</code>或不带有<code>FOR</code>修饰符。与提示如何应用于非<code>FULLTEXT</code>搜索相反，该提示用于查询执行的所有阶段（查找行和检索，分组和排序）。即使为非<code>FULLTEXT</code>索引给出了提示，也是如此。</p>
<p>例如，以下两个查询是等效的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t</span><br><span class="line">  <span class="keyword">USE</span> <span class="keyword">INDEX</span> (index1)</span><br><span class="line">  <span class="keyword">IGNORE</span> <span class="keyword">INDEX</span> (index1) <span class="keyword">FOR</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">  <span class="keyword">IGNORE</span> <span class="keyword">INDEX</span> (index1) <span class="keyword">FOR</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">  <span class="keyword">WHERE</span> ... <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">MODE</span> ... ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t</span><br><span class="line">  <span class="keyword">USE</span> <span class="keyword">INDEX</span> (index1)</span><br><span class="line">  <span class="keyword">WHERE</span> ... <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">MODE</span> ... ;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="8-9-5优化器成本模型"><a href="#8-9-5优化器成本模型" class="headerlink" title="8.9.5优化器成本模型"></a>8.9.5优化器成本模型</h3><p>优化器还有一个成本估算数据库，可在执行计划构建期间使用。这些估算值存储在系统数据库的<code>server_cost</code>和 <code>engine_cost</code>表中， <code>mysql</code>并且可以随时配置。这些表的目的是使得可以轻松调整优化器在尝试得出查询执行计划时使用的成本估算。</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/cost-model.html#cost-model-operation" target="_blank" rel="noopener">成本模型一般运作</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/cost-model.html#cost-model-database" target="_blank" rel="noopener">成本模型数据库</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/cost-model.html#cost-model-database-modifications" target="_blank" rel="noopener">更改成本模型数据库</a></li>
</ul>
<h4 id="成本模型一般运作"><a href="#成本模型一般运作" class="headerlink" title="成本模型一般运作"></a>成本模型一般运作</h4><p>可配置的优化器成本模型的工作方式如下：</p>
<ul>
<li>服务器在启动时将成本模型表读取到内存中，并在运行时使用内存中的值。<code>NULL</code>表中指定的任何非成本估算值都优先于相应的已编译默认成本常量。任何<code>NULL</code> 估计值都指示优化器使用编译后的默认值。</li>
<li>在运行时，服务器可以重新读取成本表。当动态加载存储引擎或<a href="https://dev.mysql.com/doc/refman/5.7/en/flush.html#flush-optimizer-costs" target="_blank" rel="noopener"><code>FLUSH OPTIMIZER_COSTS</code></a> 执行语句时，会发生这种情况。</li>
<li>成本表使服务器管理员可以通过更改表中的条目轻松调整成本估算。通过将条目的费用设置为，也很容易恢复为默认值<code>NULL</code>。优化器使用内存中的成本值，因此对表所做的更改应 <a href="https://dev.mysql.com/doc/refman/5.7/en/flush.html#flush-optimizer-costs" target="_blank" rel="noopener"><code>FLUSH OPTIMIZER_COSTS</code></a>生效。</li>
<li>客户会话开始时当前的内存中成本估算将在整个会话中应用，直到结束。特别是，如果服务器重新读取成本表，则任何更改的估算值仅适用于随后启动的会话。现有会话不受影响。</li>
<li>成本表特定于给定的服务器实例。服务器不会将成本表更改复制到复制从属服务器。</li>
</ul>
<h4 id="成本模型数据库"><a href="#成本模型数据库" class="headerlink" title="成本模型数据库"></a>成本模型数据库</h4><p>优化器成本模型数据库由<code>mysql</code>系统数据库中的两个表组成，其中包含查询执行期间发生的操作的成本估算信息：</p>
<ul>
<li><code>server_cost</code>：针对一般服务器操作的优化器成本估算</li>
<li><code>engine_cost</code>：针对特定存储引擎的运营的优化器成本估算</li>
</ul>
<p>该<code>server_cost</code>表包含以下列：</p>
<ul>
<li><p><code>cost_name</code></p>
<p>成本模型中使用的成本估算的名称。名称不区分大小写。如果服务器在读取此表时无法识别成本名称，则会向错误日志中写入警告。</p>
</li>
<li><p><code>cost_value</code></p>
<p>成本估算值。如果该值为non- <code>NULL</code>，则服务器将其用作成本。否则，它将使用默认估计值（编译值）。DBA可以通过更新此列来更改成本估算。如果服务器在读取此表时发现成本值无效（非正值），则会向错误日志中写入警告。</p>
<p>要覆盖默认费用估算值（对于指定的条目<code>NULL</code>），请将费用设置为非<code>NULL</code>值。要恢复为默认值，请将值设置为<code>NULL</code>。然后执行<a href="https://dev.mysql.com/doc/refman/5.7/en/flush.html#flush-optimizer-costs" target="_blank" rel="noopener"><code>FLUSH OPTIMIZER_COSTS</code></a>以告知服务器重新读取成本表。</p>
</li>
<li><p><code>last_update</code></p>
<p>最后一行的更新时间。</p>
</li>
<li><p><code>comment</code></p>
<p>与成本估算相关的描述性注释。DBA可以使用此列来提供有关为什么成本估算行存储特定值的信息。</p>
</li>
</ul>
<p>该<code>server_cost</code>表的主键是该<code>cost_name</code>列，因此无法为任何成本估算创建多个条目。</p>
<p>服务器识别表的这些<code>cost_name</code> 值<code>server_cost</code>：</p>
<ul>
<li><p><code>disk_temptable_create_cost</code>（预设40.0），<code>disk_temptable_row_cost</code>（预设1.0）</p>
<p>在基于磁盘的存储引擎（<code>InnoDB</code>或<code>MyISAM</code>）中存储的内部创建的临时表的成本估算 。增加这些值会增加使用内部临时表的成本估算，并使优化器更喜欢较少使用它们的查询计划。有关此类表的信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/internal-temporary-tables.html" target="_blank" rel="noopener">第8.4.4节“ MySQL中的内部临时表使用”</a>。</p>
<p>对于相比于相应的存储器参数的缺省值，这些磁盘参数较大的默认值（<code>memory_temptable_create_cost</code>， <code>memory_temptable_row_cost</code>）反映处理的基于磁盘的表的更高的成本。</p>
</li>
<li><p><code>key_compare_cost</code> （默认为0.1）</p>
</li>
</ul>
<p>  比较记录键的成本。增加此值将导致查询计划比较多个键变得更加昂贵。例如，<code>filesort</code>与避免使用索引进行排序的查询计划相比，执行的查询计划 变得相对昂贵。</p>
<ul>
<li><p><code>memory_temptable_create_cost</code>（默认2.0），<code>memory_temptable_row_cost</code> （默认0.2）</p>
<p><code>MEMORY</code>存储引擎中 内部创建的临时表的成本估算。增加这些值会增加使用内部临时表的成本估算，并使优化器更喜欢较少使用它们的查询计划。有关此类表的信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/internal-temporary-tables.html" target="_blank" rel="noopener">第8.4.4节“ MySQL中的内部临时表使用”</a>。</p>
<p>与相应磁盘参数的默认值（）相比，这些内存参数的默认值较小<code>disk_temptable_create_cost</code>， <code>disk_temptable_row_cost</code>反映了处理基于内存的表的成本较低。</p>
</li>
<li><p><code>row_evaluate_cost</code> （默认0.2）</p>
<p>评估记录条件的成本。与检查行数较少的查询计划相比，增加该值会导致检查许多行的查询计划变得更加昂贵。例如，与读取较少行的范围扫描相比，表扫描变得相对昂贵。</p>
</li>
</ul>
<p>该<code>engine_cost</code>表包含以下列：</p>
<ul>
<li><p><code>engine_name</code></p>
<p>此成本估算适用的存储引擎的名称。名称不区分大小写。如果值为 <code>default</code>，则适用于所有没有自己命名条目的存储引擎。如果服务器在读取该表时无法识别引擎名称，则会向错误日志中写入警告。</p>
</li>
<li><p><code>device_type</code></p>
<p>此费用估算适用的设备类型。该列旨在为不同的存储设备类型（例如，硬盘驱动器与固态驱动器）指定不同的成本估算。当前，此信息未使用，并且0是唯一允许的值。</p>
</li>
<li><p><code>cost_name</code></p>
<p>与<code>server_cost</code>表相同。</p>
</li>
<li><p><code>cost_value</code></p>
<p>与<code>server_cost</code>表相同。</p>
</li>
<li><p><code>last_update</code></p>
<p>与<code>server_cost</code>表相同。</p>
</li>
<li><p><code>comment</code></p>
<p>与<code>server_cost</code>表相同。</p>
</li>
</ul>
<p>对于主键<code>engine_cost</code>表是包含（一个元组<code>cost_name</code>， <code>engine_name</code>， <code>device_type</code>）个列，所以它不可能在这些列中的值的任意组合来创建多个条目。</p>
<p>服务器识别表的这些<code>cost_name</code> 值<code>engine_cost</code>：</p>
<ul>
<li><p><code>io_block_read_cost</code> （默认为1.0）</p>
<p>从磁盘读取索引或数据块的成本。与读取较少磁盘块的查询计划相比，增加该值会使读取许多磁盘块的查询计划变得更加昂贵。例如，与读取较少块的范围扫描相比，表扫描变得相对昂贵。</p>
</li>
<li><p><code>memory_block_read_cost</code> （默认为1.0）</p>
<p>与相似<code>io_block_read_cost</code>，但是代表从内存数据库缓冲区读取索引或数据块的成本。</p>
</li>
</ul>
<p>如果<code>io_block_read_cost</code>和 <code>memory_block_read_cost</code>值不同，则执行计划可能会在同一查询的两次运行之间改变。假设内存访问的成本小于磁盘访问的成本。在这种情况下，在服务器启动之前，将数据读入缓冲池之前，您可能会获得与运行查询之后不同的计划，因为这样数据就会存储在内存中。</p>
<h4 id="更改成本模型数据库"><a href="#更改成本模型数据库" class="headerlink" title="更改成本模型数据库"></a>更改成本模型数据库</h4><p>对于希望从其默认值更改成本模型参数的DBA，请尝试将该值加倍或减半并测量效果。</p>
<p><code>io_block_read_cost</code>和 <code>memory_block_read_cost</code>参数的 更改最有可能产生有价值的结果。这些参数值使数据访问方法的成本模型可以考虑从不同来源读取信息的成本。也就是说，从磁盘读取信息的成本与读取内存缓冲区中已经存在的信息的成本。例如，在所有其他条件都相同的情况下，将其设置 <code>io_block_read_cost</code>为大于 <code>memory_block_read_cost</code>会导致优化器更喜欢查询计划，该计划读取已保存在内存中的信息，而不是必须从磁盘读取的计划。</p>
<p>本示例说明如何更改以下项的默认值 <code>io_block_read_cost</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> mysql.engine_cost</span><br><span class="line">  <span class="keyword">SET</span> cost_value = <span class="number">2.0</span></span><br><span class="line">  <span class="keyword">WHERE</span> cost_name = <span class="string">'io_block_read_cost'</span>;</span><br><span class="line"><span class="keyword">FLUSH</span> OPTIMIZER_COSTS;</span><br></pre></td></tr></table></figure>

<p>此示例说明如何更改<code>io_block_read_cost</code>仅 <code>InnoDB</code>存储引擎的值 ：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mysql.engine_cost</span><br><span class="line">  <span class="keyword">VALUES</span> (<span class="string">'InnoDB'</span>, <span class="number">0</span>, <span class="string">'io_block_read_cost'</span>, <span class="number">3.0</span>,</span><br><span class="line">  <span class="keyword">CURRENT_TIMESTAMP</span>, <span class="string">'Using a slower disk for InnoDB'</span>);</span><br><span class="line"><span class="keyword">FLUSH</span> OPTIMIZER_COSTS;</span><br></pre></td></tr></table></figure>

<h2 id="8-10缓冲和缓存"><a href="#8-10缓冲和缓存" class="headerlink" title="8.10缓冲和缓存"></a>8.10缓冲和缓存</h2><ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool-optimization.html" target="_blank" rel="noopener">8.10.1 InnoDB缓冲池优化</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/myisam-key-cache.html" target="_blank" rel="noopener">8.10.2 MyISAM密钥缓存</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/query-cache.html" target="_blank" rel="noopener">8.10.3 MySQL查询缓存</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/statement-caching.html" target="_blank" rel="noopener">8.10.4缓存准备好的语句和存储的程序</a></li>
</ul>
<p>MySQL使用多种策略将信息缓存在内存缓冲区中以提高性能。</p>
<h3 id="8-10-1-InnoDB缓冲池优化"><a href="#8-10-1-InnoDB缓冲池优化" class="headerlink" title="8.10.1 InnoDB缓冲池优化"></a>8.10.1 InnoDB缓冲池优化</h3><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html" target="_blank" rel="noopener"><code>InnoDB</code></a>维护一个称为<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_buffer_pool" target="_blank" rel="noopener">缓冲池</a>的存储区， 用于在内存中缓存数据和索引。了解 <code>InnoDB</code>缓冲池的工作方式，并利用其将经常访问的数据保留在内存中，是MySQL调优的重要方面。</p>
<p>有关<code>InnoDB</code>缓冲池内部工作的说明， 其LRU替换算法的概述以及常规配置信息，请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool.html" target="_blank" rel="noopener">第14.5.1节“缓冲池”</a>。</p>
<p>有关其他<code>InnoDB</code>缓冲池配置和调整信息，请参阅以下部分：</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-read_ahead.html" target="_blank" rel="noopener">第14.8.3.4节“配置InnoDB缓冲池预取（预读）”</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool-flushing.html" target="_blank" rel="noopener">第14.8.3.5节“配置缓冲池刷新”</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-midpoint_insertion.html" target="_blank" rel="noopener">第14.8.3.3节“使缓冲池扫描具有抵抗力”</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-multiple-buffer-pools.html" target="_blank" rel="noopener">第14.8.3.2节“配置多个缓冲池实例”</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-preload-buffer-pool.html" target="_blank" rel="noopener">第14.8.3.6节“保存和恢复缓冲池状态”</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool-resize.html" target="_blank" rel="noopener">第14.8.3.1节“配置InnoDB缓冲池大小”</a></li>
</ul>
<h3 id="8-10-2-MyISAM密钥缓存"><a href="#8-10-2-MyISAM密钥缓存" class="headerlink" title="8.10.2 MyISAM密钥缓存"></a>8.10.2 MyISAM密钥缓存</h3><ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/shared-key-cache.html" target="_blank" rel="noopener">8.10.2.1共享密钥缓存访问</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/multiple-key-caches.html" target="_blank" rel="noopener">8.10.2.2多个键缓存</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/midpoint-insertion.html" target="_blank" rel="noopener">8.10.2.3中点插入策略</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/index-preloading.html" target="_blank" rel="noopener">8.10.2.4索引预加载</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/key-cache-block-size.html" target="_blank" rel="noopener">8.10.2.5密钥缓存块大小</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/key-cache-restructuring.html" target="_blank" rel="noopener">8.10.2.6重构密钥缓存</a></li>
</ul>
<ul>
<li>对于索引块，维护了一种称为键缓存（或 键缓冲区）的特殊结构 。该结构包含许多块缓冲区，在这些缓冲区中放置了最常用的索引块。</li>
<li>对于数据块，MySQL不使用特殊的缓存。相反，它依赖于本机操作系统文件系统缓存。</li>
</ul>
<p>本节首先介绍<code>MyISAM</code>密钥缓存的基本操作 。然后讨论了可以提高关键高速缓存性能并使您更好地控制高速缓存操作的功能：</p>
<ul>
<li>多个会话可以同时访问缓存。</li>
<li>您可以设置多个键高速缓存，并将表索引分配给特定的高速缓存。</li>
</ul>
<p>要控制键高速缓存的大小，请使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_key_buffer_size" target="_blank" rel="noopener"><code>key_buffer_size</code></a>系统变量。如果将此变量设置为零，则不使用键缓存。如果该<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_key_buffer_size" target="_blank" rel="noopener"><code>key_buffer_size</code></a>值太小而无法分配最小数量的块缓冲区（8），则也不使用键高速缓存 。</p>
<p>当键高速缓存不可用时，仅使用操作系统提供的本机文件系统缓冲来访问索引文件。（换句话说，使用与表数据块相同的策略访问表索引块。）</p>
<p>索引块是对<code>MyISAM</code>索引文件的连续访问单元 。通常，索引块的大小等于索引B树的节点的大小。（索引在磁盘上使用B树数据结构表示。树底部的节点是叶节点。叶节点上方的节点是非叶节点。）</p>
<p>密钥高速缓存结构中的所有块缓冲区的大小均相同。该大小可以等于，大于或小于表索引块的大小。通常，这两个值之一是另一个的倍数。</p>
<p>当必须访问任何表索引块中的数据时，服务器首先检查键高速缓存的某些块缓冲区中是否可用。如果是这样，服务器将访问密钥缓存中的数据，而不是磁盘上的数据。也就是说，它从缓存中读取或写入缓存，而不是从磁盘读取或写入磁盘。否则，服务器将选择一个包含另一个表索引块的缓存块缓冲区，并用所需表索引块的副本替换那里的数据。一旦新的索引块位于缓存中，就可以访问索引数据。</p>
<p>如果碰巧选中了要替换的块，则该块被视为“ 脏”。”在这种情况下，之前被取代时，其内容被刷新到它所来自的表索引。</p>
<p>通常，服务器遵循LRU（最近最少使用）策略：选择要替换的块时，它会选择最近最少使用的索引块。为了使选择更加容易，密钥缓存模块将所有使用的块维护在按使用时间排序的特殊列表（LRU链）中。当访问一个块时，它是最近使用的块，并位于列表的末尾。当需要替换块时，列表开头的块是最近最少使用的块，成为驱逐的第一个候选者。</p>
<p>该<code>InnoDB</code>存储引擎还采用LRU算法来管理它的缓冲池。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool.html" target="_blank" rel="noopener">第14.5.1节“缓冲池”</a>。</p>
<h4 id="8-10-2-1共享密钥缓存访问"><a href="#8-10-2-1共享密钥缓存访问" class="headerlink" title="8.10.2.1共享密钥缓存访问"></a>8.10.2.1共享密钥缓存访问</h4><p>在满足以下条件的前提下，线程可以同时访问键高速缓存缓冲区：</p>
<ul>
<li>多个会话可以访问未更新的缓冲区。</li>
<li>正在更新的缓冲区会导致需要使用它的会话等待更新完成。</li>
<li>多个会话可以发起导致缓存块替换的请求，只要它们彼此不干扰（也就是说，只要它们需要不同的索引块，从而导致替换不同的缓存块）即可。</li>
</ul>
<p>对密钥缓存的共享访问使服务器可以显着提高吞吐量。</p>
<h4 id="8-10-2-2多个键缓存"><a href="#8-10-2-2多个键缓存" class="headerlink" title="8.10.2.2多个键缓存"></a>8.10.2.2多个键缓存</h4><p>对密钥缓存的共享访问可以提高性能，但不能完全消除会话之间的争用。他们仍在争夺管理对键高速缓存缓冲区的访问的控制结构。为了进一步减少密钥缓存访问争用，MySQL还提供了多个密钥缓存。此功能使您可以将不同的表索引分配给不同的键高速缓存。</p>
<p>如果有多个键缓存，则服务器必须知道在处理给定<code>MyISAM</code>表的查询时要使用哪个缓存 。默认情况下，所有 <code>MyISAM</code>表索引都缓存在默认键缓存中。要将表索引分配给特定的键高速缓存，请使用该<a href="https://dev.mysql.com/doc/refman/5.7/en/cache-index.html" target="_blank" rel="noopener"><code>CACHE INDEX</code></a> 语句（请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/cache-index.html" target="_blank" rel="noopener">第13.7.6.2节“ CACHE INDEX语句”</a>）。例如，从表中下面的语句受让人指标 <code>t1</code>，<code>t2</code>以及 <code>t3</code>向键缓存命名为 <code>hot_cache</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CACHE INDEX t1, t2, t3 IN hot_cache;</span><br><span class="line">+<span class="comment">---------+--------------------+----------+----------+</span></span><br><span class="line">| Table   | Op                 | Msg_type | Msg_text |</span><br><span class="line">+<span class="comment">---------+--------------------+----------+----------+</span></span><br><span class="line">| test.t1 | assign_to_keycache | status   | OK       |</span><br><span class="line">| test.t2 | assign_to_keycache | status   | OK       |</span><br><span class="line">| test.t3 | assign_to_keycache | status   | OK       |</span><br><span class="line">+<span class="comment">---------+--------------------+----------+----------+</span></span><br></pre></td></tr></table></figure>

<p><a href="https://dev.mysql.com/doc/refman/5.7/en/cache-index.html" target="_blank" rel="noopener"><code>CACHE INDEX</code></a>可以<a href="https://dev.mysql.com/doc/refman/5.7/en/set-variable.html" target="_blank" rel="noopener"><code>SET GLOBAL</code></a>通过使用参数设置语句设置其大小或使用服务器启动选项来创建语句中 引用的键高速缓存。例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET GLOBAL keycache1.key_buffer_size=128*1024;</span><br></pre></td></tr></table></figure>

<p>要销毁密钥缓存，请将其大小设置为零：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET GLOBAL keycache1.key_buffer_size=0;</span><br></pre></td></tr></table></figure>

<p>您无法销毁默认密钥缓存。这样做的任何尝试都会被忽略：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET GLOBAL key_buffer_size = 0;</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE 'key_buffer_size';</span><br><span class="line">+<span class="comment">-----------------+---------+</span></span><br><span class="line">| Variable_name   | Value   |</span><br><span class="line">+<span class="comment">-----------------+---------+</span></span><br><span class="line">| key_buffer_size | 8384512 |</span><br><span class="line">+<span class="comment">-----------------+---------+</span></span><br></pre></td></tr></table></figure>

<p>关键高速缓存变量是具有名称和组件的结构化系统变量。对于 <code>keycache1.key_buffer_size</code>， <code>keycache1</code>是缓存变量名称， <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_key_buffer_size" target="_blank" rel="noopener"><code>key_buffer_size</code></a>是缓存组件。有关用于引用结构化键高速缓存系统变量的语法的描述，请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/structured-system-variables.html" target="_blank" rel="noopener">第5.1.8.3节“结构化系统变量”</a>。</p>
<p>默认情况下，表索引分配给服务器启动时创建的主（默认）键高速缓存。销毁键高速缓存时，分配给它的所有索引都将重新分配给默认键高速缓存。</p>
<p>对于繁忙的服务器，可以使用涉及三个关键缓存的策略：</p>
<ul>
<li>一个“ 热 ”键高速占用分配给所有键高速缓冲空间的20％。将其用于大量用于搜索但未更新的表。</li>
<li>一个“ 冷 ”键高速占用分配给所有键高速缓冲空间的20％。将此缓存用于中等大小的，经过大量修改的表，例如临时表。</li>
<li>一个“ 温暖 ”键高速占用键高速缓冲空间的60％。将此用作默认键缓存，默认情况下将其用于所有其他表。</li>
</ul>
<p>使用三个密钥缓存的好处之一是，对一个密钥缓存结构的访问不会阻止对其他密钥缓存结构的访问。访问分配给一个缓存的表的语句不会与访问分配给另一缓存的表的语句竞争。由于其他原因也会导致性能提升：</p>
<ul>
<li>热缓存仅用于检索查询，因此永远不会修改其内容。因此，每当需要将索引块从磁盘中拉出时，就无需先清除用于替换的高速缓存块的内容。</li>
<li>对于分配给热缓存的索引，如果没有查询需要进行索引扫描，则很有可能与索引B树的非叶子节点相对应的索引块保留在缓存中。</li>
<li>当更新的节点位于高速缓存中并且不需要首先从磁盘读取时，对临时表执行最频繁的更新操作将更快地执行。如果临时表的索引大小与冷键高速缓存的大小相当，则更新节点位于高速缓存中的可能性非常高。</li>
</ul>
<p>该<a href="https://dev.mysql.com/doc/refman/5.7/en/cache-index.html" target="_blank" rel="noopener"><code>CACHE INDEX</code></a>语句在表和键高速缓存之间建立关联，但是每次服务器重新启动时，关联都会丢失。如果要使该关联在每次服务器启动时都生效，则一种实现方法是使用选项文件：包括用于配置键高速缓存的变量设置和<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_init_file" target="_blank" rel="noopener"><code>init_file</code></a>用于命名包含<a href="https://dev.mysql.com/doc/refman/5.7/en/cache-index.html" target="_blank" rel="noopener"><code>CACHE INDEX</code></a>要执行的语句的文件的 系统变量。例如：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">key_buffer_size</span> = <span class="number">4</span>G</span><br><span class="line"><span class="attr">hot_cache.key_buffer_size</span> = <span class="number">2</span>G</span><br><span class="line"><span class="attr">cold_cache.key_buffer_size</span> = <span class="number">2</span>G</span><br><span class="line"><span class="attr">init_file</span>=/path/to/data-directory/mysqld_init.sql</span><br></pre></td></tr></table></figure>

<p><code>mysqld_init.sql</code>每次服务器启动时都会执行 in语句。该文件每行应包含一个SQL语句。以下示例为<code>hot_cache</code>和 分别分配了几个表<code>cold_cache</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CACHE</span> <span class="keyword">INDEX</span> db1.t1, db1.t2, db2.t3 <span class="keyword">IN</span> hot_cache</span><br><span class="line"><span class="keyword">CACHE</span> <span class="keyword">INDEX</span> db1.t4, db2.t5, db2.t6 <span class="keyword">IN</span> cold_cache</span><br></pre></td></tr></table></figure>

<h4 id="8-10-2-3中点插入策略"><a href="#8-10-2-3中点插入策略" class="headerlink" title="8.10.2.3中点插入策略"></a>8.10.2.3中点插入策略</h4><p>默认情况下，密钥缓存管理系统使用简单的LRU策略来选择要逐出的密钥缓存块，但它还支持一种更复杂的方法，称为 中点插入策略。</p>
<p>使用中点插入策略时，LRU链分为两部分：热子列表和热子列表。两个部分之间的划分点不是固定的，但是密钥缓存管理系统要注意热部分不要 “ 太短 ”，始终包含至少一部分 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_key_cache_division_limit" target="_blank" rel="noopener"><code>key_cache_division_limit</code></a> 密钥缓存块。 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_key_cache_division_limit" target="_blank" rel="noopener"><code>key_cache_division_limit</code></a>是结构化键缓存变量的组成部分，因此其值是可以为每个缓存设置的参数。</p>
<p>当将索引块从表中读取到键高速缓存中时，该索引块将置于热子列表的末尾。达到一定数量的点击次数（访问该块）后，它将被提升到热门子列表。目前，对于所有索引块而言，提升一个块（3）所需的命中数都是相同的。</p>
<p>提升到热子列表中的块位于列表的末尾。然后，该块在该子列表中循环。如果该块在子列表的开头停留了足够长的时间，它将被降级到热子列表。此时间由<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_key_cache_age_threshold" target="_blank" rel="noopener"><code>key_cache_age_threshold</code></a> 密钥缓存的组件的值确定 。</p>
<p>阈值规定，对于包含<em>N</em>块的键高速缓存，将在最后一次<code>*N* * key_cache_age_threshold / 100</code>匹配中未访问的热子列表开始处的块 移至热子列表的开始处。然后，它将成为第一个驱逐候选对象，因为要替换的块总是从温暖子列表的开头开始。</p>
<p>中点插入策略使您可以将更多有价值的块始终保留在缓存中。如果您更喜欢使用普通LRU策略，请将该<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_key_cache_division_limit" target="_blank" rel="noopener"><code>key_cache_division_limit</code></a> 值保留 为其默认值100。</p>
<p>当执行需要索引扫描的查询有效地将与有价值的高级B树节点相对应的所有索引块推出缓存时，中点插入策略有助于提高性能。为了避免这种情况，您必须使用<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_key_cache_division_limit" target="_blank" rel="noopener"><code>key_cache_division_limit</code></a>设置为小于100 的中点插入策略 。然后，在索引扫描操作期间，有价值的频繁命中的节点也会保留在热子列表中。</p>
<h4 id="8-10-2-4索引预加载"><a href="#8-10-2-4索引预加载" class="headerlink" title="8.10.2.4索引预加载"></a>8.10.2.4索引预加载</h4><p>如果键高速缓存中有足够的块来容纳整个索引的块，或者至少包含与其非叶节点相对应的块，那么在开始使用键高速缓存之前，先将索引块预加载到索引中是有意义的。预加载使您能够以最有效的方式将表索引块放入键高速缓存缓冲区中：通过从磁盘顺序读取索引块。</p>
<p>在没有预加载的情况下，块仍会根据查询的需要放置在键高速缓存中。尽管这些块将保留在高速缓存中，但是由于所有块都有足够的缓冲区，所以它们是从磁盘中以随机顺序而不是顺序获取的。</p>
<p>要将索引预加载到缓存中，请使用以下 <a href="https://dev.mysql.com/doc/refman/5.7/en/load-index.html" target="_blank" rel="noopener"><code>LOAD INDEX INTO CACHE</code></a>语句。例如，以下语句预加载表<code>t1</code>和的索引的节点（索引块）<code>t2</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; LOAD INDEX INTO CACHE t1, t2 IGNORE LEAVES;</span><br><span class="line">+<span class="comment">---------+--------------+----------+----------+</span></span><br><span class="line">| Table   | Op           | Msg_type | Msg_text |</span><br><span class="line">+<span class="comment">---------+--------------+----------+----------+</span></span><br><span class="line">| test.t1 | preload_keys | status   | OK       |</span><br><span class="line">| test.t2 | preload_keys | status   | OK       |</span><br><span class="line">+<span class="comment">---------+--------------+----------+----------+</span></span><br></pre></td></tr></table></figure>

<p>所述<code>IGNORE LEAVES</code>改性剂导致要预装只为索引的非叶结点的块。因此，显示的语句预加载来自的所有索引块<code>t1</code>，但仅加载来自 的非叶节点的块<code>t2</code>。</p>
<p>如果已使用<a href="https://dev.mysql.com/doc/refman/5.7/en/cache-index.html" target="_blank" rel="noopener"><code>CACHE INDEX</code></a>语句将索引分配给键高速缓存 ，则预加载会将索引块放入该高速缓存中。否则，索引将加载到默认键缓存中。</p>
<h4 id="8-10-2-5密钥缓存块大小"><a href="#8-10-2-5密钥缓存块大小" class="headerlink" title="8.10.2.5密钥缓存块大小"></a>8.10.2.5密钥缓存块大小</h4><p>可以使用该<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_key_cache_block_size" target="_blank" rel="noopener"><code>key_cache_block_size</code></a> 变量为单个键高速缓存指定块缓冲区的大小 。这允许调整索引文件的I / O操作的性能。</p>
<p>当读取缓冲区的大小等于本机操作系统I / O缓冲区的大小时，可以实现I / O操作的最佳性能。但是，将关键节点的大小设置为等于I / O缓冲区的大小并不能始终确保最佳的整体性能。读取大叶节点时，服务器会提取大量不必要的数据，从而有效地防止读取其他叶节点。</p>
<p>要控制表的<code>.MYI</code> 索引文件中块的大小，请在服务器启动时<code>MyISAM</code>使用该 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-options.html#option_mysqld_myisam-block-size" target="_blank" rel="noopener"><code>--myisam-block-size</code></a>选项。</p>
<h4 id="8-10-2-6重构密钥缓存"><a href="#8-10-2-6重构密钥缓存" class="headerlink" title="8.10.2.6重构密钥缓存"></a>8.10.2.6重构密钥缓存</h4><p>密钥缓存可以随时通过更新其参数值进行重组。例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET GLOBAL cold_cache.key_buffer_size=4*1024*1024;</span><br></pre></td></tr></table></figure>

<p>如果您为<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_key_buffer_size" target="_blank" rel="noopener"><code>key_buffer_size</code></a>或 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_key_cache_block_size" target="_blank" rel="noopener"><code>key_cache_block_size</code></a>键高速缓存组件分配 的值与该组件的当前值不同，则服务器将破坏高速缓存的旧结构，并根据新值创建一个新的结构。如果缓存中包含任何脏块，则服务器会在销毁并重新创建缓存之前将它们保存到磁盘。如果您更改其他关键缓存参数，则不会发生重组。</p>
<p>重组键高速缓存时，服务器首先将所有脏缓冲区的内容刷新到磁盘。此后，缓存内容将不可用。但是，重组不会阻止需要使用分配给缓存的索引的查询。而是，服务器使用本机文件系统缓存直接访问表索引。文件系统缓存的效率不如使用键缓存，因此尽管执行查询，但可以预见其速度会变慢。重组缓存后，它可再次用于缓存分配给它的索引，并且不再对索引使用文件系统缓存。</p>
<h3 id="8-10-3-MySQL查询缓存"><a href="#8-10-3-MySQL查询缓存" class="headerlink" title="8.10.3 MySQL查询缓存"></a>8.10.3 MySQL查询缓存</h3><ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/query-cache-operation.html" target="_blank" rel="noopener">8.10.3.1查询缓存如何运行</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/query-cache-in-select.html" target="_blank" rel="noopener">8.10.3.2查询缓存SELECT选项</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/query-cache-configuration.html" target="_blank" rel="noopener">8.10.3.3查询缓存配置</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/query-cache-status-and-maintenance.html" target="_blank" rel="noopener">8.10.3.4查询缓存状态和维护</a></li>
</ul>
<p>注意</p>
<p>从MySQL 5.7.20开始，查询缓存已弃用，并在MySQL 8.0中删除。</p>
<p>查询缓存将<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>语句文本以及发送到客户端的相应结果存储 在一起。如果以后收到相同的语句，则服务器从查询缓存中检索结果，而不是再次解析并执行该语句。查询缓存在会话之间共享，因此可以响应另一个客户端发出的同一查询来发送一个客户端生成的结果集。</p>
<p>查询高速缓存在您的表不经常更改且服务器接收许多相同查询的环境中很有用。这是许多Web服务器基于数据库内容生成许多动态页面的典型情况。</p>
<p>查询缓存不返回陈旧数据。修改表后，将刷新查询缓存中的所有相关条目。</p>
<p>注意</p>
<p>查询缓存在您有多个<a href="https://dev.mysql.com/doc/refman/5.7/en/mysqld.html" target="_blank" rel="noopener"><strong>mysqld</strong></a>服务器更新同一 <code>MyISAM</code>表的环境中不起作用。</p>
<p>在<a href="https://dev.mysql.com/doc/refman/5.7/en/query-cache-operation.html" target="_blank" rel="noopener">第8.10.3.1节“查询缓存的运行方式”中</a>所述的条件下，查询缓存用于准备好的语句。</p>
<p>注意</p>
<p>分区表不支持查询缓存，而涉及分区表的查询将自动禁用查询缓存。无法为此类查询启用查询缓存。</p>
<p>随后是查询缓存的一些性能数据。这些结果是通过在具有2GB RAM和64MB查询缓存的Linux Alpha 2×500MHz系统上运行MySQL基准套件而产生的。</p>
<ul>
<li>如果您正在执行的所有查询都很简单（例如从具有一行的表中选择一行），但是仍然不同，以致无法缓存查询，那么使查询缓存处于活动状态的开销为13％。这可以被认为是最坏的情况。在现实生活中，查询往往要复杂得多，因此开销通常会大大降低。</li>
<li>使用查询缓存，单行表中的单行搜索比没有查询时快238％。这可以视为接近缓存查询所期望的最小加速。</li>
</ul>
<p>要在服务器启动时禁用查询缓存，请将<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_query_cache_size" target="_blank" rel="noopener"><code>query_cache_size</code></a>系统变量设置 为0。通过禁用查询缓存代码，不会有明显的开销。</p>
<p>查询缓存提供了显着提高性能的潜力，但不要假设它在所有情况下都可以这样做。使用某些查询缓存配置或服务器工作负载，您实际上可能会看到性能下降：</p>
<ul>
<li>对于过大的查询缓存，请谨慎设置大小，这会增加维护缓存所需的开销，可能超出启用缓存的好处。通常，几十兆字节的大小是有益的。大小可能不会达到数百兆字节。</li>
<li>服务器工作负载对查询缓存效率有重大影响。几乎完全由固定的一组<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a> 语句组成的查询混合比启用频繁缓存的<a href="https://dev.mysql.com/doc/refman/5.7/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>语句导致缓存中的结果连续无效的混合更有可能从启用缓存中受益 。在某些情况下，一种解决方法是使用该 <code>SQL_NO_CACHE</code>选项来防止结果进入<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>使用频繁修改表的语句甚至进入缓存 。（请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/query-cache-in-select.html" target="_blank" rel="noopener">第8.10.3.2节“查询缓存选择选项”</a>。）</li>
</ul>
<p>要验证启用查询缓存是否有益，请在启用和禁用缓存的情况下测试MySQL服务器的运行情况。然后定期重新测试，因为查询缓存效率可能随服务器工作负载的变化而变化。</p>
<h4 id="8-10-3-1查询缓存如何运行"><a href="#8-10-3-1查询缓存如何运行" class="headerlink" title="8.10.3.1查询缓存如何运行"></a>8.10.3.1查询缓存如何运行</h4><p>注意</p>
<p>从MySQL 5.7.20开始，查询缓存已弃用，并在MySQL 8.0中删除。</p>
<p>本节描述查询高速缓存可操作时的工作方式。<a href="https://dev.mysql.com/doc/refman/5.7/en/query-cache-configuration.html" target="_blank" rel="noopener">第8.10.3.3节“查询缓存配置”</a>，描述了如何控制它是否可操作。</p>
<p>在解析之前，将传入的查询与查询缓存中的查询进行比较，因此以下两个查询被查询缓存视为不同：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</span><br><span class="line"><span class="keyword">Select</span> * <span class="keyword">from</span> tbl_name</span><br></pre></td></tr></table></figure>

<p>查询必须<em>完全相同</em>（逐字节），才能被视为相同。此外，由于其他原因，相同的查询字符串可能会被视为不同。使用不同数据库，不同协议版本或不同默认字符集的查询被视为不同查询，并分别进行缓存。</p>
<p>缓存不用于以下类型的查询：</p>
<ul>
<li>作为外部查询的子查询的查询</li>
<li>在存储的函数，触发器或事件的主体内执行的查询</li>
</ul>
<p>在从查询缓存中获取查询结果之前，MySQL将检查用户是否<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>对所涉及的所有数据库和表具有 特权。如果不是这种情况，则不使用缓存的结果。</p>
<p>如果从查询缓存返回查询结果，则服务器将递增<a href="https://dev.mysql.com/doc/refman/5.7/en/server-status-variables.html#statvar_Qcache_hits" target="_blank" rel="noopener"><code>Qcache_hits</code></a> 状态变量，而不是<code>Com_select</code>。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/query-cache-status-and-maintenance.html" target="_blank" rel="noopener">第8.10.3.4节“查询缓存状态和维护”</a>。</p>
<p>如果表发生更改，则使用该表的所有缓存查询都将变为无效，并从缓存中删除。这包括使用<code>MERGE</code>映射到已更改表的表的查询。一个表可以被许多类型的语句，如被改变<a href="https://dev.mysql.com/doc/refman/5.7/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/delete.html" target="_blank" rel="noopener"><code>DELETE</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/truncate-table.html" target="_blank" rel="noopener"><code>TRUNCATE TABLE</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/drop-table.html" target="_blank" rel="noopener"><code>DROP TABLE</code></a>，或 <a href="https://dev.mysql.com/doc/refman/5.7/en/drop-database.html" target="_blank" rel="noopener"><code>DROP DATABASE</code></a>。</p>
<p>使用<code>InnoDB</code>表时，查询缓存也可在事务内工作 。</p>
<p>来自<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>视图查询的结果被缓存。</p>
<p>查询缓存适用于<code>SELECT SQL_CALC_FOUND_ROWS ...</code>查询，并存储后续<code>SELECT FOUND_ROWS()</code>查询返回的值。 <a href="https://dev.mysql.com/doc/refman/5.7/en/information-functions.html#function_found-rows" target="_blank" rel="noopener"><code>FOUND_ROWS()</code></a>即使从缓存中提取了先前的查询，也将返回正确的值，因为找到的行数也存储在缓存中。该<code>SELECT FOUND_ROWS()</code>查询本身不能被缓存。</p>
<p>使用二进制协议使用<a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-stmt-prepare.html" target="_blank" rel="noopener"><code>mysql_stmt_prepare()</code></a>和 发出的预备语句<a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-stmt-execute.html" target="_blank" rel="noopener"><code>mysql_stmt_execute()</code></a>（请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/c-api-prepared-statements.html" target="_blank" rel="noopener">第27.7.7节“ C API预备语句”</a>）在缓存方面受到限制。与查询缓存中的语句进行比较是基于扩展<code>?</code>参数标记后的语句文本。该语句仅与使用二进制协议执行的其他缓存语句进行比较。也就是说，出于查询缓存的目的，使用二进制协议发布的预备语句不同于使用文本协议发布的预备语句（请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/sql-prepared-statements.html" target="_blank" rel="noopener">第13.5节“预备语句”</a>）。</p>
<p>如果查询使用以下任何功能，则不能将其缓存：</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/encryption-functions.html#function_aes-decrypt" target="_blank" rel="noopener"><code>AES_DECRYPT()</code></a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/encryption-functions.html#function_aes-encrypt" target="_blank" rel="noopener"><code>AES_ENCRYPT()</code></a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/information-functions.html#function_benchmark" target="_blank" rel="noopener"><code>BENCHMARK()</code></a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/information-functions.html#function_connection-id" target="_blank" rel="noopener"><code>CONNECTION_ID()</code></a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_convert-tz" target="_blank" rel="noopener"><code>CONVERT_TZ()</code></a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_curdate" target="_blank" rel="noopener"><code>CURDATE()</code></a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_current-date" target="_blank" rel="noopener"><code>CURRENT_DATE()</code></a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_current-time" target="_blank" rel="noopener"><code>CURRENT_TIME()</code></a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_current-timestamp" target="_blank" rel="noopener"><code>CURRENT_TIMESTAMP()</code></a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/information-functions.html#function_current-user" target="_blank" rel="noopener"><code>CURRENT_USER()</code></a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_curtime" target="_blank" rel="noopener"><code>CURTIME()</code></a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/information-functions.html#function_database" target="_blank" rel="noopener"><code>DATABASE()</code></a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/encryption-functions.html#function_encrypt" target="_blank" rel="noopener"><code>ENCRYPT()</code></a> 一个参数</li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/information-functions.html#function_found-rows" target="_blank" rel="noopener"><code>FOUND_ROWS()</code></a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/locking-functions.html#function_get-lock" target="_blank" rel="noopener"><code>GET_LOCK()</code></a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/locking-functions.html#function_is-free-lock" target="_blank" rel="noopener"><code>IS_FREE_LOCK()</code></a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/locking-functions.html#function_is-used-lock" target="_blank" rel="noopener"><code>IS_USED_LOCK()</code></a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/information-functions.html#function_last-insert-id" target="_blank" rel="noopener"><code>LAST_INSERT_ID()</code></a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/string-functions.html#function_load-file" target="_blank" rel="noopener"><code>LOAD_FILE()</code></a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/miscellaneous-functions.html#function_master-pos-wait" target="_blank" rel="noopener"><code>MASTER_POS_WAIT()</code></a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_now" target="_blank" rel="noopener"><code>NOW()</code></a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/encryption-functions.html#function_password" target="_blank" rel="noopener"><code>PASSWORD()</code></a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/mathematical-functions.html#function_rand" target="_blank" rel="noopener"><code>RAND()</code></a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/encryption-functions.html#function_random-bytes" target="_blank" rel="noopener"><code>RANDOM_BYTES()</code></a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/locking-functions.html#function_release-all-locks" target="_blank" rel="noopener"><code>RELEASE_ALL_LOCKS()</code></a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/locking-functions.html#function_release-lock" target="_blank" rel="noopener"><code>RELEASE_LOCK()</code></a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/miscellaneous-functions.html#function_sleep" target="_blank" rel="noopener"><code>SLEEP()</code></a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_sysdate" target="_blank" rel="noopener"><code>SYSDATE()</code></a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_unix-timestamp" target="_blank" rel="noopener"><code>UNIX_TIMESTAMP()</code></a> 没有参数</li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/information-functions.html#function_user" target="_blank" rel="noopener"><code>USER()</code></a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/miscellaneous-functions.html#function_uuid" target="_blank" rel="noopener"><code>UUID()</code></a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/miscellaneous-functions.html#function_uuid-short" target="_blank" rel="noopener"><code>UUID_SHORT()</code></a></li>
</ul>
<p>在以下情况下，也不会缓存查询：</p>
<ul>
<li><p>它指的是用户定义的函数（UDF）或存储的函数。</p>
</li>
<li><p>它指的是用户变量或本地存储的程序变量。</p>
</li>
<li><p>它是指在表<code>mysql</code>， <code>INFORMATION_SCHEMA</code>或 <code>performance_schema</code>数据库。</p>
</li>
<li><p>它引用任何分区表。</p>
</li>
<li><p>它具有以下任何形式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span></span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">INTO</span> <span class="keyword">OUTFILE</span> ...</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">INTO</span> <span class="keyword">DUMPFILE</span> ...</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> autoincrement_col <span class="keyword">IS</span> <span class="literal">NULL</span></span><br></pre></td></tr></table></figure>

<p>不缓存最后一个形式，因为它用作获取最后一个插入ID值的ODBC解决方法。请参阅<a href="https://dev.mysql.com/doc/refman/5.7/en/connectors-apis.html" target="_blank" rel="noopener">第27章，<em>连接器和API</em></a>的连接器/ ODBC部分 。</p>
<p>使用<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html#isolevel_serializable" target="_blank" rel="noopener"><code>SERIALIZABLE</code></a>隔离级别的事务中的语句 也无法缓存，因为它们使用<code>LOCK IN SHARE MODE</code>锁定。</p>
</li>
<li><p>它使用<code>TEMPORARY</code>表。</p>
</li>
<li><p>它不使用任何表。</p>
</li>
<li><p>它生成警告。</p>
</li>
<li><p>用户对任何涉及的表都具有列级特权。</p>
</li>
</ul>
<h4 id="8-10-3-2查询缓存SELECT选项"><a href="#8-10-3-2查询缓存SELECT选项" class="headerlink" title="8.10.3.2查询缓存SELECT选项"></a>8.10.3.2查询缓存SELECT选项</h4><p>注意</p>
<p>从MySQL 5.7.20开始，查询缓存已弃用，并在MySQL 8.0中删除。</p>
<p>可以在<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>语句中指定两个与查询缓存相关的选项 ：</p>
<ul>
<li><p><code>SQL_CACHE</code></p>
<p>如果查询结果是可缓存的并且<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_query_cache_type" target="_blank" rel="noopener"><code>query_cache_type</code></a>系统变量的值为<code>ON</code>or ，则将缓存该查询结果 <code>DEMAND</code>。</p>
</li>
<li><p><code>SQL_NO_CACHE</code></p>
<p>服务器不使用查询缓存。它既不检查查询缓存以查看结果是否已经缓存，也不缓存查询结果。</p>
</li>
</ul>
<p>例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SQL_CACHE</span> <span class="keyword">id</span>, <span class="keyword">name</span> <span class="keyword">FROM</span> customer;</span><br><span class="line"><span class="keyword">SELECT</span> SQL_NO_CACHE <span class="keyword">id</span>, <span class="keyword">name</span> <span class="keyword">FROM</span> customer;</span><br></pre></td></tr></table></figure>

<h4 id="8-10-3-3查询缓存配置"><a href="#8-10-3-3查询缓存配置" class="headerlink" title="8.10.3.3查询缓存配置"></a>8.10.3.3查询缓存配置</h4><p>注意</p>
<p>从MySQL 5.7.20开始，查询缓存已弃用，并在MySQL 8.0中删除。</p>
<p>该<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_have_query_cache" target="_blank" rel="noopener"><code>have_query_cache</code></a>服务器系统变量指示查询缓存是否可用：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE 'have_query_cache';</span><br><span class="line">+<span class="comment">------------------+-------+</span></span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+<span class="comment">------------------+-------+</span></span><br><span class="line">| have_query_cache | YES   |</span><br><span class="line">+<span class="comment">------------------+-------+</span></span><br></pre></td></tr></table></figure>

<p>使用标准MySQL二进制文件时<code>YES</code>，即使禁用查询缓存，该值也始终 为。</p>
<p>其他几个系统变量控制查询缓存操作。这些可以在启动<a href="https://dev.mysql.com/doc/refman/5.7/en/mysqld.html" target="_blank" rel="noopener"><strong>mysqld</strong></a>时在选项文件中或命令行中设置。查询缓存系统变量的名称都以开头 <code>query_cache_</code>。它们在<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html" target="_blank" rel="noopener">第5.1.7节“服务器系统变量”</a>中进行了简要描述，并在 此处提供了其他配置信息。</p>
<p>要设置查询缓存的大小，请设置 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_query_cache_size" target="_blank" rel="noopener"><code>query_cache_size</code></a>系统变量。将其设置为0会禁用查询缓存，而将设置也会禁用<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_query_cache_type" target="_blank" rel="noopener"><code>query_cache_type=0</code></a>。默认情况下，查询缓存处于禁用状态。这是使用默认大小1M（默认 <code>query_cache_type</code>值为0）来实现的。</p>
<p>为了显着减少开销，<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_query_cache_type" target="_blank" rel="noopener"><code>query_cache_type=0</code></a>如果您不使用查询缓存，请使用启动服务器 。</p>
<p>注意</p>
<p>使用Windows配置向导安装或配置MySQL时，<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_query_cache_size" target="_blank" rel="noopener"><code>query_cache_size</code></a>将根据可用的不同配置类型自动为您配置默认值 。使用Windows配置向导时，由于选择了配置，因此可能启用了查询缓存（即，将其设置为非零值）。查询缓存也由<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_query_cache_type" target="_blank" rel="noopener"><code>query_cache_type</code></a>变量的设置控制 。配置完成后，检查<code>my.ini</code>文件中设置的这些变量的值 。</p>
<p>设置<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_query_cache_size" target="_blank" rel="noopener"><code>query_cache_size</code></a> 为非零值时，请记住查询缓存需要最小大小约为40KB才能分配其结构。（确切的大小取决于系统体系结构。）如果将值设置得太小，则会收到警告，如以下示例所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET GLOBAL query_cache_size = 40000;</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW WARNINGS\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">  Level: Warning</span><br><span class="line">   Code: 1282</span><br><span class="line">Message: Query <span class="keyword">cache</span> <span class="keyword">failed</span> <span class="keyword">to</span> <span class="keyword">set</span> <span class="keyword">size</span> <span class="number">39936</span>;</span><br><span class="line">         new query <span class="keyword">cache</span> <span class="keyword">size</span> <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">SET</span> <span class="keyword">GLOBAL</span> query_cache_size = <span class="number">41984</span>;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE 'query_cache_size';</span><br><span class="line">+<span class="comment">------------------+-------+</span></span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+<span class="comment">------------------+-------+</span></span><br><span class="line">| query_cache_size | 41984 |</span><br><span class="line">+<span class="comment">------------------+-------+</span></span><br></pre></td></tr></table></figure>

<p>为了使查询缓存实际上能够保存任何查询结果，必须将其大小设置为更大：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET GLOBAL query_cache_size = 1000000;</span><br><span class="line">Query OK, 0 rows affected (0.04 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE 'query_cache_size';</span><br><span class="line">+<span class="comment">------------------+--------+</span></span><br><span class="line">| Variable_name    | Value  |</span><br><span class="line">+<span class="comment">------------------+--------+</span></span><br><span class="line">| query_cache_size | 999424 |</span><br><span class="line">+<span class="comment">------------------+--------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>该<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_query_cache_size" target="_blank" rel="noopener"><code>query_cache_size</code></a>值与最接近的1024字节块对齐。因此，报告的值可能与您分配的值不同。</p>
<p>如果查询缓存大小大于0，则 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_query_cache_type" target="_blank" rel="noopener"><code>query_cache_type</code></a>变量会影响其工作方式。可以将此变量设置为以下值：</p>
<ul>
<li>的值<code>0</code>或<code>OFF</code> 防止缓存或检索缓存的结果。</li>
<li>值<code>1</code>或<code>ON</code> 启用缓存，但以开头的语句除外 <code>SELECT SQL_NO_CACHE</code>。</li>
<li>的值<code>2</code>或 <code>DEMAND</code>导致仅缓存以开头的语句<code>SELECT SQL_CACHE</code>。</li>
</ul>
<p>如果<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_query_cache_size" target="_blank" rel="noopener"><code>query_cache_size</code></a>为0，则还应该将<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_query_cache_type" target="_blank" rel="noopener"><code>query_cache_type</code></a>变量设置 为0。在这种情况下，服务器根本不会获取查询缓存互斥量，这意味着无法在运行时启用查询缓存，并且减少了查询执行的开销。</p>
<p>设置该<code>GLOBAL</code> <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_query_cache_type" target="_blank" rel="noopener"><code>query_cache_type</code></a>值可以确定更改后连接的所有客户端的查询缓存行为。各个客户端可以通过设置<code>SESSION</code> <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_query_cache_type" target="_blank" rel="noopener"><code>query_cache_type</code></a>值来控制其自己的连接的缓存行为 。例如，客户端可以禁止对自己的查询使用查询缓存，如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET SESSION query_cache_type = OFF;</span><br></pre></td></tr></table></figure>

<p>如果<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_query_cache_type" target="_blank" rel="noopener"><code>query_cache_type</code></a> 在服务器启动时（而不是在运行时使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/set-variable.html" target="_blank" rel="noopener"><code>SET</code></a> 语句）设置，则仅允许数字值。</p>
<p>要控制可缓存的单个查询结果的最大大小，请设置 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_query_cache_limit" target="_blank" rel="noopener"><code>query_cache_limit</code></a>系统变量。默认值为1MB。</p>
<p>注意不要将缓存的大小设置得太大。由于在更新过程中需要线程锁定高速缓存，因此您可能会看到高速缓存非常大的锁定争用问题。</p>
<p>注意</p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/set-variable.html" target="_blank" rel="noopener"><code>SET</code></a> 通过使用 命令行或配置文件中的选项，可以使用语句设置 在运行时为查询缓存指定的最大大小 。 <code>--maximum-query_cache_size=*32M*</code></p>
<p>当要缓存查询时，其结果（发送到客户端的数据）将在结果检索期间存储在查询缓存中。因此，通常不会大批量处理数据。查询高速缓存分配块以按需存储此数据，因此当一个块被填充时，将分配一个新块。由于内存分配操作成本高昂（按时间排列），因此查询缓存将分配具有<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_query_cache_min_res_unit" target="_blank" rel="noopener"><code>query_cache_min_res_unit</code></a> 系统变量给定的最小大小的块 。执行查询时，将最后一个结果块修剪为实际数据大小，以便释放未使用的内存。根据服务器执行的查询类型，您可能会发现调整以下值会有所帮助 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_query_cache_min_res_unit" target="_blank" rel="noopener"><code>query_cache_min_res_unit</code></a>：</p>
<ul>
<li>默认值为 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_query_cache_min_res_unit" target="_blank" rel="noopener"><code>query_cache_min_res_unit</code></a> 4KB。对于大多数情况，这应该足够了。</li>
<li>如果您有很多查询而结果却很少，则默认的块大小可能会导致内存碎片，这由大量的空闲块指示。由于内存不足，碎片会迫使查询缓存从缓存中删除查询（删除）。在这种情况下，减小的值 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_query_cache_min_res_unit" target="_blank" rel="noopener"><code>query_cache_min_res_unit</code></a>。由于修剪而删除的空闲块和查询的数量由<a href="https://dev.mysql.com/doc/refman/5.7/en/server-status-variables.html#statvar_Qcache_free_blocks" target="_blank" rel="noopener"><code>Qcache_free_blocks</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-status-variables.html#statvar_Qcache_lowmem_prunes" target="_blank" rel="noopener"><code>Qcache_lowmem_prunes</code></a> 状态变量的值给出 。</li>
<li>如果您的大多数查询都有较大的结果（请检查 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-status-variables.html#statvar_Qcache_total_blocks" target="_blank" rel="noopener"><code>Qcache_total_blocks</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-status-variables.html#statvar_Qcache_queries_in_cache" target="_blank" rel="noopener"><code>Qcache_queries_in_cache</code></a> 状态变量），则可以通过提高来提高性能 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_query_cache_min_res_unit" target="_blank" rel="noopener"><code>query_cache_min_res_unit</code></a>。但是，请注意不要使其过大（请参阅上一项）。</li>
</ul>
<h4 id="8-10-3-4查询缓存状态和维护"><a href="#8-10-3-4查询缓存状态和维护" class="headerlink" title="8.10.3.4查询缓存状态和维护"></a>8.10.3.4查询缓存状态和维护</h4><p>注意</p>
<p>从MySQL 5.7.20开始，查询缓存已弃用，并在MySQL 8.0中删除。</p>
<p>要检查您的MySQL服务器中是否存在查询缓存，请使用以下语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE 'have_query_cache';</span><br><span class="line">+<span class="comment">------------------+-------+</span></span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+<span class="comment">------------------+-------+</span></span><br><span class="line">| have_query_cache | YES   |</span><br><span class="line">+<span class="comment">------------------+-------+</span></span><br></pre></td></tr></table></figure>

<p>您可以对查询缓存进行碎片整理，以更好地利用该<a href="https://dev.mysql.com/doc/refman/5.7/en/flush.html#flush-query-cache" target="_blank" rel="noopener"><code>FLUSH QUERY CACHE</code></a>语句的内存。该语句不会从缓存中删除任何查询。</p>
<p>该<code>RESET QUERY CACHE</code>语句从查询缓存中删除所有查询结果。该 <a href="https://dev.mysql.com/doc/refman/5.7/en/flush.html#flush-tables" target="_blank" rel="noopener"><code>FLUSH TABLES</code></a>语句也这样做。</p>
<p>要监视查询缓存性能，请使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/show-status.html" target="_blank" rel="noopener"><code>SHOW STATUS</code></a>来查看缓存状态变量：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW STATUS LIKE 'Qcache%';</span><br><span class="line">+<span class="comment">-------------------------+--------+</span></span><br><span class="line">| Variable_name           | Value  |</span><br><span class="line">+<span class="comment">-------------------------+--------+</span></span><br><span class="line">| Qcache_free_blocks      | 36     |</span><br><span class="line">| Qcache_free_memory      | 138488 |</span><br><span class="line">| Qcache_hits             | 79570  |</span><br><span class="line">| Qcache_inserts          | 27087  |</span><br><span class="line">| Qcache_lowmem_prunes    | 3114   |</span><br><span class="line">| Qcache_not_cached       | 22989  |</span><br><span class="line">| Qcache_queries_in_cache | 415    |</span><br><span class="line">| Qcache_total_blocks     | 912    |</span><br><span class="line">+<span class="comment">-------------------------+--------+</span></span><br></pre></td></tr></table></figure>

<p><a href="https://dev.mysql.com/doc/refman/5.7/en/server-status-variables.html" target="_blank" rel="noopener">第5.1.9节“服务器状态变量”</a> 中给出了对每个变量的描述 。这里描述了它们的一些用途。</p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a> 查询 总数由以下公式给出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  Com_select</span><br><span class="line">+ Qcache_hits</span><br><span class="line">+ queries with errors found by parser</span><br></pre></td></tr></table></figure>

<p>该<code>Com_select</code>值由以下公式给出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  Qcache_inserts</span><br><span class="line">+ Qcache_not_cached</span><br><span class="line">+ queries with errors found during the column-privileges check</span><br></pre></td></tr></table></figure>

<p>查询缓存使用可变长度的块，因此 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-status-variables.html#statvar_Qcache_total_blocks" target="_blank" rel="noopener"><code>Qcache_total_blocks</code></a>并 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-status-variables.html#statvar_Qcache_free_blocks" target="_blank" rel="noopener"><code>Qcache_free_blocks</code></a>可能指示查询缓存内存碎片。之后 <a href="https://dev.mysql.com/doc/refman/5.7/en/flush.html#flush-query-cache" target="_blank" rel="noopener"><code>FLUSH QUERY CACHE</code></a>，仅剩一个空闲块。</p>
<p>每个缓存的查询至少需要两个块（一个用于查询文本，一个或多个用于查询结果）。同样，查询使用的每个表都需要一个块。但是，如果两个或多个查询使用同一张表，则只需要分配一个表块。</p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/server-status-variables.html#statvar_Qcache_lowmem_prunes" target="_blank" rel="noopener"><code>Qcache_lowmem_prunes</code></a>status变量 提供的信息 可以帮助您调整查询缓存的大小。它计算从缓存中删除的查询数，以释放内存以缓存新查询。查询缓存使用最近最少使用（LRU）策略来决定从缓存中删除哪些查询。<a href="https://dev.mysql.com/doc/refman/5.7/en/query-cache-configuration.html" target="_blank" rel="noopener">第8.10.3.3节“查询缓存配置”中</a>给出了调整信息 。</p>
<h3 id="8-10-4缓存准备好的语句和存储的程序"><a href="#8-10-4缓存准备好的语句和存储的程序" class="headerlink" title="8.10.4缓存准备好的语句和存储的程序"></a>8.10.4缓存准备好的语句和存储的程序</h3><ul>
<li>准备好的语句，包括在SQL级别处理的<a href="https://dev.mysql.com/doc/refman/5.7/en/prepare.html" target="_blank" rel="noopener"><code>PREPARE</code></a>语句（使用该语句）和使用二进制客户端/服务器协议（使用<a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-stmt-prepare.html" target="_blank" rel="noopener"><code>mysql_stmt_prepare()</code></a>C API函数）处理的语句 。所述 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_max_prepared_stmt_count" target="_blank" rel="noopener"><code>max_prepared_stmt_count</code></a> 系统变量控制语句的服务器高速缓存的总数量。（所有会话中已准备好的语句总数）。</li>
<li>存储的程序（存储的过程和功能，触发器和事件）。在这种情况下，服务器将转换并缓存整个程序主体。该 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_stored_program_cache" target="_blank" rel="noopener"><code>stored_program_cache</code></a>系统变量指示存储的程序每个会话的服务器缓存的大致数量。</li>
</ul>
<p>服务器在每个会话的基础上为准备好的语句和存储的程序维护高速缓存。为一个会话缓存的语句不能被其他会话访问。会话结束时，服务器将丢弃为其缓存的所有语句。</p>
<p>当服务器使用缓存的内部语句结构时，必须注意该结构不会过时。语句所使用的对象可能发生元数据更改，从而导致当前对象定义与内部语句结构中表示的定义之间不匹配。DDL语句会发生元数据更改，例如创建，删除，更改，重命名或截断表，分析，优化或修复表的语句。表内容的更改（例如，使用<a href="https://dev.mysql.com/doc/refman/5.7/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>或 <a href="https://dev.mysql.com/doc/refman/5.7/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a>）不会更改元数据，<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>语句也不会更改。</p>
<p>这是问题的例证。假设客户准备以下语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PREPARE</span> s1 <span class="keyword">FROM</span> <span class="string">'SELECT * FROM t1'</span>;</span><br></pre></td></tr></table></figure>

<p>在<code>SELECT *</code>内部结构上表中的列的列表展开。如果使用修改了表中的列集<code>ALTER TABLE</code>，则prepared语句已过期。如果服务器在下次客户端执行时未检测到此更改<code>s1</code>，则prepared语句将返回错误的结果。</p>
<p>为了避免由准备好的语句引用的表或视图的元数据更改引起的问题，服务器将检测到这些更改，并在下次执行该语句时自动重新准备该语句。即，服务器重新解析该语句并重建内部结构。从表定义高速缓存中清除引用的表或视图之后，也会重新进行解析，这是隐式地为高速缓存中的新条目腾出空间，或者是由于导致的显式<a href="https://dev.mysql.com/doc/refman/5.7/en/flush.html#flush-tables" target="_blank" rel="noopener"><code>FLUSH TABLES</code></a>。</p>
<p>同样，如果存储程序使用的对象发生更改，则服务器将重新解析程序中受影响的语句。</p>
<p>服务器还检测表达式中对象的元数据更改。这些可能会在陈述具体可用于存储程序，如<code>DECLARE CURSOR</code>或流量控制语句，如 <a href="https://dev.mysql.com/doc/refman/5.7/en/if.html" target="_blank" rel="noopener"><code>IF</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/case.html" target="_blank" rel="noopener"><code>CASE</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/return.html" target="_blank" rel="noopener"><code>RETURN</code></a>。</p>
<p>为了避免重新解析整个存储的程序，服务器仅在需要时才重新解析程序中受影响的语句或表达式。例子：</p>
<ul>
<li><p>假设表或视图的元数据已更改。对于<code>SELECT *</code>访问表或视图的程序，将进行重新解析，但对于<code>SELECT *</code>不访问表或视图的程序，则不会进行 重新解析。</p>
</li>
<li><p>当一条语句受到影响时，服务器将在可能的情况下仅部分对其进行重新分析。考虑以下 <a href="https://dev.mysql.com/doc/refman/5.7/en/case.html" target="_blank" rel="noopener"><code>CASE</code></a>语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CASE case_expr</span><br><span class="line">  WHEN when_expr1 ...</span><br><span class="line">  WHEN when_expr2 ...</span><br><span class="line">  WHEN when_expr3 ...</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">CASE</span></span><br></pre></td></tr></table></figure>

<p>如果元数据更改仅影响，则将重新解析该表达式。 而其他表达式则无法解析。 <code>WHEN *when_expr3*</code><em>case_expr</em><code>WHEN</code></p>
</li>
</ul>
<p>重新解析使用默认的数据库和SQL模式，该模式对原始转换为内部格式有效。</p>
<p>服务器尝试最多进行三次重新解析。如果所有尝试均失败，则会发生错误。</p>
<p>重新解析是自动的，但是在一定程度上会降低准备好的语句和存储程序的性能。</p>
<p>对于准备好的语句，<a href="https://dev.mysql.com/doc/refman/5.7/en/server-status-variables.html#statvar_Com_xxx" target="_blank" rel="noopener"><code>Com_stmt_reprepare</code></a> 状态变量跟踪重新准备 的次数。</p>
<h2 id="8-11优化锁定操作"><a href="#8-11优化锁定操作" class="headerlink" title="8.11优化锁定操作"></a>8.11优化锁定操作</h2><ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/internal-locking.html" target="_blank" rel="noopener">8.11.1内部锁定方法</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/table-locking.html" target="_blank" rel="noopener">8.11.2表锁定问题</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/concurrent-inserts.html" target="_blank" rel="noopener">8.11.3并发插入</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/metadata-locking.html" target="_blank" rel="noopener">8.11.4元数据锁定</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/external-locking.html" target="_blank" rel="noopener">8.11.5外部锁定</a></li>
</ul>
<p>MySQL使用<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_locking" target="_blank" rel="noopener">锁定</a>管理表内容的争用 ：</p>
<ul>
<li>内部锁定在MySQL服务器本身内部执行，以管理多个线程对表内容的争用。这种类型的锁定是内部锁定，因为它完全由服务器执行，并且不涉及其他程序。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/internal-locking.html" target="_blank" rel="noopener">第8.11.1节“内部锁定方法”</a>。</li>
<li>当服务器和其他程序锁定<a href="https://dev.mysql.com/doc/refman/5.7/en/myisam-storage-engine.html" target="_blank" rel="noopener"><code>MyISAM</code></a>表文件以相互协调哪个程序可以在何时访问表时，就会发生外部锁定。请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/external-locking.html" target="_blank" rel="noopener">第8.11.5节“外部锁定”</a>。</li>
</ul>
<h3 id="8-11-1内部锁定方法"><a href="#8-11-1内部锁定方法" class="headerlink" title="8.11.1内部锁定方法"></a>8.11.1内部锁定方法</h3><p>本节讨论内部锁定。也就是说，在MySQL服务器内部执行锁定，以管理多个会话对表内容的争用。这种类型的锁定是内部锁定，因为它完全由服务器执行，并且不涉及其他程序。有关其他程序对MySQL文件执行的锁定，请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/external-locking.html" target="_blank" rel="noopener">第8.11.5节“外部锁定”</a>。</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/internal-locking.html#internal-row-level-locking" target="_blank" rel="noopener">行级锁定</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/internal-locking.html#internal-table-level-locking" target="_blank" rel="noopener">表级锁定</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/internal-locking.html#internal-locking-choices" target="_blank" rel="noopener">选择锁定类型</a></li>
</ul>
<h4 id="行级锁定"><a href="#行级锁定" class="headerlink" title="行级锁定"></a>行级锁定</h4><p>MySQL 对表使用<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_row_lock" target="_blank" rel="noopener">行级锁定</a>，<code>InnoDB</code>以支持多个会话同时进行写访问，从而使其适用于多用户，高度并发和OLTP应用程序。</p>
<p>为了避免在单个表上执行多个并发写操作时出现 <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_deadlock" target="_blank" rel="noopener">死锁</a>，即使数据更改语句出现在事务的后面，也要<code>InnoDB</code>通过<code>SELECT ... FOR UPDATE</code>在每个事务的行组中发布一条语句来获取必要的锁，该语句针对每组预期被修改的行。如果事务修改或锁定了多个表，请在每个事务中以相同顺序发出适用的语句。死锁会影响性能，而不是代表严重错误，因为 死锁会<code>InnoDB</code>自动 <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_deadlock_detection" target="_blank" rel="noopener">检测到</a>死锁条件并回滚受影响的事务之一。</p>
<p>在高并发系统上，当多个线程等待相同的锁时，死锁检测会导致速度变慢。有时，禁用死锁检测并在<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_lock_wait_timeout" target="_blank" rel="noopener"><code>innodb_lock_wait_timeout</code></a> 发生死锁时依靠设置进行事务回滚可能会更有效 。可以使用<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_deadlock_detect" target="_blank" rel="noopener"><code>innodb_deadlock_detect</code></a> 配置选项禁用死锁检测 。</p>
<p>行级锁定的优点：</p>
<ul>
<li>当不同的会话访问不同的行时，锁冲突减少。</li>
<li>回滚更改较少。</li>
<li>可以长时间锁定单个行。</li>
</ul>
<h4 id="表级锁定"><a href="#表级锁定" class="headerlink" title="表级锁定"></a>表级锁定</h4><p>MySQL 对，和 表使用<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_table_lock" target="_blank" rel="noopener">表级锁定</a><code>MyISAM</code>， 仅允许一个会话一次更新这些表。此锁定级别使这些存储引擎更适合于只读，只读或单用户应用程序。 <code>MEMORY``MERGE</code></p>
<p>这些存储引擎通过始终在查询开始时一次请求所有需要的锁并始终以相同顺序锁定表来避免 <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_deadlock" target="_blank" rel="noopener">死锁</a>。权衡是该策略减少了并发性。其他要修改表的会话必须等待，直到当前数据更改语句完成为止。</p>
<p>表级锁定的优点：</p>
<ul>
<li>所需的内存相对较少（行锁定需要锁定每行或每组行的内存）</li>
<li>在表的大部分上使用时非常快，因为只涉及一个锁。</li>
<li>如果您经常<code>GROUP BY</code> 对大部分数据进行操作，或者必须经常扫描整个表，则速度很快。</li>
</ul>
<p>MySQL授予表写锁定，如下所示：</p>
<ol>
<li>如果表上没有锁，请在其上放置写锁。</li>
<li>否则，将锁定请求放入写锁定队列中。</li>
</ol>
<p>MySQL授予表读取锁，如下所示：</p>
<ol>
<li>如果表上没有写锁，请在其上放置一个读锁。</li>
<li>否则，将锁定请求放入读取锁定队列中。</li>
</ol>
<p>表更新的优先级高于表检索。因此，释放锁时，该锁可用于写锁队列中的请求，然后可用于读锁队列中的请求。这样可以确保即使表有大量活动，对表的更新也不会“ 饿死 ”<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>。但是，如果表有许多更新，则 <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>语句将等到没有更多更新。</p>
<p>有关更改读写优先级的信息，请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/table-locking.html" target="_blank" rel="noopener">第8.11.2节“表锁定问题”</a>。</p>
<p>您可以通过检查<a href="https://dev.mysql.com/doc/refman/5.7/en/server-status-variables.html#statvar_Table_locks_immediate" target="_blank" rel="noopener"><code>Table_locks_immediate</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-status-variables.html#statvar_Table_locks_waited" target="_blank" rel="noopener"><code>Table_locks_waited</code></a>状态变量来分析系统上的表锁争用 ，分别指示可以立即授予表锁请求的次数和必须等待的次数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW STATUS LIKE 'Table%';</span><br><span class="line">+<span class="comment">-----------------------+---------+</span></span><br><span class="line">| Variable_name         | Value   |</span><br><span class="line">+<span class="comment">-----------------------+---------+</span></span><br><span class="line">| Table_locks_immediate | 1151552 |</span><br><span class="line">| Table_locks_waited    | 15324   |</span><br><span class="line">+<span class="comment">-----------------------+---------+</span></span><br></pre></td></tr></table></figure>

<p>性能架构锁定表还提供锁定信息。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/performance-schema-lock-tables.html" target="_blank" rel="noopener">第25.12.12节“性能模式锁定表”</a>。</p>
<p>如果使用显式获取表锁 <a href="https://dev.mysql.com/doc/refman/5.7/en/lock-tables.html" target="_blank" rel="noopener"><code>LOCK TABLES</code></a>，则可以请求一个 <code>READ LOCAL</code>锁而不是一个 <code>READ</code>锁，以使其他会话在锁定表时能够执行并发插入。</p>
<p>执行许多<a href="https://dev.mysql.com/doc/refman/5.7/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>操作上的表 <code>t1</code>时并发的插入是不可能的，你可以插入行到一个临时表 <code>temp_t1</code>，并从临时表中的行更新真正的表：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; LOCK TABLES t1 WRITE, temp_t1 WRITE;</span><br><span class="line">mysql&gt; INSERT INTO t1 SELECT * FROM temp_t1;</span><br><span class="line">mysql&gt; DELETE FROM temp_t1;</span><br><span class="line">mysql&gt; UNLOCK TABLES;</span><br></pre></td></tr></table></figure>

<h4 id="选择锁定类型"><a href="#选择锁定类型" class="headerlink" title="选择锁定类型"></a>选择锁定类型</h4><p>通常，在以下情况下，表锁优于行级锁：</p>
<ul>
<li><p>该表的大多数语句均为读取。</p>
</li>
<li><p>该表的语句是读和写的混合，其中写是对单行的更新或删除，可通过一次按键读取来获取：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> tbl_name <span class="keyword">SET</span> <span class="keyword">column</span>=<span class="keyword">value</span> <span class="keyword">WHERE</span> unique_key_col=key_value;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> unique_key_col=key_value;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>与并发<a href="https://dev.mysql.com/doc/refman/5.7/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a> 语句结合，很少有 <a href="https://dev.mysql.com/doc/refman/5.7/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a>or <a href="https://dev.mysql.com/doc/refman/5.7/en/delete.html" target="_blank" rel="noopener"><code>DELETE</code></a>语句。</p>
</li>
<li><p><code>GROUP BY</code>无需任何编写程序即可对整个表进行 许多扫描或操作。</p>
</li>
</ul>
<p>使用高级锁，您可以通过支持不同类型的锁来更轻松地调整应用程序，因为锁开销比行级锁要少。</p>
<p>行级锁定以外的选项：</p>
<ul>
<li>版本控制（例如在MySQL中用于并发插入的版本控制），可以同时拥有一个编写者和多个阅读者。这意味着数据库或表根据访问开始的时间支持数据的不同视图。这个其他常见的术语是 “ 时间旅行， ” “ 上写副本， ” 或“ 按需复制。”</li>
<li>在许多情况下，按需复制优于行级锁定。但是，在最坏的情况下，与使用普通锁相比，它可以使用更多的内存。</li>
<li>除了使用行级锁，您还可以使用应用程序级锁，例如MySQL <a href="https://dev.mysql.com/doc/refman/5.7/en/locking-functions.html#function_get-lock" target="_blank" rel="noopener"><code>GET_LOCK()</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/locking-functions.html#function_release-lock" target="_blank" rel="noopener"><code>RELEASE_LOCK()</code></a>MySQL 提供的锁 。这些是咨询锁，因此它们仅适用于相互协作的应用程序。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/locking-functions.html" target="_blank" rel="noopener">第12.14节“锁定功能”</a>。</li>
</ul>
<h3 id="8-11-2表锁定问题"><a href="#8-11-2表锁定问题" class="headerlink" title="8.11.2表锁定问题"></a>8.11.2表锁定问题</h3><p><code>InnoDB</code>表使用行级锁定，因此多个会话和应用程序可以同时读取和写入同一个表，而不会彼此等待或产生不一致的结果。对于此存储引擎，请避免使用该<a href="https://dev.mysql.com/doc/refman/5.7/en/lock-tables.html" target="_blank" rel="noopener"><code>LOCK TABLES</code></a>语句，因为它不提供任何额外的保护，而是减少了并发性。自动行级锁定使这些表适合于具有最重要数据的最繁忙的数据库，同时由于不需要锁定和解锁表，还简化了应用程序逻辑。因此， <code>InnoDB</code>存储引擎是MySQL中的默认引擎。</p>
<p>MySQL对所有存储引擎都使用表锁定（而不是页面锁定，行锁定或列锁定） <code>InnoDB</code>。锁定操作本身没有太多的开销。但是，由于一次只能有一个会话可以写入表，因此要与其他存储引擎一起获得最佳性能，请主要将它们用于经常查询且很少插入或更新的表。</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/table-locking.html#table-locking-innodb" target="_blank" rel="noopener">性能方面的考虑有利于InnoDB</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/table-locking.html#table-locking-workarounds" target="_blank" rel="noopener">锁定性能问题的变通办法</a></li>
</ul>
<h4 id="性能方面的考虑有利于InnoDB"><a href="#性能方面的考虑有利于InnoDB" class="headerlink" title="性能方面的考虑有利于InnoDB"></a>性能方面的考虑有利于InnoDB</h4><p>选择是使用表<code>InnoDB</code>还是使用其他存储引擎创建表时 ，请记住表锁定的以下缺点：</p>
<ul>
<li>表锁定使许多会话可以同时从一个表读取，但是如果一个会话要写入一个表，它必须首先获得独占访问权限，这意味着它可能必须先等待其他会话才能完成对该表的访问。在更新期间，要访问此特定表的所有其他会话都必须等待，直到更新完成。</li>
<li>在会话等待期间，表锁定会导致问题，因为磁盘已满，会话开始之前需要释放可用空间。在这种情况下，所有要访问问题表的会话也将处于等待状态，直到有更多磁盘空间可用为止。</li>
<li>一个<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>是需要很长的时间，从更新表的同时，使其他场次出现缓慢或无响应运行防止其他会话声明。当会话正在等待获取表的独占访问权以进行更新时，其他发出<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>语句的会话 将在其后排队，从而即使对于只读会话也降低了并发性。</li>
</ul>
<h4 id="锁定性能问题的变通办法"><a href="#锁定性能问题的变通办法" class="headerlink" title="锁定性能问题的变通办法"></a>锁定性能问题的变通办法</h4><p>以下各项描述了避免或减少表锁定引起的争用的一些方法：</p>
<ul>
<li>考虑在设置过程<code>InnoDB</code>中使用<code>CREATE TABLE ... ENGINE=INNODB</code>或<code>ALTER TABLE ... ENGINE=INNODB</code>将现有表用于将表切换到 存储引擎 。有关<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html" target="_blank" rel="noopener"><em>此存储引擎</em></a>的更多详细信息<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html" target="_blank" rel="noopener">，</a>请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html" target="_blank" rel="noopener">第14章</a>。</li>
<li>优化<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>语句以使其运行更快，以便它们在较短的时间内锁定表。您可能必须创建一些汇总表才能执行此操作。</li>
<li>启动<a href="https://dev.mysql.com/doc/refman/5.7/en/mysqld.html" target="_blank" rel="noopener"><strong>mysqld的</strong></a>使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_low_priority_updates" target="_blank" rel="noopener"><code>--low-priority-updates</code></a>。对于仅使用表级锁（如存储引擎 <code>MyISAM</code>，<code>MEMORY</code>和 <code>MERGE</code>），这给所有的语句更新（修改），比表低优先级 <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>的语句。在这种情况下，<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a> 前面场景中的第二条语句将在该<a href="https://dev.mysql.com/doc/refman/5.7/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a>语句之前执行，而不会等待第一条语句 <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>完成。</li>
<li>要指定应以低优先级完成在特定连接中发布的所有更新，请将<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_low_priority_updates" target="_blank" rel="noopener"><code>low_priority_updates</code></a> 服务器系统变量设置为 等于1。</li>
<li>要给特定的<a href="https://dev.mysql.com/doc/refman/5.7/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a>或 <a href="https://dev.mysql.com/doc/refman/5.7/en/delete.html" target="_blank" rel="noopener"><code>DELETE</code></a>语句降低优先级，请使用<code>LOW_PRIORITY</code> 属性。</li>
<li>要赋予特定<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a> 语句更高的优先级，请使用 <code>HIGH_PRIORITY</code>属性。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener">第13.2.9节“ SELECT语句”</a>。</li>
<li>在 系统变量的值较低的情况下 启动<a href="https://dev.mysql.com/doc/refman/5.7/en/mysqld.html" target="_blank" rel="noopener"><strong>mysqld</strong></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_max_write_lock_count" target="_blank" rel="noopener"><code>max_write_lock_count</code></a>以强制MySQL <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a> 在对表进行特定次数的插入之后暂时提高所有等待表的语句的优先级。这允许 <code>READ</code>一定数量的锁之后的 <code>WRITE</code>锁。</li>
<li>如果您在混合<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/delete.html" target="_blank" rel="noopener"><code>DELETE</code></a>语句方面遇到问题 ，则 <code>LIMIT</code>可以选择 <a href="https://dev.mysql.com/doc/refman/5.7/en/delete.html" target="_blank" rel="noopener"><code>DELETE</code></a>。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/delete.html" target="_blank" rel="noopener">第13.2.2节“ DELETE语句”</a>。</li>
<li>使用<code>SQL_BUFFER_RESULT</code>with <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>语句可以帮助缩短表锁定的持续时间。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener">第13.2.9节“ SELECT语句”</a>。</li>
<li>通过允许对一个表中的列运行查询，而将更新限制在另一个表中的列，将表内容拆分为单独的表可能会有所帮助。</li>
<li>您可以更改锁定代码 <code>mysys/thr_lock.c</code>以使用单个队列。在这种情况下，写锁和读锁将具有相同的优先级，这可能对某些应用程序有所帮助。</li>
</ul>
<h3 id="8-11-3并发插入"><a href="#8-11-3并发插入" class="headerlink" title="8.11.3并发插入"></a>8.11.3并发插入</h3><p>所述<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_concurrent_insert" target="_blank" rel="noopener"><code>concurrent_insert</code></a>系统变量可以被设置为修改并发插入处理。默认情况下，该变量设置为<code>AUTO</code>（或1），并按上述方式处理并发插入。如果 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_concurrent_insert" target="_blank" rel="noopener"><code>concurrent_insert</code></a>设置为 <code>NEVER</code>（或0），则禁用并发插入。如果将变量设置为<code>ALWAYS</code> （或2），则即使对于已删除行的表，也允许在表末尾进行并发插入。另请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_concurrent_insert" target="_blank" rel="noopener"><code>concurrent_insert</code></a>系统变量的描述。</p>
<p>如果使用二进制日志，则并发插入将转换为<code>CREATE ... SELECT</code>或 <a href="https://dev.mysql.com/doc/refman/5.7/en/insert-select.html" target="_blank" rel="noopener"><code>INSERT ... SELECT</code></a>语句的普通插入。这样做是为了确保您可以通过在备份操作期间应用日志来重新创建表的精确副本。请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/binary-log.html" target="_blank" rel="noopener">第5.4.4节“二进制日志”</a>。另外，对于那些语句，在从中选择的表上放置了一个读取锁，从而阻止了对该表的插入。结果是该表的并发插入也必须等待。</p>
<p>使用<a href="https://dev.mysql.com/doc/refman/5.7/en/load-data.html" target="_blank" rel="noopener"><code>LOAD DATA</code></a>，如果您指定 <code>CONCURRENT</code>的<code>MyISAM</code> 表满足并发插入的条件（也就是说，中间不包含空闲块），则其他会话可以在<a href="https://dev.mysql.com/doc/refman/5.7/en/load-data.html" target="_blank" rel="noopener"><code>LOAD DATA</code></a>执行时从表中检索数据。即使没有其他会话同时使用该表，使用该 <code>CONCURRENT</code>选项<a href="https://dev.mysql.com/doc/refman/5.7/en/load-data.html" target="_blank" rel="noopener"><code>LOAD DATA</code></a>也会影响性能 。</p>
<p>如果指定<code>HIGH_PRIORITY</code>，则<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_low_priority_updates" target="_blank" rel="noopener"><code>--low-priority-updates</code></a>使用该选项启动服务器时它将覆盖该选项的效果 。这还会导致不使用并发插入。</p>
<p>为<a href="https://dev.mysql.com/doc/refman/5.7/en/lock-tables.html" target="_blank" rel="noopener"><code>LOCK TABLE</code></a>，之间的差<code>READ LOCAL</code>并且<code>READ</code>是 <code>READ LOCAL</code>允许不冲突的 <a href="https://dev.mysql.com/doc/refman/5.7/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>语句（并发插入），而锁被保持来执行。但是，如果您要在持有锁的同时使用服务器外部的进程来操作数据库，则不能使用此功能。</p>
<h3 id="8-11-4元数据锁定"><a href="#8-11-4元数据锁定" class="headerlink" title="8.11.4元数据锁定"></a>8.11.4元数据锁定</h3><p>MySQL使用元数据锁定来管理对数据库对象的并发访问并确保数据一致性。元数据锁定不仅适用于表，而且还适用于模式，存储程序（过程，函数，触发器，计划的事件），表空间，通过<a href="https://dev.mysql.com/doc/refman/5.7/en/locking-functions.html#function_get-lock" target="_blank" rel="noopener"><code>GET_LOCK()</code></a>函数获取的用户锁 （请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/locking-functions.html" target="_blank" rel="noopener">第12.14节“锁定函数”</a>）和通过锁获取的锁。<a href="https://dev.mysql.com/doc/refman/5.7/en/locking-service.html" target="_blank" rel="noopener">第28.3.1节“锁定服务”中</a>描述 <a href="https://dev.mysql.com/doc/refman/5.7/en/locking-service.html" target="_blank" rel="noopener">的锁定服务</a>。</p>
<p>性能模式 <a href="https://dev.mysql.com/doc/refman/5.7/en/metadata-locks-table.html" target="_blank" rel="noopener"><code>metadata_locks</code></a>表公开了元数据锁信息，这对于查看哪些会话持有锁，被阻止等待锁等很有用。有关详细信息，请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/metadata-locks-table.html" target="_blank" rel="noopener">第25.12.12.1节“ metadata_locks表”</a>。</p>
<p>元数据锁定确实涉及一些开销，随着查询量的增加而增加。多个查询尝试访问相同对象的情况越多，元数据争用就会增加。</p>
<p>元数据锁定不能代替表定义高速缓存，并且其互斥锁和锁定与互斥锁不同 <code>LOCK_open</code>。以下讨论提供了有关元数据锁定如何工作的一些信息。</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/metadata-locking.html#metadata-lock-acquisition" target="_blank" rel="noopener">元数据锁定获取</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/metadata-locking.html#metadata-lock-release" target="_blank" rel="noopener">元数据锁定释放</a></li>
</ul>
<h4 id="元数据锁定获取"><a href="#元数据锁定获取" class="headerlink" title="元数据锁定获取"></a>元数据锁定获取</h4><p>如果给定锁有多个等待者，则首先满足最高优先级的锁请求，但<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_max_write_lock_count" target="_blank" rel="noopener"><code>max_write_lock_count</code></a>系统变量除外 。写锁定请求比读锁定请求具有更高的优先级。但是，如果 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_max_write_lock_count" target="_blank" rel="noopener"><code>max_write_lock_count</code></a>将其设置为某个较低的值（例如10），则如果已将读取锁定请求传递给了10个写入锁定请求，则读取锁定请求可能比挂起的写入锁定请求优先。通常，不会发生此现象，因为 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_max_write_lock_count" target="_blank" rel="noopener"><code>max_write_lock_count</code></a>默认情况下它的值非常大。</p>
<p>语句不是一个接一个地获取元数据锁，并在此过程中执行死锁检测。</p>
<p>DML语句通常以在语句中提到表的顺序获取锁。</p>
<p>DDL语句<a href="https://dev.mysql.com/doc/refman/5.7/en/lock-tables.html" target="_blank" rel="noopener"><code>LOCK TABLES</code></a>和其他类似的语句尝试通过按名称顺序获取对显式命名的表的锁来减少并发DDL语句之间可能出现的死锁。对于隐式使用的表（例如，具有外键关系的表也必须被锁定），可以以不同的顺序获取锁。</p>
<p>例如，<a href="https://dev.mysql.com/doc/refman/5.7/en/rename-table.html" target="_blank" rel="noopener"><code>RENAME TABLE</code></a>一条DDL语句按名称顺序获取锁：</p>
<ul>
<li><p>该<a href="https://dev.mysql.com/doc/refman/5.7/en/rename-table.html" target="_blank" rel="noopener"><code>RENAME TABLE</code></a>语句重命名<code>tbla</code>为其他名称，并重命名<code>tblc</code>为 <code>tbla</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RENAME</span> <span class="keyword">TABLE</span> tbla <span class="keyword">TO</span> tbld, tblc <span class="keyword">TO</span> tbla;</span><br></pre></td></tr></table></figure>

<p>声明获取元数据锁，按顺序上 <code>tbla</code>，<code>tblc</code>和 <code>tbld</code>（因为<code>tbld</code> 如下<code>tblc</code>的名称顺序排列）：</p>
</li>
<li><p>这个稍有不同的语句还重命名 <code>tbla</code>为其他名称，并重命名 <code>tblc</code>为<code>tbla</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RENAME</span> <span class="keyword">TABLE</span> tbla <span class="keyword">TO</span> tblb, tblc <span class="keyword">TO</span> tbla;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，该语句获取元数据锁，按顺序上<code>tbla</code>， <code>tblb</code>和<code>tblc</code> （因为<code>tblb</code>先于 <code>tblc</code>在名称顺序排列）：</p>
</li>
</ul>
<p>这两个语句都按<code>tbla</code>和<code>tblc</code>顺序获得对和 的锁定，但是在剩余表名上的锁定是在之前还是之后获得的都不同<code>tblc</code>。</p>
<p>如以下示例所示，当多个事务同时执行时，元数据锁获取顺序可能会在操作结果上产生差异。</p>
<p>与两个表开始<code>x</code>和 <code>x_new</code>具有相同的结构。三个客户发出涉及这些表的语句：</p>
<p>客户1：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LOCK</span> <span class="keyword">TABLE</span> x WRITE, x_new WRITE;</span><br></pre></td></tr></table></figure>

<p>该语句按名称顺序在<code>x</code>和上请求并获取写锁定<code>x_new</code>。</p>
<p>客户2：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> x <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>该语句请求并阻塞以等待写入锁定 <code>x</code>。</p>
<p>客户3：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RENAME</span> <span class="keyword">TABLE</span> x <span class="keyword">TO</span> x_old, x_new <span class="keyword">TO</span> x;</span><br></pre></td></tr></table></figure>

<p>声明要求独占锁在名字顺序 <code>x</code>，<code>x_new</code>和 <code>x_old</code>，而是块等待上了锁 <code>x</code>。</p>
<p>客户1：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UNLOCK</span> <span class="keyword">TABLES</span>;</span><br></pre></td></tr></table></figure>

<p>该语句释放对<code>x</code> 和的写锁<code>x_new</code>。<code>x</code>客户端3 的排他锁定请求 比客户端2的写锁定请求具有更高的优先级，因此客户端3在上获取其锁定<code>x</code>，然后在<code>x_new</code> 和上获取其锁定<code>x_old</code>，执行重命名并释放其锁定。客户端2然后获取其锁定 <code>x</code>，执行插入操作，然后释放其锁定。</p>
<p>锁定获取顺序导致在 <a href="https://dev.mysql.com/doc/refman/5.7/en/rename-table.html" target="_blank" rel="noopener"><code>RENAME TABLE</code></a>之前执行<a href="https://dev.mysql.com/doc/refman/5.7/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>。在 <code>x</code>进入时发生的插入是被命名表<code>x_new</code>时，客户端2日插入，并更名为<code>x</code>通过客户端3：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM x;</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| i    |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">|    1 |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM x_old;</span><br><span class="line">Empty <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>现在，而不是首先命名表<code>x</code>，并 <code>new_x</code>具有相同的结构。同样，三个客户发出涉及这些表的语句：</p>
<p>客户1：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LOCK</span> <span class="keyword">TABLE</span> x WRITE, new_x WRITE;</span><br></pre></td></tr></table></figure>

<p>该语句按名称顺序在<code>new_x</code>和上请求并获取写锁定<code>x</code>。</p>
<p>客户2：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> x <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>该语句请求并阻塞以等待写入锁定 <code>x</code>。</p>
<p>客户3：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RENAME</span> <span class="keyword">TABLE</span> x <span class="keyword">TO</span> old_x, new_x <span class="keyword">TO</span> x;</span><br></pre></td></tr></table></figure>

<p>声明要求独占锁在名字顺序 <code>new_x</code>，<code>old_x</code>和 <code>x</code>，而是块等待上了锁 <code>new_x</code>。</p>
<p>客户1：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UNLOCK</span> <span class="keyword">TABLES</span>;</span><br></pre></td></tr></table></figure>

<p>该语句释放对<code>x</code> 和的写锁<code>new_x</code>。对于<code>x</code>，唯一未决的请求是客户端2发出的，因此客户端2获取其锁，执行插入操作，然后释放该锁。对于 <code>new_x</code>，唯一待处理的请求是由客户端3进行的，客户端3被允许获取该锁（以及上的锁<code>old_x</code>）。<code>x</code>在Client 2插入完成并释放其锁定之前，重命名操作仍会阻止锁定。然后，客户端3获取对的锁定<code>x</code>，执行重命名，然后释放其锁定。</p>
<p>在这种情况下，锁定获取顺序导致在 <a href="https://dev.mysql.com/doc/refman/5.7/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>之前执行 <a href="https://dev.mysql.com/doc/refman/5.7/en/rename-table.html" target="_blank" rel="noopener"><code>RENAME TABLE</code></a>。将 <code>x</code>其插入到时原来是<code>x</code>，现在更名为 <code>old_x</code>通过重命名操作：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM x;</span><br><span class="line">Empty <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> old_x;</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| i    |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">|    1 |</span><br><span class="line">+<span class="comment">------+</span></span><br></pre></td></tr></table></figure>

<p>如前例所示，如果并发语句中的锁获取顺序对应用程序的操作结果有所不同，则可以调整表名以影响锁获取的顺序。</p>
<h4 id="元数据锁定释放"><a href="#元数据锁定释放" class="headerlink" title="元数据锁定释放"></a>元数据锁定释放</h4><p>为确保事务可序列化，服务器不得允许一个会话对在另一会话中未完成的显式或隐式启动的事务中使用的表执行数据定义语言（DDL）语句。服务器通过获取事务中使用的表上的元数据锁并推迟释放这些锁直到事务结束来实现此目的。表上的元数据锁可防止更改表的结构。这种锁定方法的含义是，一个事务内的一个事务正在使用的表在事务结束之前，不能由其他会话在DDL语句中使用。</p>
<p>该原理不仅适用于事务表，而且适用于非事务表。假设会话开始使用事务表<code>t</code>和非事务表的 事务 <code>nt</code>，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> nt;</span><br></pre></td></tr></table></figure>

<p>服务器在两者上都持有元数据锁<code>t</code> ，<code>nt</code>直到事务结束。如果另一个会话在任一表上尝试DDL或写锁定操作，它将阻塞，直到在事务结束释放元数据锁定为止。例如，如果第二个会话尝试执行以下任何操作，则它将阻塞：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> t;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t ...;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> nt;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> nt ...;</span><br><span class="line"><span class="keyword">LOCK</span> <span class="keyword">TABLE</span> t ... WRITE;</span><br></pre></td></tr></table></figure>

<p>相同的行为适用于 <a href="https://dev.mysql.com/doc/refman/5.7/en/lock-tables.html" target="_blank" rel="noopener"><code>LOCK TABLES ... READ</code></a>。即，更新该表（事务性或非事务性）的显式或隐式启动的事务将<code>LOCK TABLES ... READ</code>对该表进行阻塞和阻塞。</p>
<p>如果服务器获取语法上有效但在执行过程中失败的语句的元数据锁，则它不会尽早释放该锁。锁定释放仍然推迟到事务结束，因为失败的语句将被写入二进制日志，并且锁定可以保护日志的一致性。</p>
<p>在自动提交模式下，每个语句实际上是一个完整的事务，因此为该语句获取的元数据锁仅保留到该语句的末尾。</p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/prepare.html" target="_blank" rel="noopener"><code>PREPARE</code></a>准备好语句后，即使在多语句事务中进行准备，也会释放语句 期间获取的元数据锁 。</p>
<h3 id="8-11-5外部锁定"><a href="#8-11-5外部锁定" class="headerlink" title="8.11.5外部锁定"></a>8.11.5外部锁定</h3><ul>
<li><p>如果运行使用相同数据库目录的多个服务器（不建议），则每个服务器必须启用了外部锁定。</p>
</li>
<li><p>如果使用<a href="https://dev.mysql.com/doc/refman/5.7/en/myisamchk.html" target="_blank" rel="noopener"><strong>myisamchk</strong></a>对表执行表维护操作 <a href="https://dev.mysql.com/doc/refman/5.7/en/myisam-storage-engine.html" target="_blank" rel="noopener"><code>MyISAM</code></a>，则必须确保服务器未运行，或者服务器已启用外部锁定，以便根据需要锁定表文件以与<a href="https://dev.mysql.com/doc/refman/5.7/en/myisamchk.html" target="_blank" rel="noopener"><strong>myisamchk</strong></a>协作以 访问表。使用<a href="https://dev.mysql.com/doc/refman/5.7/en/myisampack.html" target="_blank" rel="noopener"><strong>myisampack</strong></a>打包 <a href="https://dev.mysql.com/doc/refman/5.7/en/myisam-storage-engine.html" target="_blank" rel="noopener"><code>MyISAM</code></a>表也是如此 。</p>
<p>如果服务器在启用了外部锁定的情况下运行，则可以随时使用<a href="https://dev.mysql.com/doc/refman/5.7/en/myisamchk.html" target="_blank" rel="noopener"><strong>myisamchk</strong></a>进行读取操作，例如检查表。在这种情况下，如果服务器尝试更新<a href="https://dev.mysql.com/doc/refman/5.7/en/myisamchk.html" target="_blank" rel="noopener"><strong>myisamchk</strong></a>正在使用的表 ，则服务器将等待<a href="https://dev.mysql.com/doc/refman/5.7/en/myisamchk.html" target="_blank" rel="noopener"><strong>myisamchk</strong></a>完成后才能继续。</p>
<p>如果使用<a href="https://dev.mysql.com/doc/refman/5.7/en/myisamchk.html" target="_blank" rel="noopener"><strong>myisamchk</strong></a>进行诸如修复或优化表之类的写操作，或者使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/myisampack.html" target="_blank" rel="noopener"><strong>myisampack</strong></a>打包表，则 <em>必须</em>始终确保 <a href="https://dev.mysql.com/doc/refman/5.7/en/mysqld.html" target="_blank" rel="noopener"><strong>mysqld</strong></a>服务器未使用该表。如果不停止<a href="https://dev.mysql.com/doc/refman/5.7/en/mysqld.html" target="_blank" rel="noopener"><strong>mysqld</strong></a>，至少 在运行<a href="https://dev.mysql.com/doc/refman/5.7/en/myisamchk.html" target="_blank" rel="noopener"><strong>myisamchk</strong></a>之前先执行 <a href="https://dev.mysql.com/doc/refman/5.7/en/mysqladmin.html" target="_blank" rel="noopener"><strong>mysqladmin flush-tables</strong></a>。如果服务器和<a href="https://dev.mysql.com/doc/refman/5.7/en/myisamchk.html" target="_blank" rel="noopener"><strong>myisamchk</strong></a>同时访问表，则 表<em>可能已损坏</em>。</p>
</li>
</ul>
<p>启用外部锁定后，每个需要访问表的进程都将在继续访问表之前获取表文件的文件系统锁。如果无法获取所有必需的锁，则会阻止该进程访问表，直到获得锁为止（在当前持有锁的进程释放它们之后）。</p>
<p>外部锁定会影响服务器性能，因为服务器有时必须等待其他进程才能访问表。</p>
<p>如果您运行一台服务器来访问给定的数据目录（通常是这种情况），并且在服务器运行时不需要其他程序（例如<a href="https://dev.mysql.com/doc/refman/5.7/en/myisamchk.html" target="_blank" rel="noopener"><strong>myisamchk）</strong></a>来修改表，则不需要外部锁定。如果仅 使用其他程序<em>读取</em>表，则不需要外部锁定，尽管 如果<a href="https://dev.mysql.com/doc/refman/5.7/en/myisamchk.html" target="_blank" rel="noopener"><strong>myisamchk</strong></a>在读取表时服务器更改表，<a href="https://dev.mysql.com/doc/refman/5.7/en/myisamchk.html" target="_blank" rel="noopener"><strong>myisamchk</strong></a>可能会报告警告 。</p>
<p>禁用外部锁定后，要使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/myisamchk.html" target="_blank" rel="noopener"><strong>myisamchk</strong></a>，必须在<a href="https://dev.mysql.com/doc/refman/5.7/en/myisamchk.html" target="_blank" rel="noopener"><strong>myisamchk</strong></a>执行时停止服务器，或者在运行<a href="https://dev.mysql.com/doc/refman/5.7/en/myisamchk.html" target="_blank" rel="noopener"><strong>myisamchk</strong></a>之前锁定并刷新表。（请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/system-optimization.html" target="_blank" rel="noopener">第8.12.1节“系统因素”</a>。）为避免此要求，请使用<a href="https://dev.mysql.com/doc/refman/5.7/en/check-table.html" target="_blank" rel="noopener"><code>CHECK TABLE</code></a> and <a href="https://dev.mysql.com/doc/refman/5.7/en/repair-table.html" target="_blank" rel="noopener"><code>REPAIR TABLE</code></a>语句检查和修复<a href="https://dev.mysql.com/doc/refman/5.7/en/myisam-storage-engine.html" target="_blank" rel="noopener"><code>MyISAM</code></a>表。</p>
<p>对于<a href="https://dev.mysql.com/doc/refman/5.7/en/mysqld.html" target="_blank" rel="noopener"><strong>mysqld</strong></a>，外部锁定由<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_skip_external_locking" target="_blank" rel="noopener"><code>skip_external_locking</code></a>系统变量的值控制 。启用此变量后，将禁用外部锁定，反之亦然。默认情况下，外部锁定是禁用的。</p>
<p>可以使用<a href="https://dev.mysql.com/doc/refman/5.7/en/server-options.html#option_mysqld_external-locking" target="_blank" rel="noopener"><code>--external-locking</code></a>或 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-options.html#option_mysqld_external-locking" target="_blank" rel="noopener"><code>--skip-external-locking</code></a> 选项在服务器启动时控制外部锁定的使用。</p>
<p>如果确实使用外部锁定选项来启用<a href="https://dev.mysql.com/doc/refman/5.7/en/myisam-storage-engine.html" target="_blank" rel="noopener"><code>MyISAM</code></a>来自许多MySQL进程的表更新 ，则必须确保满足以下条件：</p>
<ul>
<li>不要对使用由另一个进程更新的表的查询使用查询缓存。</li>
<li>不要将<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_delay_key_write" target="_blank" rel="noopener"><code>delay_key_write</code></a>系统变量设置为启动服务器，也不要 对任何共享表<code>ALL</code>使用 <code>DELAY_KEY_WRITE=1</code>table选项。否则，可能会发生索引损坏。</li>
</ul>
<p>满足这些条件的最简单方法是始终 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-options.html#option_mysqld_external-locking" target="_blank" rel="noopener"><code>--external-locking</code></a>与<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_delay_key_write" target="_blank" rel="noopener"><code>--delay-key-write=OFF</code></a>和 一起使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_query_cache_size" target="_blank" rel="noopener"><code>--query-cache-size=0</code></a>。（默认情况下不会执行此操作，因为在许多设置中，混合使用上述选项会很有用。）</p>
<h2 id="8-12优化MySQL服务器"><a href="#8-12优化MySQL服务器" class="headerlink" title="8.12优化MySQL服务器"></a>8.12优化MySQL服务器</h2><ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/system-optimization.html" target="_blank" rel="noopener">8.12.1系统因素</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/disk-issues.html" target="_blank" rel="noopener">8.12.2优化磁盘I / O</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/symbolic-links.html" target="_blank" rel="noopener">8.12.3使用符号链接</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizing-memory.html" target="_blank" rel="noopener">8.12.4优化内存使用</a></li>
</ul>
<p>本节讨论数据库服务器的优化技术，主要是处理系统配置而不是调整SQL语句。本节中的信息适用于想要确保所管理服务器之间的性能和可伸缩性的DBA。为开发人员构建包括设置数据库在内的安装脚本；以及自己运行MySQL进行开发，测试等工作的人们，他们希望最大限度地提高自己的生产力。</p>
<h3 id="8-12-1系统因素"><a href="#8-12-1系统因素" class="headerlink" title="8.12.1系统因素"></a>8.12.1系统因素</h3><p>一些系统级因素会在很大程度上影响性能：</p>
<ul>
<li><p>如果有足够的RAM，则可以删除所有交换设备。在某些情况下，即使您有可用内存，某些操作系统也会使用交换设备。</p>
</li>
<li><p>避免对<a href="https://dev.mysql.com/doc/refman/5.7/en/myisam-storage-engine.html" target="_blank" rel="noopener"><code>MyISAM</code></a>表进行外部锁定 。默认设置是禁用外部锁定。在 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-options.html#option_mysqld_external-locking" target="_blank" rel="noopener"><code>--external-locking</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-options.html#option_mysqld_external-locking" target="_blank" rel="noopener"><code>--skip-external-locking</code></a> 选项明确地启用和禁用外部锁定。</p>
<p>只要仅运行一台服务器，禁用外部锁定就不会影响MySQL的功能。只要记住在运行<a href="https://dev.mysql.com/doc/refman/5.7/en/myisamchk.html" target="_blank" rel="noopener"><strong>myisamchk</strong></a>之前关闭服务器（或锁定并刷新相关表）即可 。在某些系统上，必须禁用外部锁定，因为无论如何它都无法工作。</p>
<p>唯一不能禁用外部锁定的情况是 对同一数据运行多个MySQL <em>服务器<em>（而非客户端），或者如果运行 [*</em>myisamchk*<em>](<a href="https://dev.mysql.com/doc/refman/5.7/en/myisamchk.html)来检查（而非修复）表而不通知服务器先刷新并锁定表。请注意，通常" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/myisamchk.html)来检查（而非修复）表而不通知服务器先刷新并锁定表。请注意，通常</a></em>不</em> 建议使用多个MySQL服务器并发访问同一数据，除非使用NDB Cluster。</p>
<p>该<a href="https://dev.mysql.com/doc/refman/5.7/en/lock-tables.html" target="_blank" rel="noopener"><code>LOCK TABLES</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/lock-tables.html" target="_blank" rel="noopener"><code>UNLOCK TABLES</code></a>语句使用内部锁定，所以你可以使用他们，即使外部锁定被禁用。</p>
</li>
</ul>
<h3 id="8-12-2优化磁盘I-O"><a href="#8-12-2优化磁盘I-O" class="headerlink" title="8.12.2优化磁盘I / O"></a>8.12.2优化磁盘I / O</h3><h4 id="在MySQL中使用NFS"><a href="#在MySQL中使用NFS" class="headerlink" title="在MySQL中使用NFS"></a>在MySQL中使用NFS</h4><p>在考虑是否将NFS与MySQL一起使用时，您应该谨慎。根据操作系统和NFS版本的不同，潜在的问题包括：</p>
<ul>
<li>放置在NFS卷上的MySQL数据和日志文件被锁定，无法使用。例如，在多个MySQL实例访问同一数据目录或由于断电而导致MySQL不正确关闭的情况下，可能会发生锁定问题。NFS版本4通过引入咨询和基于租约的锁定解决了潜在的锁定问题。但是，不建议在MySQL实例之间共享数据目录。</li>
<li>由于接收到的消息混乱或网络流量丢失而导致数据不一致。为避免此问题，请使用TCP和<code>hard</code>和 <code>intr</code>mount选项。</li>
<li>最大文件大小限制。NFS版本2客户端只能访问文件的最低2GB（带符号的32位偏移量）。NFS版本3客户端支持更大的文件（最大64位偏移）。支持的最大文件大小还取决于NFS服务器的本地文件系统。</li>
</ul>
<p>与在此类环境之外使用NFS相比，在专业的SAN环境或其他存储系统中使用NFS往往会提供更高的可靠性。但是，SAN环境中的NFS可能比直接连接或总线连接的非旋转存储要慢。</p>
<p>如果选择使用NFS，则建议使用NFS版本4或更高版本，以及在部署到生产环境之前彻底测试NFS设置。</p>
<h3 id="8-12-3使用符号链接"><a href="#8-12-3使用符号链接" class="headerlink" title="8.12.3使用符号链接"></a>8.12.3使用符号链接</h3><ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/symbolic-links-to-databases.html" target="_blank" rel="noopener">8.12.3.1在Unix上对数据库使用符号链接</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/symbolic-links-to-tables.html" target="_blank" rel="noopener">8.12.3.2在Unix上对MyISAM表使用符号链接</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/windows-symbolic-links.html" target="_blank" rel="noopener">8.12.3.3在Windows上对数据库使用符号链接</a></li>
</ul>
<p>对于<code>InnoDB</code>表，请按照<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-create-table-external.html" target="_blank" rel="noopener">第14.6.1.2节“</a>在<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-create-table-external.html" target="_blank" rel="noopener">外部创建表”中的</a>说明，使用语句的<code>DATA DIRECTORY</code>子句<a href="https://dev.mysql.com/doc/refman/5.7/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a>代替符号链接。此新功能是受支持的跨平台技术。</p>
<p>推荐的方法是将整个数据库目录符号链接到另一个磁盘。Symlink <code>MyISAM</code>表仅是万不得已的方法。</p>
<p>要确定数据目录的位置，请使用以下语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'datadir'</span>;</span><br></pre></td></tr></table></figure>

<h4 id="8-12-3-1在Unix上对数据库使用符号链接"><a href="#8-12-3-1在Unix上对数据库使用符号链接" class="headerlink" title="8.12.3.1在Unix上对数据库使用符号链接"></a>8.12.3.1在Unix上对数据库使用符号链接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; mkdir &#x2F;dr1&#x2F;databases&#x2F;test</span><br><span class="line">shell&gt; ln -s &#x2F;dr1&#x2F;databases&#x2F;test &#x2F;path&#x2F;to&#x2F;datadir</span><br></pre></td></tr></table></figure>

<p>MySQL不支持将一个目录链接到多个数据库。只要您不在数据库之间建立符号链接，就可以使用符号链接替换数据库目录。假设您<code>db1</code>在MySQL数据目录下有一个数据库 ，然后建立一个<code>db2</code>指向以下内容 的符号链接<code>db1</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; cd &#x2F;path&#x2F;to&#x2F;datadir</span><br><span class="line">shell&gt; ln -s db1 db2</span><br></pre></td></tr></table></figure>

<p>其结果是，对于任何表<code>tbl_a</code>中 <code>db1</code>，也似乎是一个表 <code>tbl_a</code>中<code>db2</code>。如果一个客户端更新，<code>db1.tbl_a</code>而另一个客户端更新<code>db2.tbl_a</code>，则可能会出现问题。</p>
<h4 id="8-12-3-2在Unix上对MyISAM表使用符号链接"><a href="#8-12-3-2在Unix上对MyISAM表使用符号链接" class="headerlink" title="8.12.3.2在Unix上对MyISAM表使用符号链接"></a>8.12.3.2在Unix上对MyISAM表使用符号链接</h4><p>不要在没有完全操作<code>realpath()</code>调用的系统上符号链接表。（Linux和Solaris支持<code>realpath()</code>）。要确定您的系统是否支持符号链接，请<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_have_symlink" target="_blank" rel="noopener"><code>have_symlink</code></a>使用以下语句检查系统变量的值：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'have_symlink'</span>;</span><br></pre></td></tr></table></figure>

<p><code>MyISAM</code> 表 的符号链接的处理方式如下：</p>
<ul>
<li><p>在数据目录中，始终具有表格式（<code>.frm</code>）文件，数据（<code>.MYD</code>）文件和索引（<code>.MYI</code>）文件。数据文件和索引文件可以移动到其他位置，并在数据目录中用符号链接替换。格式文件不能。</p>
</li>
<li><p>您可以将数据文件和索引文件独立地符号链接到不同的目录。</p>
</li>
<li><p>要指示正在运行的MySQL服务器执行符号链接，请使用<code>DATA DIRECTORY</code>和 <code>INDEX DIRECTORY</code>选项 <a href="https://dev.mysql.com/doc/refman/5.7/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a>。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/create-table.html" target="_blank" rel="noopener">第13.1.18节“ CREATE TABLE语句”</a>。或者，如果 <a href="https://dev.mysql.com/doc/refman/5.7/en/mysqld.html" target="_blank" rel="noopener"><strong>mysqld</strong></a>未运行，则可以 从命令行使用<strong>ln -s</strong>手动完成符号链接。</p>
<p>注意</p>
<p>与<code>DATA DIRECTORY</code>和<code>INDEX DIRECTORY</code>选项中的一个或两个一起使用的路径可能不包括MySQL <code>data</code>目录。错误32167）</p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/myisamchk.html" target="_blank" rel="noopener"><strong>myisamchk</strong></a>不会用数据文件或索引文件替换符号链接。它直接在符号链接指向的文件上工作。在数据文件或索引文件所在的目录中创建任何临时文件。同样是真实的 <a href="https://dev.mysql.com/doc/refman/5.7/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/optimize-table.html" target="_blank" rel="noopener"><code>OPTIMIZE TABLE</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/repair-table.html" target="_blank" rel="noopener"><code>REPAIR TABLE</code></a>语句。</p>
</li>
<li><p>注意</p>
<p>删除使用符号链接的表时，符号 <em>链接和符号链接指向的文件都会被删除</em>。这是一个非常好的理由<em>不</em>运行 <a href="https://dev.mysql.com/doc/refman/5.7/en/mysqld.html" target="_blank" rel="noopener"><strong>mysqld的</strong></a>作为<code>root</code> 操作系统用户或允许操作系统的用户将不得不MySQL数据库目录的写入权限。</p>
</li>
<li><p>如果使用<a href="https://dev.mysql.com/doc/refman/5.7/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE ... RENAME</code></a>或重命名表， <a href="https://dev.mysql.com/doc/refman/5.7/en/rename-table.html" target="_blank" rel="noopener"><code>RENAME TABLE</code></a>并且没有将表移至另一个数据库，则数据库目录中的符号链接将重命名为新名称，并且数据文件和索引文件也将相应重命名。</p>
</li>
<li><p>如果使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE ... RENAME</code></a>或<a href="https://dev.mysql.com/doc/refman/5.7/en/rename-table.html" target="_blank" rel="noopener"><code>RENAME TABLE</code></a>将表移动到另一个数据库，则该表将移动到另一个数据库目录。如果表名更改，则新数据库目录中的符号链接将重命名为新名称，并且数据文件和索引文件也将相应重命名。</p>
</li>
<li><p>如果不使用符号链接，则使用该 选项启动 <a href="https://dev.mysql.com/doc/refman/5.7/en/mysqld.html" target="_blank" rel="noopener"><strong>mysqld</strong></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/server-options.html#option_mysqld_symbolic-links" target="_blank" rel="noopener"><code>--skip-symbolic-links</code></a>以确保没有人可以使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/mysqld.html" target="_blank" rel="noopener"><strong>mysqld</strong></a>删除或重命名数据目录之外的文件。</p>
</li>
</ul>
<p>不支持这些表符号链接操作：</p>
<ul>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>忽略 <code>DATA DIRECTORY</code>和<code>INDEX DIRECTORY</code>表选项。</p>
</li>
<li><p>如前所述，只有数据和索引文件可以是符号链接。该<code>.frm</code>文件绝 <em>不能</em>是符号链接。尝试执行此操作（例如，使一个表名成为另一表名的同义词）会产生错误的结果。假设您<code>db1</code>在MySQL数据目录下有一个数据库，<code>tbl1</code>在该数据库中有一个表，并且在该<code>db1</code>目录中建立了一个<code>tbl2</code>指向以下内容 的符号链接<code>tbl1</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; cd &#x2F;path&#x2F;to&#x2F;datadir&#x2F;db1</span><br><span class="line">shell&gt; ln -s tbl1.frm tbl2.frm</span><br><span class="line">shell&gt; ln -s tbl1.MYD tbl2.MYD</span><br><span class="line">shell&gt; ln -s tbl1.MYI tbl2.MYI</span><br></pre></td></tr></table></figure>

<p>如果一个线程读取<code>db1.tbl1</code>而另一个线程更新， 则会导致问题 <code>db1.tbl2</code>：</p>
<ul>
<li>查询缓存是“ 愚弄的 ”（无法得知<code>tbl1</code>尚未更新，因此它会返回过时的结果）。</li>
<li><code>ALTER``tbl2</code>失败声明 。</li>
</ul>
<h4 id="8-12-3-3在Windows上对数据库使用符号链接"><a href="#8-12-3-3在Windows上对数据库使用符号链接" class="headerlink" title="8.12.3.3在Windows上对数据库使用符号链接"></a>8.12.3.3在Windows上对数据库使用符号链接</h4></li>
</ul>
<p>  假设你要放置数据库目录中指定的数据库<code>mydb</code>的 <code>D:\data\mydb</code>。为此，请在MySQL数据目录中创建一个指向的符号链接 <code>D:\data\mydb</code>。但是，在创建符号链接之前<code>D:\data\mydb</code>，请根据需要通过创建目录来确保该 目录存在。如果您已经有一个<code>mydb</code>在数据目录中命名的数据库目录，请将其移至<code>D:\data</code>。否则，符号链接将无效。为避免出现问题，请在移动数据库目录时确保服务器未在运行。</p>
<p>  在Windows上，可以使用<strong>mklink</strong>命令创建符号链接 。此命令需要管理特权。</p>
<ol>
<li><p>将位置更改为数据目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; cd \path\to\datadir</span><br></pre></td></tr></table></figure>
</li>
<li><p>在数据目录中，创建一个名为的符号链接，该链接 <code>mydb</code>指向数据库目录的位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; mklink &#x2F;d mydb D:\data\mydb</span><br></pre></td></tr></table></figure>

<p>之后，将在<code>mydb</code>中创建数据库中创建的 所有表 <code>D:\data\mydb</code>。</p>
<h3 id="8-12-4优化内存使用"><a href="#8-12-4优化内存使用" class="headerlink" title="8.12.4优化内存使用"></a>8.12.4优化内存使用</h3></li>
</ol>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/memory-use.html" target="_blank" rel="noopener">8.12.4.1 MySQL如何使用内存</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/large-page-support.html" target="_blank" rel="noopener">8.12.4.2启用大页面支持</a></li>
<li></li>
</ul>
<h4 id="8-12-4-1-MySQL如何使用内存"><a href="#8-12-4-1-MySQL如何使用内存" class="headerlink" title="8.12.4.1 MySQL如何使用内存"></a>8.12.4.1 MySQL如何使用内存</h4><p>MySQL分配缓冲区和高速缓存以提高数据库操作的性能。默认配置旨在允许MySQL服务器在具有大约512MB RAM的虚拟机上启动。您可以通过增加某些与缓存和缓冲区相关的系统变量的值来提高MySQL性能。您还可以修改默认配置，以在内存有限的系统上运行MySQL。</p>
<p>下表描述了MySQL使用内存的一些方式。如果适用，将引用相关的系统变量。有些项目是存储引擎或特定于功能的。</p>
<ul>
<li><p>所述<code>InnoDB</code>缓冲器池是保持高速缓存的存储区域<code>InnoDB</code>表，索引，及其它辅助缓冲器中的数据。为了提高大容量读取操作的效率，缓冲池被分为多个<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_page" target="_blank" rel="noopener">页面</a> ，这些<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_page" target="_blank" rel="noopener">页面</a>可能包含多个行。为了提高缓存管理的效率，缓冲池被实现为页面的链接列表。使用<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_lru" target="_blank" rel="noopener">LRU</a>算法的变体，将很少使用的数据从缓存中老化掉 。有关更多信息，请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool.html" target="_blank" rel="noopener">第14.5.1节“缓冲池”</a>。</p>
<p>缓冲池的大小对于系统性能很重要：</p>
<ul>
<li><code>InnoDB</code>使用<code>malloc()</code>操作在服务器启动时为整个缓冲池分配内存 。所述 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_size" target="_blank" rel="noopener"><code>innodb_buffer_pool_size</code></a> 系统变量定义缓冲池大小。通常，建议 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_size" target="_blank" rel="noopener"><code>innodb_buffer_pool_size</code></a> 值为系统内存的50％到75％。 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_size" target="_blank" rel="noopener"><code>innodb_buffer_pool_size</code></a> 服务器运行时可以动态配置。有关更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool-resize.html" target="_blank" rel="noopener">第14.8.3.1节“配置InnoDB缓冲池大小”</a>。</li>
<li>在具有大量内存的系统上，可以通过将缓冲池划分为多个<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_buffer_pool_instance" target="_blank" rel="noopener">缓冲池实例</a>来提高并发性 。所述 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_instances" target="_blank" rel="noopener"><code>innodb_buffer_pool_instances</code></a> 系统变量定义缓冲池实例的数量。</li>
<li>太小的缓冲池可能会导致过度搅动，因为从缓冲池中刷新页面只是在短时间内再次需要。</li>
<li>缓冲池太大可能会由于争用内存而导致交换。</li>
</ul>
</li>
<li><p>所有线程共享<a href="https://dev.mysql.com/doc/refman/5.7/en/myisam-storage-engine.html" target="_blank" rel="noopener"><code>MyISAM</code></a> 密钥缓冲区。的 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_key_buffer_size" target="_blank" rel="noopener"><code>key_buffer_size</code></a>系统变量决定其大小。</p>
<p>对于<code>MyISAM</code>服务器打开的每个表，索引文件都会打开一次；对于访问该表的每个并发运行的线程，数据文件都会打开一次。对于每个并发线程，分配一个表结构，每个列的列结构以及大小的缓冲区 （其中最大行长，不计 列）。一 列需要五到八个字节加上数据的长度 。该 存储引擎维护用于内部使用一个额外的行缓冲。 <code>3 * *N*</code><em>N</em><a href="https://dev.mysql.com/doc/refman/5.7/en/blob.html" target="_blank" rel="noopener"><code>BLOB</code></a><a href="https://dev.mysql.com/doc/refman/5.7/en/blob.html" target="_blank" rel="noopener"><code>BLOB</code></a><a href="https://dev.mysql.com/doc/refman/5.7/en/blob.html" target="_blank" rel="noopener"><code>BLOB</code></a><code>MyISAM</code></p>
</li>
<li><p>所述<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_myisam_use_mmap" target="_blank" rel="noopener"><code>myisam_use_mmap</code></a> 系统变量可以被设置为1，使能对所有内存映射<code>MyISAM</code>表。</p>
</li>
<li><p>如果内部内存临时表太大（使用<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_tmp_table_size" target="_blank" rel="noopener"><code>tmp_table_size</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_max_heap_table_size" target="_blank" rel="noopener"><code>max_heap_table_size</code></a> 系统变量确定 ），MySQL会自动将表从内存格式转换为磁盘格式。磁盘临时表使用<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_internal_tmp_disk_storage_engine" target="_blank" rel="noopener"><code>internal_tmp_disk_storage_engine</code></a> 系统变量定义的存储引擎 。您可以按照<a href="https://dev.mysql.com/doc/refman/5.7/en/internal-temporary-tables.html" target="_blank" rel="noopener">第8.4.4节“ MySQL中的内部临时表使用”中</a>所述增加允许的临时表大小 。</p>
<p>对于使用<a href="https://dev.mysql.com/doc/refman/5.7/en/memory-storage-engine.html" target="_blank" rel="noopener"><code>MEMORY</code></a>显式创建的表<a href="https://dev.mysql.com/doc/refman/5.7/en/create-table.html" target="_blank" rel="noopener"><code>CREATE TABLE</code></a>，只有 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_max_heap_table_size" target="_blank" rel="noopener"><code>max_heap_table_size</code></a> 系统变量确定表可以增长到多大，并且不转换为磁盘格式。</p>
</li>
<li><p>在<a href="https://dev.mysql.com/doc/refman/5.7/en/performance-schema.html" target="_blank" rel="noopener">MySQL性能模式</a>是在低级别监控MySQL服务器执行的功能。性能架构动态地增量分配内存，将其内存使用量扩展到实际服务器负载，而不是在服务器启动期间分配所需的内存。一旦分配了内存，就不会释放它，除非重新启动服务器。有关更多信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/performance-schema-memory-model.html" target="_blank" rel="noopener">第25.17节“性能模式内存分配模型”</a>。</p>
</li>
<li><p>服务器用来管理客户端连接的每个线程都需要一些特定于线程的空间。下表列出了这些内容以及哪些系统变量控制它们的大小：</p>
<ul>
<li>堆栈（<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_thread_stack" target="_blank" rel="noopener"><code>thread_stack</code></a>）</li>
<li>连接缓冲区（<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_net_buffer_length" target="_blank" rel="noopener"><code>net_buffer_length</code></a>）</li>
<li>结果缓冲区（<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_net_buffer_length" target="_blank" rel="noopener"><code>net_buffer_length</code></a>）</li>
</ul>
<p>连接缓冲区和结果缓冲区<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_net_buffer_length" target="_blank" rel="noopener"><code>net_buffer_length</code></a>均以等于字节的大小开头 ，但<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_max_allowed_packet" target="_blank" rel="noopener"><code>max_allowed_packet</code></a>根据需要动态扩展到 字节。<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_net_buffer_length" target="_blank" rel="noopener"><code>net_buffer_length</code></a>在每个SQL语句之后，结果缓冲区缩小为 字节。在运行语句时，还会分配当前语句字符串的副本。</p>
<p>每个连接线程都使用内存来计算语句摘要。服务器<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_max_digest_length" target="_blank" rel="noopener"><code>max_digest_length</code></a>为每个会话分配 字节。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/performance-schema-statement-digests.html" target="_blank" rel="noopener">第25.10节“性能模式语句摘要”</a>。</p>
</li>
<li><p>所有线程共享相同的基本内存。</p>
</li>
<li><p>当不再需要线程时，分配给它的内存将释放并返回系统，除非该线程返回线程高速缓存。在这种情况下，内存将保持分配状态。</p>
</li>
<li><p>每个执行表顺序扫描的请求都分配一个读取缓冲区。的 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_read_buffer_size" target="_blank" rel="noopener"><code>read_buffer_size</code></a>系统变量决定缓冲器大小。</p>
</li>
<li><p>当以任意顺序（例如，按照排序）读取行时， 可以分配一个 随机读取的缓冲区以避免磁盘查找。的 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_read_rnd_buffer_size" target="_blank" rel="noopener"><code>read_rnd_buffer_size</code></a> 系统变量决定缓冲器大小。</p>
</li>
<li><p>所有联接都在一次通过中执行，并且大多数联接甚至都可以使用临时表来完成。大多数临时表是基于内存的哈希表。具有较大行长度（按所有列长度的总和计算）或包含<a href="https://dev.mysql.com/doc/refman/5.7/en/blob.html" target="_blank" rel="noopener"><code>BLOB</code></a>列的临时表 存储在磁盘上。</p>
</li>
<li><p>大多数执行排序的请求都根据结果集的大小分配一个排序缓冲区和两个临时文件零。请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/temporary-files.html" target="_blank" rel="noopener">第B.4.3.5节“ MySQL在哪里存储临时文件”</a>。</p>
</li>
<li><p>几乎所有的解析和计算都是在线程本地的和可重用的内存池中完成的。小项目不需要内存开销，从而避免了正常的慢速内存分配和释放。内存仅分配给意外大的字符串。</p>
</li>
<li><p>对于具有<a href="https://dev.mysql.com/doc/refman/5.7/en/blob.html" target="_blank" rel="noopener"><code>BLOB</code></a> 列的每个表，将动态扩大缓冲区以读取更大的<a href="https://dev.mysql.com/doc/refman/5.7/en/blob.html" target="_blank" rel="noopener"><code>BLOB</code></a>值。如果您扫描表，则缓冲区将增大到 <a href="https://dev.mysql.com/doc/refman/5.7/en/blob.html" target="_blank" rel="noopener"><code>BLOB</code></a>最大值。</p>
</li>
<li><p>MySQL需要用于表缓存的内存和描述符。所有使用中的表的处理程序结构都保存在表缓存中，并作为“ 先进先出 ”（FIFO）管理。所述 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_table_open_cache" target="_blank" rel="noopener"><code>table_open_cache</code></a>系统变量定义初始表高速缓存大小; 请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/table-cache.html" target="_blank" rel="noopener">第8.4.3.1节“ MySQL如何打开和关闭表”</a>。</p>
<p>MySQL还需要用于表定义缓存的内存。所述 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_table_definition_cache" target="_blank" rel="noopener"><code>table_definition_cache</code></a> 系统变量定义的表定义（距离的数量<code>.frm</code>可以存储在表中定义的高速缓存文件）。如果使用大量表，则可以创建大表定义缓存以加快表的打开速度。与表高速缓存不同，表定义高速缓存占用的空间更少，并且不使用文件描述符。</p>
</li>
<li><p>一条<a href="https://dev.mysql.com/doc/refman/5.7/en/flush.html#flush-tables" target="_blank" rel="noopener"><code>FLUSH TABLES</code></a>语句或 <a href="https://dev.mysql.com/doc/refman/5.7/en/mysqladmin.html" target="_blank" rel="noopener"><strong>mysqladmin flush-tables</strong></a>命令立即关闭所有未使用的表，并在当前执行的线程结束时将所有正在使用的表标记为关闭。这样可以有效释放大多数使用中的内存。<a href="https://dev.mysql.com/doc/refman/5.7/en/flush.html#flush-tables" target="_blank" rel="noopener"><code>FLUSH TABLES</code></a>在关闭所有表之前不会返回。</p>
</li>
<li><p>服务器在内存中缓存信息的结果 <a href="https://dev.mysql.com/doc/refman/5.7/en/grant.html" target="_blank" rel="noopener"><code>GRANT</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/create-user.html" target="_blank" rel="noopener"><code>CREATE USER</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/create-server.html" target="_blank" rel="noopener"><code>CREATE SERVER</code></a>，和 <a href="https://dev.mysql.com/doc/refman/5.7/en/install-plugin.html" target="_blank" rel="noopener"><code>INSTALL PLUGIN</code></a>语句。该内存不能由相应的释放 <a href="https://dev.mysql.com/doc/refman/5.7/en/revoke.html" target="_blank" rel="noopener"><code>REVOKE</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/drop-user.html" target="_blank" rel="noopener"><code>DROP USER</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/drop-server.html" target="_blank" rel="noopener"><code>DROP SERVER</code></a>，和 <a href="https://dev.mysql.com/doc/refman/5.7/en/uninstall-plugin.html" target="_blank" rel="noopener"><code>UNINSTALL PLUGIN</code></a> 语句，所以执行该语句的许多情况下，这导致高速缓存，会出现在缓存内存使用的增加，除非它与释放服务器 <a href="https://dev.mysql.com/doc/refman/5.7/en/flush.html#flush-privileges" target="_blank" rel="noopener"><code>FLUSH PRIVILEGES</code></a>。</p>
</li>
</ul>
<p><strong>ps</strong>和其他系统状态程序可能会报告<a href="https://dev.mysql.com/doc/refman/5.7/en/mysqld.html" target="_blank" rel="noopener"> <strong>mysqld</strong></a>使用了大量内存。这可能是由于不同内存地址上的线程堆栈引起的。例如，Solaris的 <strong>ps</strong>版本将 堆栈之间未使用的内存计为已用内存。要验证这一点，请通过检查可用的交换 <code>swap -s</code>。我们 使用多个内存泄漏检测器（商用和开放源代码）测试<a href="https://dev.mysql.com/doc/refman/5.7/en/mysqld.html" target="_blank" rel="noopener"> <strong>mysqld</strong></a>，因此应该没有内存泄漏。</p>
<h5 id="监视MySQL内存使用情况"><a href="#监视MySQL内存使用情况" class="headerlink" title="监视MySQL内存使用情况"></a>监视MySQL内存使用情况</h5><p>默认情况下，大多数性能架构内存检测是禁用的。可以通过更新<code>ENABLED</code>“性能模式” <a href="https://dev.mysql.com/doc/refman/5.7/en/setup-instruments-table.html" target="_blank" rel="noopener"><code>setup_instruments</code></a>表的列 来启用仪器 。内存仪器的名称形式为 ，其中为诸如或的值，并且 为仪器详细信息。 <code>memory/*code_area*/*instrument_name*</code><em>code_area<em><code>sql``innodb</code></em>instrument_name</em></p>
<ol>
<li><p>要查看可用的MySQL内存工具，请查询Performance Schema <a href="https://dev.mysql.com/doc/refman/5.7/en/setup-instruments-table.html" target="_blank" rel="noopener"><code>setup_instruments</code></a>表。以下查询返回所有代码区域的数百种内存工具。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM performance_schema.setup_instruments</span><br><span class="line">       WHERE NAME LIKE '%memory%';</span><br></pre></td></tr></table></figure>

<p>您可以通过指定代码区域来缩小结果范围。例如，您可以<code>InnoDB</code>通过指定<code>innodb</code>为代码区域来将结果限制为 内存仪器。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM performance_schema.setup_instruments</span><br><span class="line">       WHERE NAME LIKE '%memory/innodb%';</span><br><span class="line">+<span class="comment">-------------------------------------------+---------+-------+</span></span><br><span class="line">| NAME                                      | ENABLED | TIMED |</span><br><span class="line">+<span class="comment">-------------------------------------------+---------+-------+</span></span><br><span class="line">| memory/innodb/adaptive hash index         | NO      | NO    |</span><br><span class="line">| memory/innodb/buf_buf_pool                | NO      | NO    |</span><br><span class="line">| memory/innodb/dict_stats_bg_recalc_pool_t | NO      | NO    |</span><br><span class="line">| memory/innodb/dict_stats_index_map_t      | NO      | NO    |</span><br><span class="line">| memory/innodb/dict_stats_n_diff_on_level  | NO      | NO    |</span><br><span class="line">| memory/innodb/other                       | NO      | NO    |</span><br><span class="line">| memory/innodb/row_log_buf                 | NO      | NO    |</span><br><span class="line">| memory/innodb/row_merge_sort              | NO      | NO    |</span><br><span class="line">| memory/innodb/std                         | NO      | NO    |</span><br><span class="line">| memory/innodb/trx_sys_t::rw_trx_ids       | NO      | NO    |</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>根据您的MySQL安装代码区域可能包括<code>performance_schema</code>， <code>sql</code>，<code>client</code>， <code>innodb</code>，<code>myisam</code>， <code>csv</code>，<code>memory</code>， <code>blackhole</code>， <code>archive</code>， <code>partition</code>，和其他人。</p>
</li>
<li><p>要启用内存工具，请<code>performance-schema-instrument</code>在您的MySQL配置文件中添加一条 规则。例如，要启用所有内存工具，请将此规则添加到您的配置文件中，然后重新启动服务器：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">performance-schema-instrument</span>=<span class="string">'memory/%=COUNTED'</span></span><br></pre></td></tr></table></figure>

<p>注意</p>
<p>启动时启用内存工具可确保计算启动时发生的内存分配。</p>
<p>重新启动服务器后，<code>ENABLED</code>性能架构<a href="https://dev.mysql.com/doc/refman/5.7/en/setup-instruments-table.html" target="_blank" rel="noopener"><code>setup_instruments</code></a> 表的 列应报告<code>YES</code>已启用的内存工具。对于内存工具<code>TIMED</code>，<a href="https://dev.mysql.com/doc/refman/5.7/en/setup-instruments-table.html" target="_blank" rel="noopener"><code>setup_instruments</code></a>表中的 列将 被忽略，因为内存操作未计时。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM performance_schema.setup_instruments</span><br><span class="line">       WHERE NAME LIKE '%memory/innodb%';</span><br><span class="line">+<span class="comment">-------------------------------------------+---------+-------+</span></span><br><span class="line">| NAME                                      | ENABLED | TIMED |</span><br><span class="line">+<span class="comment">-------------------------------------------+---------+-------+</span></span><br><span class="line">| memory/innodb/adaptive hash index         | NO      | NO    |</span><br><span class="line">| memory/innodb/buf_buf_pool                | NO      | NO    |</span><br><span class="line">| memory/innodb/dict_stats_bg_recalc_pool_t | NO      | NO    |</span><br><span class="line">| memory/innodb/dict_stats_index_map_t      | NO      | NO    |</span><br><span class="line">| memory/innodb/dict_stats_n_diff_on_level  | NO      | NO    |</span><br><span class="line">| memory/innodb/other                       | NO      | NO    |</span><br><span class="line">| memory/innodb/row_log_buf                 | NO      | NO    |</span><br><span class="line">| memory/innodb/row_merge_sort              | NO      | NO    |</span><br><span class="line">| memory/innodb/std                         | NO      | NO    |</span><br><span class="line">| memory/innodb/trx_sys_t::rw_trx_ids       | NO      | NO    |</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询存储仪器数据。在此示例中，在Performance Schema <a href="https://dev.mysql.com/doc/refman/5.7/en/memory-summary-tables.html" target="_blank" rel="noopener"><code>memory_summary_global_by_event_name</code></a> 表中查询存储仪器数据，该 表通过汇总数据 <code>EVENT_NAME</code>。该 <code>EVENT_NAME</code>是仪器的名称。</p>
<p>以下查询返回<code>InnoDB</code>缓冲池的内存数据 。有关列的描述，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/memory-summary-tables.html" target="_blank" rel="noopener">第25.12.15.9节“内存摘要表”</a>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM performance_schema.memory_summary_global_by_event_name</span><br><span class="line">       WHERE EVENT_NAME LIKE 'memory/innodb/buf_buf_pool'\G</span><br><span class="line">                  EVENT_NAME: memory/innodb/buf_buf_pool</span><br><span class="line">                 COUNT_ALLOC: 1</span><br><span class="line">                  COUNT_FREE: 0</span><br><span class="line">   SUM_NUMBER_OF_BYTES_ALLOC: 137428992</span><br><span class="line">    SUM_NUMBER_OF_BYTES_FREE: 0</span><br><span class="line">              LOW_COUNT_USED: 0</span><br><span class="line">          CURRENT_COUNT_USED: 1</span><br><span class="line">             HIGH_COUNT_USED: 1</span><br><span class="line">    LOW_NUMBER_OF_BYTES_USED: 0</span><br><span class="line">CURRENT_NUMBER_OF_BYTES_USED: 137428992</span><br><span class="line">   HIGH_NUMBER_OF_BYTES_USED: 137428992</span><br></pre></td></tr></table></figure>

<p>可以使用<a href="https://dev.mysql.com/doc/refman/5.7/en/sys-schema.html" target="_blank" rel="noopener"><code>sys</code></a>架构 <a href="https://dev.mysql.com/doc/refman/5.7/en/sys-memory-global-by-current-bytes.html" target="_blank" rel="noopener"><code>memory_global_by_current_bytes</code></a> 表查询相同的基础数据 ，该表显示了服务器中全局的当前内存使用情况，并按分配类型进行了细分。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM sys.memory_global_by_current_bytes</span><br><span class="line">       WHERE event_name LIKE 'memory/innodb/buf_buf_pool'\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">       event_name: memory/innodb/buf_buf_pool</span><br><span class="line">    current_count: 1</span><br><span class="line">    current_alloc: 131.06 MiB</span><br><span class="line">current_avg_alloc: 131.06 MiB</span><br><span class="line">       high_count: 1</span><br><span class="line">       high_alloc: 131.06 MiB</span><br><span class="line">   high_avg_alloc: 131.06 MiB</span><br></pre></td></tr></table></figure>

<p>此<a href="https://dev.mysql.com/doc/refman/5.7/en/sys-schema.html" target="_blank" rel="noopener"><code>sys</code></a>架构查询<code>current_alloc</code>按代码区域汇总当前分配的内存（）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT SUBSTRING_INDEX(event_name,'/',2) AS</span><br><span class="line">       code_area, sys.format_bytes(SUM(current_alloc))</span><br><span class="line">       AS current_alloc</span><br><span class="line">       FROM sys.x$memory_global_by_current_bytes</span><br><span class="line">       GROUP BY SUBSTRING_INDEX(event_name,'/',2)</span><br><span class="line">       ORDER BY SUM(current_alloc) DESC;</span><br><span class="line">+<span class="comment">---------------------------+---------------+</span></span><br><span class="line">| code_area                 | current_alloc |</span><br><span class="line">+<span class="comment">---------------------------+---------------+</span></span><br><span class="line">| memory/innodb             | 843.24 MiB    |</span><br><span class="line">| memory/performance_schema | 81.29 MiB     |</span><br><span class="line">| memory/mysys              | 8.20 MiB      |</span><br><span class="line">| memory/sql                | 2.47 MiB      |</span><br><span class="line">| memory/memory             | 174.01 KiB    |</span><br><span class="line">| memory/myisam             | 46.53 KiB     |</span><br><span class="line">| memory/blackhole          | 512 bytes     |</span><br><span class="line">| memory/federated          | 512 bytes     |</span><br><span class="line">| memory/csv                | 512 bytes     |</span><br><span class="line">| memory/vio                | 496 bytes     |</span><br><span class="line">+<span class="comment">---------------------------+---------------+</span></span><br></pre></td></tr></table></figure>

<p>有关<a href="https://dev.mysql.com/doc/refman/5.7/en/sys-schema.html" target="_blank" rel="noopener"><code>sys</code></a>模式的更多信息 ，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/sys-schema.html" target="_blank" rel="noopener">第26章，<em>MySQL sys模式</em></a>。</p>
<h4 id="8-12-4-2启用大页面支持"><a href="#8-12-4-2启用大页面支持" class="headerlink" title="8.12.4.2启用大页面支持"></a>8.12.4.2启用大页面支持</h4></li>
</ol>
<p>   某些硬件/操作系统体系结构支持的内存页大于默认值（通常为4KB）。此支持的实际实现取决于底层硬件和操作系统。由于减少了转换后备缓冲区（TLB）丢失，因此执行大量内存访问的应用程序可以通过使用大页面来提高性能。</p>
<p>   在MySQL中，InnoDB可以使用大页为其缓冲池和其他内存池分配内存。</p>
<p>   MySQL中大页面的标准用法尝试使用支持的最大大小，最大4MB。在Solaris下， “ 超大页面 ”功能允许使用最大256MB的页面。此功能可用于最新的SPARC平台。可以使用<a href="https://dev.mysql.com/doc/refman/5.7/en/server-options.html#option_mysqld_super-large-pages" target="_blank" rel="noopener"><code>--super-large-pages</code></a>或 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-options.html#option_mysqld_super-large-pages" target="_blank" rel="noopener"><code>--skip-super-large-pages</code></a> 选项启用或禁用它 。</p>
<p>   MySQL还支持大页面支持的Linux实现（在Linux中称为HugeTLB）。</p>
<p>   在Linux上使用大页面之前，必须启用内核以支持大页面，并且有必要配置HugeTLB内存池。作为参考，HugeTBL API记录在 <code>Documentation/vm/hugetlbpage.txt</code>您的Linux源文件中。</p>
<p>   默认情况下，某些最新系统（例如Red Hat Enterprise Linux）的内核似乎启用了大页面功能。要检查您的内核是否正确，请使用以下命令并查找包含“ huge ”的输出行 ：</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; cat &#x2F;proc&#x2F;meminfo | grep -i huge</span><br><span class="line">HugePages_Total:       0</span><br><span class="line">HugePages_Free:        0</span><br><span class="line">HugePages_Rsvd:        0</span><br><span class="line">HugePages_Surp:        0</span><br><span class="line">Hugepagesize:       4096 kB</span><br></pre></td></tr></table></figure>

<p>   nonempty命令输出表明存在大页面支持，但零值表明未配置任何页面供使用。</p>
<p>   如果需要将内核重新配置为支持大页面，请查阅该<code>hugetlbpage.txt</code>文件以获取指示。</p>
<p>   假设您的Linux内核启用了大页面支持，请使用以下命令将其配置为供MySQL使用。通常，将它们放在<code>rc</code>系统引导序列中执行的 文件或等效的启动文件中，以便命令在每次系统启动时执行。这些命令应在MySQL服务器启动之前的引导顺序中早执行。确保根据您的系统更改分配号和组号。</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Set the number of pages to be used.</span><br><span class="line"># Each page is normally 2MB, so a value of 20 &#x3D; 40MB.</span><br><span class="line"># This command actually allocates memory, so this much</span><br><span class="line"># memory must be available.</span><br><span class="line">echo 20 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;nr_hugepages</span><br><span class="line"></span><br><span class="line"># Set the group number that is permitted to access this</span><br><span class="line"># memory (102 in this case). The mysql user must be a</span><br><span class="line"># member of this group.</span><br><span class="line">echo 102 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;hugetlb_shm_group</span><br><span class="line"></span><br><span class="line"># Increase the amount of shmem permitted per segment</span><br><span class="line"># (12G in this case).</span><br><span class="line">echo 1560281088 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;shmmax</span><br><span class="line"></span><br><span class="line"># Increase total amount of shared memory.  The value</span><br><span class="line"># is the number of pages. At 4KB&#x2F;page, 4194304 &#x3D; 16GB.</span><br><span class="line">echo 4194304 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;shmall</span><br></pre></td></tr></table></figure>

<p>   对于MySQL使用，您通常希望的值 <code>shmmax</code>接近的值 <code>shmall</code>。</p>
<p>   要验证大页面配置，请<code>/proc/meminfo</code>按照前面所述再次检查 。现在您应该看到一些非零值：</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; cat &#x2F;proc&#x2F;meminfo | grep -i huge</span><br><span class="line">HugePages_Total:      20</span><br><span class="line">HugePages_Free:       20</span><br><span class="line">HugePages_Rsvd:        0</span><br><span class="line">HugePages_Surp:        0</span><br><span class="line">Hugepagesize:       4096 kB</span><br></pre></td></tr></table></figure>

<p>   使用的最后一步 <code>hugetlb_shm_group</code>是为 <code>mysql</code>用户提供一个“ 无限 ” 的门锁限制值。可以通过编辑<code>/etc/security/limits.conf</code>或将以下命令添加到 <a href="https://dev.mysql.com/doc/refman/5.7/en/mysqld-safe.html" target="_blank" rel="noopener"><strong>mysqld_safe</strong></a>脚本中来完成：</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -l unlimited</span><br></pre></td></tr></table></figure>

<p>   在<a href="https://dev.mysql.com/doc/refman/5.7/en/mysqld-safe.html" target="_blank" rel="noopener"><strong>mysqld_safe中</strong></a>添加<strong>ulimit</strong>命令 会导致 用户在切换到用户之前 将memlock限制设置为 。（这假定 <a href="https://dev.mysql.com/doc/refman/5.7/en/mysqld-safe.html" target="_blank" rel="noopener"><strong>mysqld_safe</strong></a>由启动 。） <code>root``unlimited``mysql``root</code></p>
<p>   默认情况下，MySQL中的大页面支持处于禁用状态。要启用它，请使用<a href="https://dev.mysql.com/doc/refman/5.7/en/server-options.html#option_mysqld_large-pages" target="_blank" rel="noopener"><code>--large-pages</code></a>选项启动服务器 。例如，您可以在服务器<code>my.cnf</code>文件中使用以下几行 ：</p>
   <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line">large-pages</span><br></pre></td></tr></table></figure>

<p>   使用此选项，<code>InnoDB</code>自动将大页用于其缓冲池和其他内存池。如果<code>InnoDB</code>不能执行此操作，则退回到传统内存的使用，并向错误日志写入警告：警告：使用常规内存池</p>
<p>   要验证是否使用了大页面，请<code>/proc/meminfo</code>再次检查 ：</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; cat &#x2F;proc&#x2F;meminfo | grep -i huge</span><br><span class="line">HugePages_Total:      20</span><br><span class="line">HugePages_Free:       20</span><br><span class="line">HugePages_Rsvd:        2</span><br><span class="line">HugePages_Surp:        0</span><br><span class="line">Hugepagesize:       4096 kB</span><br></pre></td></tr></table></figure>



<h2 id="8-13评估效果（基准测试）"><a href="#8-13评估效果（基准测试）" class="headerlink" title="8.13评估效果（基准测试）"></a>8.13评估效果（基准测试）</h2><ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/select-benchmarking.html" target="_blank" rel="noopener">8.13.1测量表达式和函数的速度</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/custom-benchmarks.html" target="_blank" rel="noopener">8.13.2使用自己的基准</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/monitoring-performance-schema.html" target="_blank" rel="noopener">8.13.3使用performance_schema衡量绩效</a></li>
</ul>
<p>要衡量性能，请考虑以下因素：</p>
<ul>
<li>无论您是在安静的系统上测量单个操作的速度，还是一段时间内一组操作（ “ 工作负载 ”）如何工作。通过简单的测试，您通常可以测试更改一个方面（配置设置，表上的索引集，查询中的SQL子句）如何影响性能。基准测试通常是长期运行且精心设计的性能测试，其结果可能会决定高级选择，例如硬件和存储配置，或升级到新MySQL版本的时间。</li>
<li>为了进行基准测试，有时您必须模拟繁重的数据库工作量才能获得准确的图像。</li>
<li>表现可能取决于许多不同的因素，以至于几个百分点的差异可能不是决定性的胜利。在不同的环境中进行测试时，结果可能会以相反的方式发生变化。</li>
<li>某些MySQL功能会根据工作负载来帮助或不帮助性能。为了完整起见，请始终在打开和关闭这些功能的情况下测试性能。尝试与每个工作负载的两个最重要的功能是 <a href="https://dev.mysql.com/doc/refman/5.7/en/query-cache.html" target="_blank" rel="noopener">MySQL查询缓存</a>，以及 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-adaptive-hash.html" target="_blank" rel="noopener">适应性的散列索引</a>的<code>InnoDB</code>表。</li>
</ul>
<p>本节从单个开发人员可以执行的简单直接的测量技术发展到需要更多专业知识来执行和解释结果的更复杂的技术。</p>
<h3 id="8-13-1测量表达式和函数的速度"><a href="#8-13-1测量表达式和函数的速度" class="headerlink" title="8.13.1测量表达式和函数的速度"></a>8.13.1测量表达式和函数的速度</h3><p>要测量特定MySQL表达式或函数的速度，请<a href="https://dev.mysql.com/doc/refman/5.7/en/information-functions.html#function_benchmark" target="_blank" rel="noopener"><code>BENCHMARK()</code></a>使用<a href="https://dev.mysql.com/doc/refman/5.7/en/mysql.html" target="_blank" rel="noopener"><strong>mysql</strong></a>客户端程序调用该函数。其语法为 。返回值始终为零，但是<a href="https://dev.mysql.com/doc/refman/5.7/en/mysql.html" target="_blank" rel="noopener"><strong>mysql</strong></a> 打印一行，显示大约执行该语句所花的时间。例如： <a href="https://dev.mysql.com/doc/refman/5.7/en/information-functions.html#function_benchmark" target="_blank" rel="noopener"><code>BENCHMARK(*loop_count*,*expr*)</code></a></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT BENCHMARK(1000000,1+1);</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">| BENCHMARK(1000000,1+1) |</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">|                      0 |</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.32</span> sec)</span><br></pre></td></tr></table></figure>

<p>该结果是在奔腾II 400MHz系统上获得的。它表明MySQL可以在该系统上在0.32秒内执行1,000,000个简单加法表达式。</p>
<p>内置的MySQL函数通常经过高度优化，但是可能会有一些例外。 <a href="https://dev.mysql.com/doc/refman/5.7/en/information-functions.html#function_benchmark" target="_blank" rel="noopener"><code>BENCHMARK()</code></a>是一个很好的工具，用于确定某些功能是否对您的查询有问题。</p>
<h3 id="8-13-2使用自己的基准"><a href="#8-13-2使用自己的基准" class="headerlink" title="8.13.2使用自己的基准"></a>8.13.2使用自己的基准</h3><p>免费的基准测试套件是开放源代码数据库基准测试，可从<a href="http://osdb.sourceforge.net/" target="_blank" rel="noopener">http://osdb.sourceforge.net/获得</a>。</p>
<p>仅当系统负载很重时才发生问题是很常见的。我们有许多客户在生产中（经过测试）系统并遇到负载问题时与我们联系。在大多数情况下，性能问题可能是由于基本数据库设计问题（例如，表扫描在高负载下效果不佳）或操作系统或库问题引起的。在大多数情况下，如果系统尚未投入生产，这些问题将更容易解决。</p>
<p>为避免此类问题，请在可能的最坏负载下对整个应用程序进行基准测试：</p>
<ul>
<li>该<a href="https://dev.mysql.com/doc/refman/5.7/en/mysqlslap.html" target="_blank" rel="noopener"><strong>mysqlslap</strong></a>程序可以是用于模拟由多个客户端同时发出查询产生的高负载有帮助的。请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/mysqlslap.html" target="_blank" rel="noopener">第4.5.8节“ <strong>mysqlslap-</strong>负载仿真客户端”</a>。</li>
<li>您还可以尝试通过<a href="https://launchpad.net/sysbench和" target="_blank" rel="noopener">https://launchpad.net/sysbench和</a> <a href="http://osdldbt.sourceforge.net/#dbt2获得的SysBench和DBT2等基准测试包" target="_blank" rel="noopener">http://osdldbt.sourceforge.net/#dbt2获得的SysBench和DBT2等基准测试包</a> 。</li>
</ul>
<p>这些程序或软件包可以使系统崩溃，因此请确保仅在开发系统上使用它们。</p>
<h3 id="8-13-3使用performance-schema衡量绩效"><a href="#8-13-3使用performance-schema衡量绩效" class="headerlink" title="8.13.3使用performance_schema衡量绩效"></a>8.13.3使用performance_schema衡量绩效</h3><p>您可以查询<code>performance_schema</code>数据库中的表 以查看有关服务器及其正在运行的应用程序的性能特征的实时信息。有关详细信息<a href="https://dev.mysql.com/doc/refman/5.7/en/performance-schema.html" target="_blank" rel="noopener">，</a>请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/performance-schema.html" target="_blank" rel="noopener">第25章，</a><a href="https://dev.mysql.com/doc/refman/5.7/en/performance-schema.html" target="_blank" rel="noopener"><em>MySQL性能模式</em></a>。</p>
<h2 id="8-14检查线程信息"><a href="#8-14检查线程信息" class="headerlink" title="8.14检查线程信息"></a>8.14检查线程信息</h2><ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/thread-commands.html" target="_blank" rel="noopener">8.14.1线程命令值</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/general-thread-states.html" target="_blank" rel="noopener">8.14.2通用线程状态</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/query-cache-thread-states.html" target="_blank" rel="noopener">8.14.3查询缓存线程状态</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/master-thread-states.html" target="_blank" rel="noopener">8.14.4复制主线程状态</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/slave-io-thread-states.html" target="_blank" rel="noopener">8.14.5复制从属I / O线程状态</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/slave-sql-thread-states.html" target="_blank" rel="noopener">8.14.6复制从SQL线程状态</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/slave-connection-thread-states.html" target="_blank" rel="noopener">8.14.7复制从设备连接线程状态</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-cluster-thread-states.html" target="_blank" rel="noopener">8.14.8 NDB群集线程状态</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/event-scheduler-thread-states.html" target="_blank" rel="noopener">8.14.9事件调度程序线程状态</a></li>
</ul>
<p>当您尝试确定MySQL服务器正在做什么时，检查进程列表（这是服务器中当前正在执行的线程集）可能会有所帮助。可以从以下来源获得过程列表信息：</p>
<ul>
<li>该<code>SHOW [FULL] PROCESSLIST</code>语句： <a href="https://dev.mysql.com/doc/refman/5.7/en/show-processlist.html" target="_blank" rel="noopener">第13.7.5.29节“ SHOW PROCESSLIST语句”</a></li>
<li>该<a href="https://dev.mysql.com/doc/refman/5.7/en/show-profile.html" target="_blank" rel="noopener"><code>SHOW PROFILE</code></a>语句： <a href="https://dev.mysql.com/doc/refman/5.7/en/show-profiles.html" target="_blank" rel="noopener">第13.7.5.31节“ SHOW PROFILES语句”</a></li>
<li>该<code>INFORMATION_SCHEMA</code> <a href="https://dev.mysql.com/doc/refman/5.7/en/processlist-table.html" target="_blank" rel="noopener"><code>PROCESSLIST</code></a>表： <a href="https://dev.mysql.com/doc/refman/5.7/en/processlist-table.html" target="_blank" rel="noopener">第24.18，“该INFORMATION_SCHEMA PROCESSLIST表”</a></li>
<li>在<a href="https://dev.mysql.com/doc/refman/5.7/en/mysqladmin.html" target="_blank" rel="noopener"><strong>中mysqladmin processlist的</strong></a>命令： <a href="https://dev.mysql.com/doc/refman/5.7/en/mysqladmin.html" target="_blank" rel="noopener">第4.5.2节“ <strong>中mysqladmin</strong> -客户端管理MySQL服务器”</a></li>
<li>性能架构<a href="https://dev.mysql.com/doc/refman/5.7/en/threads-table.html" target="_blank" rel="noopener"><code>threads</code></a> 表，阶段表和锁定表： <a href="https://dev.mysql.com/doc/refman/5.7/en/performance-schema-miscellaneous-tables.html" target="_blank" rel="noopener">第25.12.16节“性能架构杂项表”</a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/performance-schema-stage-tables.html" target="_blank" rel="noopener">第25.12.5节“性能架构阶段事件表”</a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/performance-schema-lock-tables.html" target="_blank" rel="noopener">第25.12.12节“性能架构锁定表”</a>。</li>
<li>该<code>sys</code>架构 <a href="https://dev.mysql.com/doc/refman/5.7/en/sys-processlist.html" target="_blank" rel="noopener"><code>processlist</code></a>视图，呈现从性能模式的信息 <a href="https://dev.mysql.com/doc/refman/5.7/en/threads-table.html" target="_blank" rel="noopener"><code>threads</code></a>在更方便的格式表：<a href="https://dev.mysql.com/doc/refman/5.7/en/sys-processlist.html" target="_blank" rel="noopener">第26.4.3.22，“ProcessList中和X $ PROCESSLIST意见”</a></li>
<li>该<code>sys</code>模式 <a href="https://dev.mysql.com/doc/refman/5.7/en/sys-session.html" target="_blank" rel="noopener"><code>session</code></a>认为，有关用户会话呈现信息（如 <code>sys</code>架构 <a href="https://dev.mysql.com/doc/refman/5.7/en/sys-processlist.html" target="_blank" rel="noopener"><code>processlist</code></a>视图，但后台进程滤除）： <a href="https://dev.mysql.com/doc/refman/5.7/en/sys-session.html" target="_blank" rel="noopener">第26.4.3.33，“会议和X $会话视图”</a></li>
</ul>
<p>访问<a href="https://dev.mysql.com/doc/refman/5.7/en/threads-table.html" target="_blank" rel="noopener"><code>threads</code></a>不需要互斥，并且对服务器性能的影响最小。 <a href="https://dev.mysql.com/doc/refman/5.7/en/processlist-table.html" target="_blank" rel="noopener"><code>INFORMATION_SCHEMA.PROCESSLIST</code></a>并且<a href="https://dev.mysql.com/doc/refman/5.7/en/show-processlist.html" target="_blank" rel="noopener"><code>SHOW PROCESSLIST</code></a>由于它们需要互斥量而 对性能造成负面影响。 <a href="https://dev.mysql.com/doc/refman/5.7/en/threads-table.html" target="_blank" rel="noopener"><code>threads</code></a>还显示有关后台线程，哪些信息 <a href="https://dev.mysql.com/doc/refman/5.7/en/processlist-table.html" target="_blank" rel="noopener"><code>INFORMATION_SCHEMA.PROCESSLIST</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/show-processlist.html" target="_blank" rel="noopener"><code>SHOW PROCESSLIST</code></a>没有。这意味着<a href="https://dev.mysql.com/doc/refman/5.7/en/threads-table.html" target="_blank" rel="noopener"><code>threads</code></a>可以用来监视其他线程信息源无法监视的活动。</p>
<p>您始终可以查看有关自己线程的信息。要查看有关其他帐户正在执行的线程的信息，您必须具有<a href="https://dev.mysql.com/doc/refman/5.7/en/privileges-provided.html#priv_process" target="_blank" rel="noopener"><code>PROCESS</code></a>特权。</p>
<p>每个进程列表条目包含几条信息：</p>
<ul>
<li><p><code>Id</code> 是与线程关联的客户端的连接标识符。</p>
</li>
<li><p><code>User</code>并<code>Host</code>指出与该线程关联的帐户。</p>
</li>
<li><p><code>db</code>是该线程的默认数据库，或者<code>NULL</code>如果未选择任何数据库。</p>
</li>
<li><p><code>Command</code>并<code>State</code> 指出线程在做什么。</p>
<p>大多数状态对应于非常快速的操作。如果线程在给定状态下停留数秒钟，则可能存在需要调查的问题。</p>
</li>
<li><p><code>Time</code>指示线程处于其当前状态的时间。在某些情况下，线程的当前时间概念可能会更改：线程可以使用更改时间。对于在从属服务器上运行的，正在处理来自主服务器的事件的线程，线程时间设置为事件中找到的时间，从而反映了主服务器而非从属服务器上的当前时间。 <a href="https://dev.mysql.com/doc/refman/5.7/en/set-variable.html" target="_blank" rel="noopener"><code>SET TIMESTAMP = *value*</code></a></p>
</li>
<li><p><code>Info</code>包含线程正在执行的语句的文本，或者<code>NULL</code>不执行的文本。默认情况下，此值仅包含语句的前100个字符。要查看完整的语句，请使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/show-processlist.html" target="_blank" rel="noopener"><code>SHOW FULL PROCESSLIST</code></a>。</p>
</li>
</ul>
<p>以下各节列出了可能的 <code>Command</code>值以及<code>State</code> 按类别分组的值。其中一些值的含义不言而喻。对于其他人，提供了附加描述。</p>
<h3 id="8-14-1线程命令值"><a href="#8-14-1线程命令值" class="headerlink" title="8.14.1线程命令值"></a>8.14.1线程命令值</h3><p>线程可以具有以下任何 <code>Command</code>值：</p>
<ul>
<li><p><code>Binlog Dump</code></p>
<p>这是主服务器上的线程，用于将二进制日志内容发送到从服务器。</p>
</li>
<li><p><code>Change user</code></p>
<p>线程正在执行更改用户操作。</p>
</li>
<li><p><code>Close stmt</code></p>
<p>线程正在关闭准备好的语句。</p>
</li>
<li><p><code>Connect</code></p>
<p>复制从属服务器已连接到其主服务器。</p>
</li>
<li><p><code>Connect Out</code></p>
<p>复制从属服务器正在连接到其主服务器。</p>
</li>
<li><p><code>Create DB</code></p>
<p>线程正在执行创建数据库操作。</p>
</li>
<li><p><code>Daemon</code></p>
<p>该线程在服务器内部，而不是为客户端连接提供服务的线程。</p>
</li>
<li><p><code>Debug</code></p>
<p>该线程正在生成调试信息。</p>
</li>
<li><p><code>Delayed insert</code></p>
<p>该线程是延迟插入处理程序。</p>
</li>
<li><p><code>Drop DB</code></p>
<p>线程正在执行放置数据库操作。</p>
</li>
<li><p><code>Error</code></p>
</li>
<li><p><code>Execute</code></p>
<p>线程正在执行准备好的语句。</p>
</li>
<li><p><code>Fetch</code></p>
<p>线程正在从执行准备好的语句中获取结果。</p>
</li>
<li><p><code>Field List</code></p>
<p>该线程正在检索表列的信息。</p>
</li>
<li><p><code>Init DB</code></p>
<p>线程正在选择默认数据库。</p>
</li>
<li><p><code>Kill</code></p>
<p>该线程正在杀死另一个线程。</p>
</li>
<li><p><code>Long Data</code></p>
<p>执行准备好的语句的结果是线程正在检索长数据。</p>
</li>
<li><p><code>Ping</code></p>
<p>线程正在处理服务器ping请求。</p>
</li>
<li><p><code>Prepare</code></p>
<p>该线程正在准备一个准备好的语句。</p>
</li>
<li><p><code>Processlist</code></p>
<p>该线程正在生成有关服务器线程的信息。</p>
</li>
<li><p><code>Query</code></p>
<p>线程正在执行一条语句。</p>
</li>
<li><p><code>Quit</code></p>
<p>线程正在终止。</p>
</li>
<li><p><code>Refresh</code></p>
<p>该线程是刷新表，日志或缓存，或者重置状态变量或复制服务器信息。</p>
</li>
<li><p><code>Register Slave</code></p>
<p>线程正在注册从属服务器。</p>
</li>
<li><p><code>Reset stmt</code></p>
<p>线程正在重置准备好的语句。</p>
</li>
<li><p><code>Set option</code></p>
<p>该线程正在设置或重置客户端语句执行选项。</p>
</li>
<li><p><code>Shutdown</code></p>
<p>线程正在关闭服务器。</p>
</li>
<li><p><code>Sleep</code></p>
<p>线程正在等待客户端向其发送新语句。</p>
</li>
<li><p><code>Statistics</code></p>
<p>该线程正在生成服务器状态信息。</p>
</li>
<li><p><code>Table Dump</code></p>
<p>线程正在将表内容发送到从属服务器。</p>
</li>
<li><p><code>Time</code></p>
<p>没用过。</p>
</li>
<li><h3 id="8-14-2通用线程状态"><a href="#8-14-2通用线程状态" class="headerlink" title="8.14.2通用线程状态"></a>8.14.2通用线程状态</h3></li>
</ul>
<p>  下表描述了<code>State</code> 与常规查询处理而非更专门的活动（如复制）关联的线程值。其中许多仅用于发现服务器中的错误。</p>
<ul>
<li><p><code>After create</code></p>
<p>当线程在创建表的函数的末尾创建一个表（包括内部临时表）时，就会发生这种情况。即使由于某些错误而无法创建表，也会使用此状态。</p>
</li>
<li><p><code>Analyzing</code></p>
<p>该线程正在计算<code>MyISAM</code>表键分布（例如for <a href="https://dev.mysql.com/doc/refman/5.7/en/analyze-table.html" target="_blank" rel="noopener"><code>ANALYZE TABLE</code></a>）。</p>
</li>
<li><p><code>checking permissions</code></p>
<p>线程正在检查服务器是否具有执行该语句所需的特权。</p>
</li>
<li><p><code>Checking table</code></p>
<p>线程正在执行表检查操作。</p>
</li>
<li><p><code>cleaning up</code></p>
<p>该线程已处理一个命令，并准备释放内存并重置某些状态变量。</p>
</li>
<li><p><code>closing tables</code></p>
<p>线程正在将更改后的表数据刷新到磁盘并关闭已使用的表。这应该是一个快速的操作。如果没有，请确认您没有完整的磁盘，并且磁盘使用率不是很高。</p>
</li>
<li><p><code>converting HEAP to ondisk</code></p>
<p>线程正在将内部临时表从 <code>MEMORY</code>表转换为磁盘表。</p>
</li>
<li><p><code>copy to tmp table</code></p>
<p>线程正在处理一条<a href="https://dev.mysql.com/doc/refman/5.7/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>语句。在创建具有新结构的表之后但在将行复制到其中之前，将发生此状态。</p>
<p>对于处于这种状态的线程，可以使用性能架构来获取有关复制操作进度的信息。请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/performance-schema-stage-tables.html" target="_blank" rel="noopener">第25.12.5节“性能架构阶段事件表”</a>。</p>
</li>
<li><p><code>Copying to group table</code></p>
<p>如果语句具有不同的条件<code>ORDER BY</code>和 <code>GROUP BY</code>条件，则行将按组排序并复制到临时表中。</p>
</li>
<li><p><code>Copying to tmp table</code></p>
<p>服务器正在复制到内存中的临时表。</p>
</li>
<li><p><code>altering table</code></p>
<p>服务器正在执行就地服务 <a href="https://dev.mysql.com/doc/refman/5.7/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>。</p>
</li>
<li><p><code>Copying to tmp table on disk</code></p>
<p>服务器正在复制到磁盘上的临时表。临时结果集太大（请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/internal-temporary-tables.html" target="_blank" rel="noopener">第8.4.4节“ MySQL中的内部临时表使用”</a>）。因此，线程正在将临时表从内存中更改为基于磁盘的格式，以节省内存。</p>
</li>
<li><p><code>Creating index</code></p>
<p>线程正在处理<code>ALTER TABLE ... ENABLE KEYS</code>一个<code>MyISAM</code>表。</p>
</li>
<li><p><code>Creating sort index</code></p>
<p>线程正在处理 <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>使用内部临时表解析的。</p>
</li>
<li><p><code>creating table</code></p>
<p>该线程正在创建一个表。这包括创建临时表。</p>
</li>
<li><p><code>Creating tmp table</code></p>
<p>该线程正在内存或磁盘上创建一个临时表。如果该表是在内存中创建的，但后来又转换为磁盘表，则该操作期间的状态将为<code>Copying to tmp table on disk</code>。</p>
</li>
<li><p><code>committing alter table to storage engine</code></p>
<p>服务器已就地完成 <a href="https://dev.mysql.com/doc/refman/5.7/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>并提交结果。</p>
</li>
<li><p><code>deleting from main table</code></p>
<p>服务器正在执行多表删除的第一部分。它仅从第一个表中删除，并保存要从其他（参考）表中删除的列和偏移量。</p>
</li>
<li><p><code>deleting from reference tables</code></p>
<p>服务器正在执行多表删除的第二部分，并从其他表中删除匹配的行。</p>
</li>
<li><p><code>discard_or_import_tablespace</code></p>
<p>线程正在处理<code>ALTER TABLE ... DISCARD TABLESPACE</code>or <code>ALTER TABLE ... IMPORT TABLESPACE</code>语句。</p>
</li>
<li><p><code>end</code></p>
<p>这发生在结束，但的清理之前 <a href="https://dev.mysql.com/doc/refman/5.7/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/create-view.html" target="_blank" rel="noopener"><code>CREATE VIEW</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/delete.html" target="_blank" rel="noopener"><code>DELETE</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>，或 <a href="https://dev.mysql.com/doc/refman/5.7/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a>语句。</p>
</li>
<li><p><code>executing</code></p>
<p>该线程已开始执行一条语句。</p>
</li>
<li><p><code>Execution of init_command</code></p>
<p>线程正在使用<code>init_command</code>系统变量的值执行语句 。</p>
</li>
<li><p><code>freeing items</code></p>
<p>线程已执行命令。在此状态下完成的一些项目释放涉及查询缓存。此状态通常后跟<code>cleaning up</code>。</p>
</li>
<li><p><code>FULLTEXT initialization</code></p>
<p>服务器正在准备执行自然语言的全文本搜索。</p>
</li>
<li><p><code>init</code></p>
<p>出现这种情况的初始化之前 <a href="https://dev.mysql.com/doc/refman/5.7/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/delete.html" target="_blank" rel="noopener"><code>DELETE</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>， <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>，或 <a href="https://dev.mysql.com/doc/refman/5.7/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a>语句。服务器在此状态下采取的操作包括刷新二进制日志，<code>InnoDB</code>日志和一些查询缓存清除操作。</p>
<p>对于<code>end</code>状态，可能发生以下操作：</p>
<ul>
<li>更改表中的数据后删除查询缓存条目</li>
<li>将事件写入二进制日志</li>
<li>释放内存缓冲区，包括用于blob的缓冲区</li>
</ul>
</li>
<li><p><code>Killed</code></p>
<p>有人<a href="https://dev.mysql.com/doc/refman/5.7/en/kill.html" target="_blank" rel="noopener"><code>KILL</code></a> 向该线程发送了一条语句，下次检查kill标志时，它将中止。在MySQL的每个主要循环中都会检查该标志，但是在某些情况下，线程死亡仍然可能需要很短的时间。如果该线程被某个其他线程锁定，则杀死操作将在另一个线程释放其锁定后立即生效。</p>
</li>
<li><p><code>logging slow query</code></p>
<p>线程正在将一条语句写入慢速查询日志。</p>
</li>
<li><p><code>login</code></p>
<p>连接线程的初始状态，直到客户端已成功通过身份验证。</p>
</li>
<li><p><code>manage keys</code></p>
<p>服务器正在启用或禁用表索引。</p>
</li>
<li><p><code>NULL</code></p>
<p>该状态用于<a href="https://dev.mysql.com/doc/refman/5.7/en/show-processlist.html" target="_blank" rel="noopener"><code>SHOW PROCESSLIST</code></a>状态。</p>
</li>
<li><p><code>Opening tables</code></p>
<p>线程正在尝试打开表。除非有阻止打开的步骤，否则这应该是非常快速的过程。例如，一个<a href="https://dev.mysql.com/doc/refman/5.7/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>或一条 <a href="https://dev.mysql.com/doc/refman/5.7/en/lock-tables.html" target="_blank" rel="noopener"><code>LOCK TABLE</code></a>语句可以阻止在该语句完成之前打开表。还值得检查您的<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_table_open_cache" target="_blank" rel="noopener"><code>table_open_cache</code></a>价值是否足够大。</p>
</li>
<li><p><code>optimizing</code></p>
<p>服务器正在对查询执行初始优化。</p>
</li>
<li><p><code>preparing</code></p>
<p>此状态在查询优化期间发生。</p>
</li>
<li><p><code>Purging old relay logs</code></p>
<p>该线程正在删除不需要的中继日志文件。</p>
</li>
<li><p><code>query end</code></p>
<p>此状态在处理查询之后但在该<code>freeing items</code>状态之前发生 。</p>
</li>
<li><p><code>Receiving from client</code></p>
<p>服务器正在从客户端读取数据包。<code>Reading from net</code>在MySQL 5.7.8之前，此状态称为。</p>
</li>
<li><p><code>Removing duplicates</code></p>
<p>查询的使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT DISTINCT</code></a>方式使得MySQL无法在早期阶段优化独特的操作。因此，MySQL需要一个额外的阶段来删除所有重复的行，然后再将结果发送给客户端。</p>
</li>
<li><p><code>removing tmp table</code></p>
<p>线程在处理<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a> 语句后正在删除内部临时表。如果未创建临时表，则不使用此状态。</p>
</li>
<li><p><code>rename</code></p>
<p>线程正在重命名表。</p>
</li>
<li><p><code>rename result table</code></p>
<p>该线程正在处理一条<a href="https://dev.mysql.com/doc/refman/5.7/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>语句，创建了新表，并对其进行了重命名以替换原始表。</p>
</li>
<li><p><code>Reopen tables</code></p>
<p>线程获得了该表的锁，但是在获得该锁后，该线程注意到基础表结构已更改。它释放了锁，关闭了表，并试图重新打开它。</p>
</li>
<li><p><code>Repair by sorting</code></p>
<p>修复代码正在使用某种排序来创建索引。</p>
</li>
<li><p><code>preparing for alter table</code></p>
<p>服务器正在准备执行就地 <a href="https://dev.mysql.com/doc/refman/5.7/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>。</p>
</li>
<li><p><code>Repair done</code></p>
<p>该线程已完成对<code>MyISAM</code>表的多线程修复 。</p>
</li>
<li><p><code>Repair with keycache</code></p>
<p>修复代码使用的是通过密钥缓存一对一地创建密钥。这比慢得多<code>Repair by sorting</code>。</p>
</li>
<li><p><code>Rolling back</code></p>
<p>线程正在回滚事务。</p>
</li>
<li><p><code>Saving state</code></p>
<p>对于<code>MyISAM</code>表操作（例如修复或分析），线程会将新表状态保存到<code>.MYI</code>文件头。状态包括诸如行数， <code>AUTO_INCREMENT</code>计数器和密钥分布之类的信息。</p>
</li>
<li><p><code>Searching rows for update</code></p>
<p>线程正在执行第一阶段以在更新所有匹配的行之前找到它们。如果 <a href="https://dev.mysql.com/doc/refman/5.7/en/update.html" target="_blank" rel="noopener"><code>UPDATE</code></a>更改了用于查找所涉及行的索引，则必须执行此操作。</p>
</li>
<li><p><code>Sending data</code></p>
<p>线程正在读取和处理<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>语句的行 ，并将数据发送到客户端。因为在此状态下发生的操作往往会执行大量磁盘访问（读取），所以它通常是给定查询生命周期中运行时间最长的状态。</p>
</li>
<li><p><code>Sending to client</code></p>
<p>服务器正在将数据包写入客户端。<code>Writing to net</code>在MySQL 5.7.8之前，此状态称为。</p>
</li>
<li><p><code>setup</code></p>
<p>线程正在开始<a href="https://dev.mysql.com/doc/refman/5.7/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a>操作。</p>
</li>
<li><p><code>Sorting for group</code></p>
<p>线程正在做某种排序以满足<code>GROUP BY</code>。</p>
</li>
<li><p><code>Sorting for order</code></p>
<p>线程正在执行某种排序以满足<code>ORDER BY</code>。</p>
</li>
<li><p><code>Sorting index</code></p>
<p>该线程正在对索引页进行排序，以在<code>MyISAM</code>表优化操作期间更有效地进行访问。</p>
</li>
<li><p><code>Sorting result</code></p>
<p>对于<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>语句，这类似于<code>Creating sort index</code>，但是对于非临时表。</p>
</li>
<li><p><code>statistics</code></p>
<p>服务器正在计算统计信息以制定查询执行计划。如果线程长时间处于此状态，则服务器可能是磁盘绑定的，正在执行其他工作。</p>
</li>
<li><p><code>System lock</code></p>
<p>从此线程已被调用<code>mysql_lock_tables()</code> ，并且线程状态尚未更新。这是一种非常普遍的状态，可能由于多种原因而发生。</p>
<p>例如，线程将要请求或正在等待表的内部或外部系统锁定。<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html" target="_blank" rel="noopener"><code>InnoDB</code></a>在执行期间等待表级锁定时， 可能会发生这种情况<a href="https://dev.mysql.com/doc/refman/5.7/en/lock-tables.html" target="_blank" rel="noopener"><code>LOCK TABLES</code></a>。如果此状态是由对外部锁的请求引起的，并且您没有使用正在访问同一 表的多个<a href="https://dev.mysql.com/doc/refman/5.7/en/mysqld.html" target="_blank" rel="noopener"><strong>mysqld</strong></a>服务器，则<a href="https://dev.mysql.com/doc/refman/5.7/en/myisam-storage-engine.html" target="_blank" rel="noopener"><code>MyISAM</code></a>可以使用该<a href="https://dev.mysql.com/doc/refman/5.7/en/server-options.html#option_mysqld_external-locking" target="_blank" rel="noopener"><code>--skip-external-locking</code></a> 选项禁用外部系统锁 。但是，默认情况下将禁用外部锁定，因此此选项可能无效。对于 <a href="https://dev.mysql.com/doc/refman/5.7/en/show-profile.html" target="_blank" rel="noopener"><code>SHOW PROFILE</code></a>，此状态表示线程正在请求锁定（不等待它）。</p>
</li>
<li><p><code>update</code></p>
<p>线程已准备好开始更新表。</p>
</li>
<li><p><code>Updating</code></p>
<p>线程正在搜索要更新的行，并且正在更新它们。</p>
</li>
<li><p><code>updating main table</code></p>
<p>服务器正在执行多表更新的第一部分。它仅更新第一个表，并保存列和偏移量以用于更新其他（参考）表。</p>
</li>
<li><p><code>updating reference tables</code></p>
<p>服务器正在执行多表更新的第二部分，并从其他表更新匹配的行。</p>
</li>
<li><p><code>User lock</code></p>
<p>该线程将要请求或正在等待通过<a href="https://dev.mysql.com/doc/refman/5.7/en/locking-functions.html#function_get-lock" target="_blank" rel="noopener"><code>GET_LOCK()</code></a>调用请求的咨询锁 。对于 <a href="https://dev.mysql.com/doc/refman/5.7/en/show-profile.html" target="_blank" rel="noopener"><code>SHOW PROFILE</code></a>，此状态表示线程正在请求锁定（不等待它）。</p>
</li>
<li><p><code>User sleep</code></p>
<p>线程已调用 <a href="https://dev.mysql.com/doc/refman/5.7/en/miscellaneous-functions.html#function_sleep" target="_blank" rel="noopener"><code>SLEEP()</code></a>。</p>
</li>
<li><p><code>Waiting for commit lock</code></p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/flush.html#flush-tables-with-read-lock" target="_blank" rel="noopener"><code>FLUSH TABLES WITH READ LOCK</code></a> 正在等待提交锁。</p>
</li>
<li><p><code>Waiting for global read lock</code></p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/flush.html#flush-tables-with-read-lock" target="_blank" rel="noopener"><code>FLUSH TABLES WITH READ LOCK</code></a> 正在等待全局读取锁定或<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_read_only" target="_blank" rel="noopener"><code>read_only</code></a>正在设置全局 系统变量。</p>
</li>
<li><p><code>Waiting for tables</code></p>
<p>该线程收到有关表的基础结构已更改的通知，它需要重新打开表以获取新的结构。但是，要重新打开该表，它必须等待，直到所有其他线程关闭了该表。</p>
<p>这张告示，如果另一个线程使用的地方 <a href="https://dev.mysql.com/doc/refman/5.7/en/flush.html#flush-tables" target="_blank" rel="noopener"><code>FLUSH TABLES</code></a>或有问题的表下面的语句之一： ， ， ， ， ，或 。 <code>FLUSH TABLES *tbl_name*</code><a href="https://dev.mysql.com/doc/refman/5.7/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a><a href="https://dev.mysql.com/doc/refman/5.7/en/rename-table.html" target="_blank" rel="noopener"><code>RENAME TABLE</code></a><a href="https://dev.mysql.com/doc/refman/5.7/en/repair-table.html" target="_blank" rel="noopener"><code>REPAIR TABLE</code></a><a href="https://dev.mysql.com/doc/refman/5.7/en/analyze-table.html" target="_blank" rel="noopener"><code>ANALYZE TABLE</code></a><a href="https://dev.mysql.com/doc/refman/5.7/en/optimize-table.html" target="_blank" rel="noopener"><code>OPTIMIZE TABLE</code></a></p>
</li>
<li><p><code>Waiting for table flush</code></p>
<p>该线程正在执行<a href="https://dev.mysql.com/doc/refman/5.7/en/flush.html#flush-tables" target="_blank" rel="noopener"><code>FLUSH TABLES</code></a>并正在等待所有线程关闭其表，或者该线程收到有关表的基础结构已更改的通知，并且需要重新打开表以获取新结构。但是，要重新打开该表，它必须等待，直到所有其他线程关闭了该表。</p>
<p>这张告示，如果另一个线程使用的地方 <a href="https://dev.mysql.com/doc/refman/5.7/en/flush.html#flush-tables" target="_blank" rel="noopener"><code>FLUSH TABLES</code></a>或有问题的表下面的语句之一： ， ， ， ， ，或 。 <code>FLUSH TABLES *tbl_name*</code><a href="https://dev.mysql.com/doc/refman/5.7/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a><a href="https://dev.mysql.com/doc/refman/5.7/en/rename-table.html" target="_blank" rel="noopener"><code>RENAME TABLE</code></a><a href="https://dev.mysql.com/doc/refman/5.7/en/repair-table.html" target="_blank" rel="noopener"><code>REPAIR TABLE</code></a><a href="https://dev.mysql.com/doc/refman/5.7/en/analyze-table.html" target="_blank" rel="noopener"><code>ANALYZE TABLE</code></a><a href="https://dev.mysql.com/doc/refman/5.7/en/optimize-table.html" target="_blank" rel="noopener"><code>OPTIMIZE TABLE</code></a></p>
</li>
<li><p><code>Waiting for *lock_type* lock</code></p>
<p>服务器正在等待<code>THR_LOCK</code>从元数据锁定子系统获取 锁或锁，其中 <em>lock_type</em>指示了锁的类型。</p>
<p>此状态表示正在等待 <code>THR_LOCK</code>：</p>
<ul>
<li><code>Waiting for table level lock</code></li>
</ul>
<p>这些状态指示等待元数据锁定：</p>
<ul>
<li><code>Waiting for event metadata lock</code></li>
<li><code>Waiting for global read lock</code></li>
<li><code>Waiting for schema metadata lock</code></li>
<li><code>Waiting for stored function metadata lock</code></li>
<li><code>Waiting for stored procedure metadata lock</code></li>
<li><code>Waiting for table metadata lock</code></li>
<li><code>Waiting for trigger metadata lock</code></li>
</ul>
<p>有关表锁定指示器的信息，请参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/internal-locking.html" target="_blank" rel="noopener">第8.11.1节“内部锁定方法”</a>。有关元数据锁定的信息，请参见<a href="https://dev.mysql.com/doc/refman/5.7/en/metadata-locking.html" target="_blank" rel="noopener">第8.11.4节“元数据锁定”</a>。要查看哪些锁阻止了锁请求，请使用<a href="https://dev.mysql.com/doc/refman/5.7/en/performance-schema-lock-tables.html" target="_blank" rel="noopener">第25.12.12节“性能模式锁表”中</a>介绍的 <a href="https://dev.mysql.com/doc/refman/5.7/en/performance-schema-lock-tables.html" target="_blank" rel="noopener">性能模式锁表</a>。</p>
</li>
<li><p><code>Waiting on cond</code></p>
<p>线程正在等待条件变为真的一般状态。没有可用的特定状态信息。</p>
</li>
<li><p><code>Writing to net</code></p>
<p>服务器正在将数据包写入网络。<code>Sending to client</code>从MySQL 5.7.8开始，此状态被称为。</p>
</li>
</ul>
<h3 id="8-14-3查询缓存线程状态"><a href="#8-14-3查询缓存线程状态" class="headerlink" title="8.14.3查询缓存线程状态"></a>8.14.3查询缓存线程状态</h3><ul>
<li><p><code>checking privileges on cached query</code></p>
<p>服务器正在检查用户是否具有访问缓存的查询结果的特权。</p>
</li>
<li><p><code>checking query cache for query</code></p>
<p>服务器正在检查查询高速缓存中是否存在当前查询。</p>
</li>
<li><p><code>invalidating query cache entries</code></p>
<p>查询缓存条目被标记为无效，因为基础表已更改。</p>
</li>
<li><p><code>sending cached result to client</code></p>
<p>服务器正在从查询缓存中获取查询结果，并将其发送到客户端。</p>
</li>
<li><p><code>storing result in query cache</code></p>
<p>服务器将查询结果存储在查询缓存中。</p>
</li>
<li><p><code>Waiting for query cache lock</code></p>
<p>当会话正在等待获取查询缓存锁时，会发生此状态。对于需要执行某些查询缓存操作的任何语句（例如<a href="https://dev.mysql.com/doc/refman/5.7/en/insert.html" target="_blank" rel="noopener"><code>INSERT</code></a>或 <a href="https://dev.mysql.com/doc/refman/5.7/en/delete.html" target="_blank" rel="noopener"><code>DELETE</code></a>使查询缓存无效<a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a>，查找缓存条目的<a href="https://dev.mysql.com/doc/refman/5.7/en/reset.html" target="_blank" rel="noopener"><code>RESET QUERY CACHE</code></a>等等）， 都可能发生这种情况 。</p>
</li>
<li></li>
</ul>
<h3 id="8-14-4复制主线程状态"><a href="#8-14-4复制主线程状态" class="headerlink" title="8.14.4复制主线程状态"></a>8.14.4复制主线程状态</h3><ul>
<li><p><code>Finished reading one binlog; switching to next binlog</code></p>
<p>该线程已完成读取二进制日志文件，并正在打开下一个日志文件以发送到从属服务器。</p>
</li>
<li><p><code>Master has sent all binlog to slave; waiting for more updates</code></p>
<p>线程已从二进制日志中读取所有剩余的更新，并将其发送到从属服务器。线程现在处于空闲状态，等待由于主服务器上发生新更新而导致新事件出现在二进制日志中。</p>
</li>
<li><p><code>Sending binlog event to slave</code></p>
<p>二进制日志由<em>事件</em>组成，其中事件通常是更新以及一些其他信息。该线程已从二进制日志中读取一个事件，并将其发送到从属服务器。</p>
</li>
<li><p><code>Waiting to finalize termination</code></p>
<p>线程停止时发生的非常短暂的状态。</p>
</li>
</ul>
<h3 id="8-14-5复制从属I-O线程状态"><a href="#8-14-5复制从属I-O线程状态" class="headerlink" title="8.14.5复制从属I / O线程状态"></a>8.14.5复制从属I / O线程状态</h3><ul>
<li><p><code>Checking master version</code></p>
<p>建立与主机的连接后，状态非常短暂。</p>
</li>
<li><p><code>Connecting to master</code></p>
<p>线程正在尝试连接到主服务器。</p>
</li>
<li><p><code>Queueing master event to the relay log</code></p>
<p>线程已读取事件，并将其复制到中继日志，以便SQL线程可以处理它。</p>
</li>
<li><p><code>Reconnecting after a failed binlog dump request</code></p>
<p>线程正在尝试重新连接到主服务器。</p>
</li>
<li><p><code>Reconnecting after a failed master event read</code></p>
<p>线程正在尝试重新连接到主服务器。再次建立连接后，状态变为 <code>Waiting for master to send event</code>。</p>
</li>
<li><p><code>Registering slave on master</code></p>
<p>建立与主机的连接后非常短暂地发生的状态。</p>
</li>
<li><p><code>Requesting binlog dump</code></p>
<p>建立与主机的连接后，状态非常短暂。从请求的二进制日志文件名和位置开始，线程向主服务器发送对其二进制日志内容的请求。</p>
</li>
<li><p><code>Waiting for its turn to commit</code></p>
<p>如果<a href="https://dev.mysql.com/doc/refman/5.7/en/replication-options-slave.html#sysvar_slave_preserve_commit_order" target="_blank" rel="noopener"><code>slave_preserve_commit_order</code></a> 启用了从属线程正在等待较早的工作线程提交的状态 。</p>
</li>
<li><p><code>Waiting for master to send event</code></p>
<p>线程已连接到主服务器，正在等待二进制日志事件到达。如果主机空闲，这可能会持续很长时间。如果等待持续 <a href="https://dev.mysql.com/doc/refman/5.7/en/replication-options-slave.html#sysvar_slave_net_timeout" target="_blank" rel="noopener"><code>slave_net_timeout</code></a>几秒钟，则会发生超时。此时，线程认为连接已断开，并尝试重新连接。</p>
</li>
<li><p><code>Waiting for master update</code></p>
<p>之前的初始状态<code>Connecting to master</code>。</p>
</li>
<li><p><code>Waiting for slave mutex on exit</code></p>
<p>在线程停止时短暂发生的状态。</p>
</li>
<li><p><code>Waiting for the slave SQL thread to free enough relay log space</code></p>
<p>您使用的是非零 <a href="https://dev.mysql.com/doc/refman/5.7/en/replication-options-slave.html#sysvar_relay_log_space_limit" target="_blank" rel="noopener"><code>relay_log_space_limit</code></a> 值，并且中继日志已变得足够大，以致它们的合并大小超过了该值。I / O线程正在等待，直到SQL线程通过处理中继日志内容释放足够的空间，以便它可以删除某些中继日志文件。</p>
</li>
<li><p><code>Waiting to reconnect after a failed binlog dump request</code></p>
<p>如果二进制日志转储请求失败（由于断开连接），则线程在休眠时进入此状态，然后尝试定期重新连接。重试之间的间隔可以使用该<a href="https://dev.mysql.com/doc/refman/5.7/en/change-master-to.html" target="_blank" rel="noopener"><code>CHANGE MASTER TO</code></a>语句指定 。</p>
</li>
<li><p><code>Waiting to reconnect after a failed master event read</code></p>
<p>读取时发生错误（由于断开连接）。<a href="https://dev.mysql.com/doc/refman/5.7/en/change-master-to.html" target="_blank" rel="noopener"><code>CHANGE MASTER TO</code></a>在尝试重新连接之前，该线程处于休眠状态的语句所设置的秒数 （默认为60）。</p>
</li>
</ul>
<h3 id="8-14-6复制从SQL线程状态"><a href="#8-14-6复制从SQL线程状态" class="headerlink" title="8.14.6复制从SQL线程状态"></a>8.14.6复制从SQL线程状态</h3><ul>
<li><p><code>Killing slave</code></p>
<p>线程正在处理一条<code>STOP SLAVE</code> 语句。</p>
</li>
<li><p><code>Making temporary file (append) before replaying LOAD DATA INFILE</code></p>
<p>线程正在执行一条<a href="https://dev.mysql.com/doc/refman/5.7/en/load-data.html" target="_blank" rel="noopener"><code>LOAD DATA</code></a>语句，并将数据追加到一个临时文件中，该临时文件包含从站将从中读取行的数据。</p>
</li>
<li><p><code>Making temporary file (create) before replaying LOAD DATA INFILE</code></p>
<p>该线程正在执行一条<a href="https://dev.mysql.com/doc/refman/5.7/en/load-data.html" target="_blank" rel="noopener"><code>LOAD DATA</code></a>语句，并正在创建一个临时文件，其中包含从站将从中读取行的数据。仅当原始<a href="https://dev.mysql.com/doc/refman/5.7/en/load-data.html" target="_blank" rel="noopener"><code>LOAD DATA</code></a>语句是由运行低于MySQL 5.0.3的MySQL版本的主服务器记录的，才能遇到此状态 。</p>
</li>
<li><p><code>Reading event from the relay log</code></p>
<p>线程已从中继日志中读取事件，以便可以处理该事件。</p>
</li>
<li><p><code>Slave has read all relay log; waiting for more updates</code></p>
<p>该线程已经处理了中继日志文件中的所有事件，现在正在等待I / O线程将新事件写入中继日志。</p>
</li>
<li><p><code>Waiting for an event from Coordinator</code></p>
<p>使用多线程从属服务器（<a href="https://dev.mysql.com/doc/refman/5.7/en/replication-options-slave.html#sysvar_slave_parallel_workers" target="_blank" rel="noopener"><code>slave_parallel_workers</code></a>大于1），一个从属工作线程正在等待协调器线程的事件。</p>
</li>
<li><p><code>Waiting for slave mutex on exit</code></p>
<p>线程停止时发生的非常短暂的状态。</p>
</li>
<li><p><code>Waiting for Slave Workers to free pending events</code></p>
<p>当Workers处理的事件的总大小超过<a href="https://dev.mysql.com/doc/refman/5.7/en/replication-options-slave.html#sysvar_slave_pending_jobs_size_max" target="_blank" rel="noopener"><code>slave_pending_jobs_size_max</code></a> 系统变量的大小时，将发生此等待操作 。当大小降至此限制以下时，协调器将恢复调度。仅当<a href="https://dev.mysql.com/doc/refman/5.7/en/replication-options-slave.html#sysvar_slave_parallel_workers" target="_blank" rel="noopener"><code>slave_parallel_workers</code></a>设置为大于0 时，才会出现此状态 。</p>
</li>
<li><p><code>Waiting for the next event in relay log</code></p>
<p>之前的初始状态<code>Reading event from the relay log</code>。</p>
</li>
<li><p><code>Waiting until MASTER_DELAY seconds after master executed event</code></p>
<p>SQL线程已读取事件，但正在等待从属延迟过去。延迟设置 <code>MASTER_DELAY</code>为 <a href="https://dev.mysql.com/doc/refman/5.7/en/change-master-to.html" target="_blank" rel="noopener"><code>CHANGE MASTER TO</code></a>。</p>
</li>
</ul>
<p><code>Info</code>SQL线程 的列也可能显示语句的文本。这表明线程已经从中继日志中读取了一个事件，从中提取了该语句，并且可能正在执行该事件。</p>
<h3 id="8-14-7复制从设备连接线程状态"><a href="#8-14-7复制从设备连接线程状态" class="headerlink" title="8.14.7复制从设备连接线程状态"></a>8.14.7复制从设备连接线程状态</h3><ul>
<li><p><code>Changing master</code></p>
<p>线程正在处理一条<a href="https://dev.mysql.com/doc/refman/5.7/en/change-master-to.html" target="_blank" rel="noopener"><code>CHANGE MASTER TO</code></a>语句。</p>
</li>
<li><p><code>Killing slave</code></p>
<p>线程正在处理一条<code>STOP SLAVE</code> 语句。</p>
</li>
<li><p><code>Opening master dump table</code></p>
<p>此状态在之后发生<code>Creating table from master dump</code>。</p>
</li>
<li><p><code>Reading master dump table data</code></p>
<p>此状态在之后发生<code>Opening master dump table</code>。</p>
</li>
<li><p><code>Rebuilding the index on master dump table</code></p>
<p>此状态在之后发生<code>Reading master dump table data</code>。</p>
</li>
</ul>

  </div>
  <!--文末结束语-->
  
    <div style="text-align:center;color: #ccc;font-size:24px;"> --- 本文结束 <i class="iconfont icon-heartbeat" style="font-size:24px;"></i> The End --- </div>
  
  <!--页脚广告-->
  
  <div class="mdui-divider"></div>
  
  <nav>
    
    
      <a rel="next" class="post-nav-item mdui-float-right" href="/2020/06/29/JVM%E9%9D%A2%E8%AF%95%E9%A2%98/">
        <span>JVM面试题</span>
        <i class="iconfont icon-angle-right"></i>
      </a>
    
  </nav>
</article>




  <div class="toc-button"  style="z-index: 100;">
    <button class="mdui-fab mdui-ripple mdui-color-teal" mdui-menu="{target: '#toc'}"><i class="iconfont icon-list"></i></button>
    <ul class="mdui-menu" id="toc">
      <li class="mdui-menu-item">
        <a href="/2020/06/29/Mysql5.7%E4%B8%AD%E6%96%87%E5%8F%82%E8%80%83%E6%8C%87%E5%8D%97/" id="toc-header" class="mdui-ripple">文章目录</a>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Mysql5-7中文参考指南精要"><span class="toc-number">1.</span> <span class="toc-text">Mysql5.7中文参考指南精要</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#概述"><span class="toc-number">2.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#内部结构和可移植性"><span class="toc-number">2.1.</span> <span class="toc-text">内部结构和可移植性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#数据类型"><span class="toc-number">2.1.0.1.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#语句和函数"><span class="toc-number">2.1.0.2.</span> <span class="toc-text">语句和函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#安全"><span class="toc-number">2.1.0.3.</span> <span class="toc-text">安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#可扩展性和限制"><span class="toc-number">2.1.0.4.</span> <span class="toc-text">可扩展性和限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#连接"><span class="toc-number">2.1.0.5.</span> <span class="toc-text">连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#本地化"><span class="toc-number">2.1.0.6.</span> <span class="toc-text">本地化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#客户端和工具"><span class="toc-number">2.1.0.7.</span> <span class="toc-text">客户端和工具</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL历史"><span class="toc-number">2.2.</span> <span class="toc-text">MySQL历史</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#优化"><span class="toc-number">2.3.</span> <span class="toc-text">优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1优化概述"><span class="toc-number">2.4.</span> <span class="toc-text">8.1优化概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#在数据库级别进行优化"><span class="toc-number">2.4.1.</span> <span class="toc-text">在数据库级别进行优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在硬件级别进行优化"><span class="toc-number">2.4.2.</span> <span class="toc-text">在硬件级别进行优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#平衡可移植性和性能"><span class="toc-number">2.4.3.</span> <span class="toc-text">平衡可移植性和性能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2优化SQL语句"><span class="toc-number">2.5.</span> <span class="toc-text">8.2优化SQL语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-1优化SELECT语句"><span class="toc-number">2.5.1.</span> <span class="toc-text">8.2.1优化SELECT语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-1-WHERE子句优化"><span class="toc-number">2.5.1.1.</span> <span class="toc-text">8.2.1.1 WHERE子句优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-2范围优化"><span class="toc-number">2.5.1.2.</span> <span class="toc-text">8.2.1.2范围优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#单部分索引的范围访问方法"><span class="toc-number">2.5.1.2.1.</span> <span class="toc-text">单部分索引的范围访问方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#多部分索引的范围访问方法"><span class="toc-number">2.5.1.2.2.</span> <span class="toc-text">多部分索引的范围访问方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#多值比较的等距范围优化"><span class="toc-number">2.5.1.2.3.</span> <span class="toc-text">多值比较的等距范围优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#行构造函数表达式的范围优化"><span class="toc-number">2.5.1.2.4.</span> <span class="toc-text">行构造函数表达式的范围优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#限制内存使用以进行范围优化"><span class="toc-number">2.5.1.2.5.</span> <span class="toc-text">限制内存使用以进行范围优化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-3索引合并优化"><span class="toc-number">2.5.1.3.</span> <span class="toc-text">8.2.1.3索引合并优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#索引合并路口访问算法"><span class="toc-number">2.5.1.3.1.</span> <span class="toc-text">索引合并路口访问算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#索引合并联合访问算法"><span class="toc-number">2.5.1.3.2.</span> <span class="toc-text">索引合并联合访问算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#索引合并排序联合访问算法"><span class="toc-number">2.5.1.3.3.</span> <span class="toc-text">索引合并排序联合访问算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-4发动机状态下推优化"><span class="toc-number">2.5.1.4.</span> <span class="toc-text">8.2.1.4发动机状态下推优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-5索引条件下推优化"><span class="toc-number">2.5.1.5.</span> <span class="toc-text">8.2.1.5索引条件下推优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-6嵌套循环联接算法"><span class="toc-number">2.5.1.6.</span> <span class="toc-text">8.2.1.6嵌套循环联接算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#嵌套循环联接算法"><span class="toc-number">2.5.1.6.1.</span> <span class="toc-text">嵌套循环联接算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#块嵌套循环加入算法"><span class="toc-number">2.5.1.6.2.</span> <span class="toc-text">块嵌套循环加入算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-7嵌套联接优化"><span class="toc-number">2.5.1.7.</span> <span class="toc-text">8.2.1.7嵌套联接优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-8外部联接优化"><span class="toc-number">2.5.1.8.</span> <span class="toc-text">8.2.1.8外部联接优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-9外部联接简化"><span class="toc-number">2.5.1.9.</span> <span class="toc-text">8.2.1.9外部联接简化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-10多范围读取优化"><span class="toc-number">2.5.1.10.</span> <span class="toc-text">8.2.1.10多范围读取优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-11块嵌套循环和批处理密钥访问联接"><span class="toc-number">2.5.1.11.</span> <span class="toc-text">8.2.1.11块嵌套循环和批处理密钥访问联接</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#用于块嵌套循环和批处理密钥访问算法的联接缓冲区管理"><span class="toc-number">2.5.1.11.1.</span> <span class="toc-text">用于块嵌套循环和批处理密钥访问算法的联接缓冲区管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#外部联接和半联接的块嵌套循环算法"><span class="toc-number">2.5.1.11.2.</span> <span class="toc-text">外部联接和半联接的块嵌套循环算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#批量密钥访问联接"><span class="toc-number">2.5.1.11.3.</span> <span class="toc-text">批量密钥访问联接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#块嵌套循环和批处理密钥访问算法的优化器提示"><span class="toc-number">2.5.1.11.4.</span> <span class="toc-text">块嵌套循环和批处理密钥访问算法的优化器提示</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-12条件过滤"><span class="toc-number">2.5.1.12.</span> <span class="toc-text">8.2.1.12条件过滤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-13-IS-NULL优化"><span class="toc-number">2.5.1.13.</span> <span class="toc-text">8.2.1.13 IS NULL优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-14优化排序"><span class="toc-number">2.5.1.14.</span> <span class="toc-text">8.2.1.14优化排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#使用索引满足ORDER-BY"><span class="toc-number">2.5.1.14.1.</span> <span class="toc-text">使用索引满足ORDER BY</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#使用文件排序满足ORDER-BY"><span class="toc-number">2.5.1.14.2.</span> <span class="toc-text">使用文件排序满足ORDER BY</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#通过优化影响订单"><span class="toc-number">2.5.1.14.3.</span> <span class="toc-text">通过优化影响订单</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ORDER-BY执行计划信息可用"><span class="toc-number">2.5.1.14.4.</span> <span class="toc-text">ORDER BY执行计划信息可用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-15按优化分组"><span class="toc-number">2.5.1.15.</span> <span class="toc-text">8.2.1.15按优化分组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#松散索引扫描"><span class="toc-number">2.5.1.15.1.</span> <span class="toc-text">松散索引扫描</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#紧密索引扫描"><span class="toc-number">2.5.1.15.2.</span> <span class="toc-text">紧密索引扫描</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-16-DISTINCT优化"><span class="toc-number">2.5.1.16.</span> <span class="toc-text">8.2.1.16 DISTINCT优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-17-LIMIT查询优化"><span class="toc-number">2.5.1.17.</span> <span class="toc-text">8.2.1.17 LIMIT查询优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-18函数调用优化"><span class="toc-number">2.5.1.18.</span> <span class="toc-text">8.2.1.18函数调用优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-19行构造器表达式优化"><span class="toc-number">2.5.1.19.</span> <span class="toc-text">8.2.1.19行构造器表达式优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-20避免全表扫描"><span class="toc-number">2.5.1.20.</span> <span class="toc-text">8.2.1.20避免全表扫描</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-2优化子查询，派生表和视图引用"><span class="toc-number">2.5.2.</span> <span class="toc-text">8.2.2优化子查询，派生表和视图引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-2-1使用半联接转换优化子查询，派生表和视图引用"><span class="toc-number">2.5.2.1.</span> <span class="toc-text">8.2.2.1使用半联接转换优化子查询，派生表和视图引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-2-2通过实现来优化子查询"><span class="toc-number">2.5.2.2.</span> <span class="toc-text">8.2.2.2通过实现来优化子查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-2-3使用EXISTS策略优化子查询"><span class="toc-number">2.5.2.3.</span> <span class="toc-text">8.2.2.3使用EXISTS策略优化子查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-2-4通过合并或实现来优化派生表和视图引用"><span class="toc-number">2.5.2.4.</span> <span class="toc-text">8.2.2.4通过合并或实现来优化派生表和视图引用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-3优化INFORMATION-SCHEMA查询"><span class="toc-number">2.5.3.</span> <span class="toc-text">8.2.3优化INFORMATION_SCHEMA查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-4优化数据更改语句"><span class="toc-number">2.5.4.</span> <span class="toc-text">8.2.4优化数据更改语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-4-1优化INSERT语句"><span class="toc-number">2.5.4.1.</span> <span class="toc-text">8.2.4.1优化INSERT语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-4-2优化UPDATE语句"><span class="toc-number">2.5.4.2.</span> <span class="toc-text">8.2.4.2优化UPDATE语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-4-3优化DELETE语句"><span class="toc-number">2.5.4.3.</span> <span class="toc-text">8.2.4.3优化DELETE语句</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-5优化数据库特权"><span class="toc-number">2.5.5.</span> <span class="toc-text">8.2.5优化数据库特权</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-6其他优化技巧"><span class="toc-number">2.5.6.</span> <span class="toc-text">8.2.6其他优化技巧</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3优化和索引"><span class="toc-number">2.6.</span> <span class="toc-text">8.3优化和索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-1-MySQL如何使用索引"><span class="toc-number">2.6.1.</span> <span class="toc-text">8.3.1 MySQL如何使用索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-2主键优化"><span class="toc-number">2.6.2.</span> <span class="toc-text">8.3.2主键优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-3外键优化"><span class="toc-number">2.6.3.</span> <span class="toc-text">8.3.3外键优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-4列索引"><span class="toc-number">2.6.4.</span> <span class="toc-text">8.3.4列索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#索引前缀"><span class="toc-number">2.6.4.1.</span> <span class="toc-text">索引前缀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#全文索引"><span class="toc-number">2.6.4.2.</span> <span class="toc-text">全文索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#空间指数"><span class="toc-number">2.6.4.3.</span> <span class="toc-text">空间指数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MEMORY存储引擎中的索引"><span class="toc-number">2.6.4.4.</span> <span class="toc-text">MEMORY存储引擎中的索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-5多列索引"><span class="toc-number">2.6.5.</span> <span class="toc-text">8.3.5多列索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-6验证索引使用情况"><span class="toc-number">2.6.6.</span> <span class="toc-text">8.3.6验证索引使用情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-7-InnoDB和MyISAM索引统计信息收集"><span class="toc-number">2.6.7.</span> <span class="toc-text">8.3.7 InnoDB和MyISAM索引统计信息收集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-8-B树和哈希索引的比较"><span class="toc-number">2.6.8.</span> <span class="toc-text">8.3.8 B树和哈希索引的比较</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#B树索引特征"><span class="toc-number">2.6.8.1.</span> <span class="toc-text">B树索引特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#哈希指数特征"><span class="toc-number">2.6.8.2.</span> <span class="toc-text">哈希指数特征</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-9索引扩展的使用"><span class="toc-number">2.6.9.</span> <span class="toc-text">8.3.9索引扩展的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-10优化器对生成的列索引的使用"><span class="toc-number">2.6.10.</span> <span class="toc-text">8.3.10优化器对生成的列索引的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-11从TIMESTAMP列进行索引查找"><span class="toc-number">2.6.11.</span> <span class="toc-text">8.3.11从TIMESTAMP列进行索引查找</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4优化数据库结构"><span class="toc-number">2.7.</span> <span class="toc-text">8.4优化数据库结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-1优化数据大小"><span class="toc-number">2.7.1.</span> <span class="toc-text">8.4.1优化数据大小</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#表格栏"><span class="toc-number">2.7.1.1.</span> <span class="toc-text">表格栏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#行格式"><span class="toc-number">2.7.1.2.</span> <span class="toc-text">行格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#指标"><span class="toc-number">2.7.1.3.</span> <span class="toc-text">指标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#加入"><span class="toc-number">2.7.1.4.</span> <span class="toc-text">加入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#正常化"><span class="toc-number">2.7.1.5.</span> <span class="toc-text">正常化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-2优化MySQL数据类型"><span class="toc-number">2.7.2.</span> <span class="toc-text">8.4.2优化MySQL数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-2-1优化数值数据"><span class="toc-number">2.7.2.1.</span> <span class="toc-text">8.4.2.1优化数值数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-2-2优化字符和字符串类型"><span class="toc-number">2.7.2.2.</span> <span class="toc-text">8.4.2.2优化字符和字符串类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-2-3优化BLOB类型"><span class="toc-number">2.7.2.3.</span> <span class="toc-text">8.4.2.3优化BLOB类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-2-4使用过程分析"><span class="toc-number">2.7.2.4.</span> <span class="toc-text">8.4.2.4使用过程分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-3优化许多表"><span class="toc-number">2.7.3.</span> <span class="toc-text">8.4.3优化许多表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-3-1-MySQL如何打开和关闭表"><span class="toc-number">2.7.3.1.</span> <span class="toc-text">8.4.3.1 MySQL如何打开和关闭表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-3-2在同一数据库中创建多个表的缺点"><span class="toc-number">2.7.3.2.</span> <span class="toc-text">8.4.3.2在同一数据库中创建多个表的缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-4-MySQL中内部临时表的使用"><span class="toc-number">2.7.4.</span> <span class="toc-text">8.4.4 MySQL中内部临时表的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#内部临时表存储引擎"><span class="toc-number">2.7.4.1.</span> <span class="toc-text">内部临时表存储引擎</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内部临时表存储格式"><span class="toc-number">2.7.4.2.</span> <span class="toc-text">内部临时表存储格式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-5数据库和表数限制"><span class="toc-number">2.7.5.</span> <span class="toc-text">8.4.5数据库和表数限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-6表格大小限制"><span class="toc-number">2.7.6.</span> <span class="toc-text">8.4.6表格大小限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-7表列数和行大小的限制"><span class="toc-number">2.7.7.</span> <span class="toc-text">8.4.7表列数和行大小的限制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#列数限制"><span class="toc-number">2.7.7.1.</span> <span class="toc-text">列数限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#行大小限制"><span class="toc-number">2.7.7.2.</span> <span class="toc-text">行大小限制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#行大小限制示例"><span class="toc-number">2.7.7.2.1.</span> <span class="toc-text">行大小限制示例</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5优化InnoDB表"><span class="toc-number">2.8.</span> <span class="toc-text">8.5优化InnoDB表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-1优化InnoDB表的存储布局"><span class="toc-number">2.8.1.</span> <span class="toc-text">8.5.1优化InnoDB表的存储布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-2优化InnoDB事务管理"><span class="toc-number">2.8.2.</span> <span class="toc-text">8.5.2优化InnoDB事务管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-3优化InnoDB只读事务"><span class="toc-number">2.8.3.</span> <span class="toc-text">8.5.3优化InnoDB只读事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-4优化InnoDB重做日志"><span class="toc-number">2.8.4.</span> <span class="toc-text">8.5.4优化InnoDB重做日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-5-InnoDB表的批量数据加载"><span class="toc-number">2.8.5.</span> <span class="toc-text">8.5.5 InnoDB表的批量数据加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-6优化InnoDB查询"><span class="toc-number">2.8.6.</span> <span class="toc-text">8.5.6优化InnoDB查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-7优化InnoDB-DDL操作"><span class="toc-number">2.8.7.</span> <span class="toc-text">8.5.7优化InnoDB DDL操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-8优化InnoDB磁盘I-O"><span class="toc-number">2.8.8.</span> <span class="toc-text">8.5.8优化InnoDB磁盘I &#x2F; O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-9优化InnoDB配置变量"><span class="toc-number">2.8.9.</span> <span class="toc-text">8.5.9优化InnoDB配置变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-10为具有多个表的系统优化InnoDB"><span class="toc-number">2.8.10.</span> <span class="toc-text">8.5.10为具有多个表的系统优化InnoDB</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-6优化MyISAM表"><span class="toc-number">2.9.</span> <span class="toc-text">8.6优化MyISAM表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-1优化MyISAM查询"><span class="toc-number">2.9.1.</span> <span class="toc-text">8.6.1优化MyISAM查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-2-MyISAM表的批量数据加载"><span class="toc-number">2.9.2.</span> <span class="toc-text">8.6.2 MyISAM表的批量数据加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-3优化REPAIR-TABLE语句"><span class="toc-number">2.9.3.</span> <span class="toc-text">8.6.3优化REPAIR TABLE语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-7优化内存表"><span class="toc-number">2.10.</span> <span class="toc-text">8.7优化内存表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-8了解查询执行计划"><span class="toc-number">2.11.</span> <span class="toc-text">8.8了解查询执行计划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-8-1使用EXPLAIN优化查询"><span class="toc-number">2.11.1.</span> <span class="toc-text">8.8.1使用EXPLAIN优化查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-8-2说明输出格式"><span class="toc-number">2.11.2.</span> <span class="toc-text">8.8.2说明输出格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解释输出列"><span class="toc-number">2.11.2.1.</span> <span class="toc-text">解释输出列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#说明联接类型"><span class="toc-number">2.11.2.2.</span> <span class="toc-text">说明联接类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#了解更多信息"><span class="toc-number">2.11.2.3.</span> <span class="toc-text">了解更多信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解释输出解释"><span class="toc-number">2.11.2.4.</span> <span class="toc-text">解释输出解释</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-8-3扩展的EXPLAIN输出格式"><span class="toc-number">2.11.3.</span> <span class="toc-text">8.8.3扩展的EXPLAIN输出格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-8-4获取命名连接的执行计划信息"><span class="toc-number">2.11.4.</span> <span class="toc-text">8.8.4获取命名连接的执行计划信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-8-5估计查询性能"><span class="toc-number">2.11.5.</span> <span class="toc-text">8.8.5估计查询性能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-9控制查询优化器"><span class="toc-number">2.12.</span> <span class="toc-text">8.9控制查询优化器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-9-1控制查询计划评估"><span class="toc-number">2.12.1.</span> <span class="toc-text">8.9.1控制查询计划评估</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-9-2可切换的优化"><span class="toc-number">2.12.2.</span> <span class="toc-text">8.9.2可切换的优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-9-3优化器提示"><span class="toc-number">2.12.3.</span> <span class="toc-text">8.9.3优化器提示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#优化程序提示概述"><span class="toc-number">2.12.3.1.</span> <span class="toc-text">优化程序提示概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#优化程序提示语法"><span class="toc-number">2.12.3.2.</span> <span class="toc-text">优化程序提示语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#表级优化器提示"><span class="toc-number">2.12.3.3.</span> <span class="toc-text">表级优化器提示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#索引级优化器提示"><span class="toc-number">2.12.3.4.</span> <span class="toc-text">索引级优化器提示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#子查询优化器提示"><span class="toc-number">2.12.3.5.</span> <span class="toc-text">子查询优化器提示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#语句执行时间优化器提示"><span class="toc-number">2.12.3.6.</span> <span class="toc-text">语句执行时间优化器提示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#用于命名查询块的优化器提示"><span class="toc-number">2.12.3.7.</span> <span class="toc-text">用于命名查询块的优化器提示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-9-4索引提示"><span class="toc-number">2.12.4.</span> <span class="toc-text">8.9.4索引提示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-9-5优化器成本模型"><span class="toc-number">2.12.5.</span> <span class="toc-text">8.9.5优化器成本模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#成本模型一般运作"><span class="toc-number">2.12.5.1.</span> <span class="toc-text">成本模型一般运作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#成本模型数据库"><span class="toc-number">2.12.5.2.</span> <span class="toc-text">成本模型数据库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#更改成本模型数据库"><span class="toc-number">2.12.5.3.</span> <span class="toc-text">更改成本模型数据库</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-10缓冲和缓存"><span class="toc-number">2.13.</span> <span class="toc-text">8.10缓冲和缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-10-1-InnoDB缓冲池优化"><span class="toc-number">2.13.1.</span> <span class="toc-text">8.10.1 InnoDB缓冲池优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-10-2-MyISAM密钥缓存"><span class="toc-number">2.13.2.</span> <span class="toc-text">8.10.2 MyISAM密钥缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-10-2-1共享密钥缓存访问"><span class="toc-number">2.13.2.1.</span> <span class="toc-text">8.10.2.1共享密钥缓存访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-10-2-2多个键缓存"><span class="toc-number">2.13.2.2.</span> <span class="toc-text">8.10.2.2多个键缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-10-2-3中点插入策略"><span class="toc-number">2.13.2.3.</span> <span class="toc-text">8.10.2.3中点插入策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-10-2-4索引预加载"><span class="toc-number">2.13.2.4.</span> <span class="toc-text">8.10.2.4索引预加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-10-2-5密钥缓存块大小"><span class="toc-number">2.13.2.5.</span> <span class="toc-text">8.10.2.5密钥缓存块大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-10-2-6重构密钥缓存"><span class="toc-number">2.13.2.6.</span> <span class="toc-text">8.10.2.6重构密钥缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-10-3-MySQL查询缓存"><span class="toc-number">2.13.3.</span> <span class="toc-text">8.10.3 MySQL查询缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-10-3-1查询缓存如何运行"><span class="toc-number">2.13.3.1.</span> <span class="toc-text">8.10.3.1查询缓存如何运行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-10-3-2查询缓存SELECT选项"><span class="toc-number">2.13.3.2.</span> <span class="toc-text">8.10.3.2查询缓存SELECT选项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-10-3-3查询缓存配置"><span class="toc-number">2.13.3.3.</span> <span class="toc-text">8.10.3.3查询缓存配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-10-3-4查询缓存状态和维护"><span class="toc-number">2.13.3.4.</span> <span class="toc-text">8.10.3.4查询缓存状态和维护</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-10-4缓存准备好的语句和存储的程序"><span class="toc-number">2.13.4.</span> <span class="toc-text">8.10.4缓存准备好的语句和存储的程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-11优化锁定操作"><span class="toc-number">2.14.</span> <span class="toc-text">8.11优化锁定操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-11-1内部锁定方法"><span class="toc-number">2.14.1.</span> <span class="toc-text">8.11.1内部锁定方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#行级锁定"><span class="toc-number">2.14.1.1.</span> <span class="toc-text">行级锁定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#表级锁定"><span class="toc-number">2.14.1.2.</span> <span class="toc-text">表级锁定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#选择锁定类型"><span class="toc-number">2.14.1.3.</span> <span class="toc-text">选择锁定类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-11-2表锁定问题"><span class="toc-number">2.14.2.</span> <span class="toc-text">8.11.2表锁定问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#性能方面的考虑有利于InnoDB"><span class="toc-number">2.14.2.1.</span> <span class="toc-text">性能方面的考虑有利于InnoDB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#锁定性能问题的变通办法"><span class="toc-number">2.14.2.2.</span> <span class="toc-text">锁定性能问题的变通办法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-11-3并发插入"><span class="toc-number">2.14.3.</span> <span class="toc-text">8.11.3并发插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-11-4元数据锁定"><span class="toc-number">2.14.4.</span> <span class="toc-text">8.11.4元数据锁定</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#元数据锁定获取"><span class="toc-number">2.14.4.1.</span> <span class="toc-text">元数据锁定获取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#元数据锁定释放"><span class="toc-number">2.14.4.2.</span> <span class="toc-text">元数据锁定释放</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-11-5外部锁定"><span class="toc-number">2.14.5.</span> <span class="toc-text">8.11.5外部锁定</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-12优化MySQL服务器"><span class="toc-number">2.15.</span> <span class="toc-text">8.12优化MySQL服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-12-1系统因素"><span class="toc-number">2.15.1.</span> <span class="toc-text">8.12.1系统因素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-12-2优化磁盘I-O"><span class="toc-number">2.15.2.</span> <span class="toc-text">8.12.2优化磁盘I &#x2F; O</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#在MySQL中使用NFS"><span class="toc-number">2.15.2.1.</span> <span class="toc-text">在MySQL中使用NFS</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-12-3使用符号链接"><span class="toc-number">2.15.3.</span> <span class="toc-text">8.12.3使用符号链接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-12-3-1在Unix上对数据库使用符号链接"><span class="toc-number">2.15.3.1.</span> <span class="toc-text">8.12.3.1在Unix上对数据库使用符号链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-12-3-2在Unix上对MyISAM表使用符号链接"><span class="toc-number">2.15.3.2.</span> <span class="toc-text">8.12.3.2在Unix上对MyISAM表使用符号链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-12-3-3在Windows上对数据库使用符号链接"><span class="toc-number">2.15.3.3.</span> <span class="toc-text">8.12.3.3在Windows上对数据库使用符号链接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-12-4优化内存使用"><span class="toc-number">2.15.4.</span> <span class="toc-text">8.12.4优化内存使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-12-4-1-MySQL如何使用内存"><span class="toc-number">2.15.4.1.</span> <span class="toc-text">8.12.4.1 MySQL如何使用内存</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#监视MySQL内存使用情况"><span class="toc-number">2.15.4.1.1.</span> <span class="toc-text">监视MySQL内存使用情况</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-12-4-2启用大页面支持"><span class="toc-number">2.15.4.2.</span> <span class="toc-text">8.12.4.2启用大页面支持</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-13评估效果（基准测试）"><span class="toc-number">2.16.</span> <span class="toc-text">8.13评估效果（基准测试）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-13-1测量表达式和函数的速度"><span class="toc-number">2.16.1.</span> <span class="toc-text">8.13.1测量表达式和函数的速度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-13-2使用自己的基准"><span class="toc-number">2.16.2.</span> <span class="toc-text">8.13.2使用自己的基准</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-13-3使用performance-schema衡量绩效"><span class="toc-number">2.16.3.</span> <span class="toc-text">8.13.3使用performance_schema衡量绩效</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-14检查线程信息"><span class="toc-number">2.17.</span> <span class="toc-text">8.14检查线程信息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-14-1线程命令值"><span class="toc-number">2.17.1.</span> <span class="toc-text">8.14.1线程命令值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-14-2通用线程状态"><span class="toc-number">2.17.2.</span> <span class="toc-text">8.14.2通用线程状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-14-3查询缓存线程状态"><span class="toc-number">2.17.3.</span> <span class="toc-text">8.14.3查询缓存线程状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-14-4复制主线程状态"><span class="toc-number">2.17.4.</span> <span class="toc-text">8.14.4复制主线程状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-14-5复制从属I-O线程状态"><span class="toc-number">2.17.5.</span> <span class="toc-text">8.14.5复制从属I &#x2F; O线程状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-14-6复制从SQL线程状态"><span class="toc-number">2.17.6.</span> <span class="toc-text">8.14.6复制从SQL线程状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-14-7复制从设备连接线程状态"><span class="toc-number">2.17.7.</span> <span class="toc-text">8.14.7复制从设备连接线程状态</span></a></li></ol></li></ol></li></ol>
      </li>
    </ul>
  </div>



    <div id="comment" class="mdui-card mdui-p-a-2 mdui-m-b-5">
      <div class="mdui-tab" mdui-tab>
        
          <a href="#comment-tab0" class="mdui-ripple">gitalk</a>
        
          <a href="#comment-tab1" class="mdui-ripple">livere</a>
        
      </div>
      
        <div id="comment-tab0" class="mdui-p-a-2">
          <div id="gitalk-container"></div>
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script src="//cdn.jsdelivr.net/npm/js-md5@0.7.3/src/md5.min.js"></script>
<script>
  var gitalk = new Gitalk({
    clientID: '',
    clientSecret: '',
    repo: '',
    owner: '',
    admin: [''],
    id:  md5(location.pathname) ,
    distractionFreeMode: 'true',
  });
  gitalk.render('gitalk-container');
</script>
        </div>
      
        <div id="comment-tab1" class="mdui-p-a-2">
          <div id="lv-container" data-id="city" data-uid="">
  <script type="text/javascript">
    (function (d, s) {
      var j, e = d.getElementsByTagName(s)[0];
      if (typeof LivereTower === 'function') { return; }
      j = d.createElement(s);
      j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
      j.async = true;
      e.parentNode.insertBefore(j, e);
    })(document, 'script');
  </script>
  <noscript>Please enable JavaScript to view the comments powered by LiveRe.</noscript>
</div>
        </div>
      
    </div>

  </main>
  <footer id="footer" class="mdui-text-center mdui-m-t-5 mdui-p-b-2 mdui-p-t-4 mdui-color-theme">
  <div class="mdui-container">
    <div class="mdui-row">
      
        <a href="http://www.beian.miit.gov.cn" rel="noopener" target="_blank"></a>
      
      <span>
        &copy; 2015 - 2020 
        
          <span style="color:#d9333f" class="iconfont icon-heart"></span>
        
        John Doe
      </span>
    </div>
    <div class="mdui-row">
      
        <div class="mdui-col-xs-6 mdui-text-right">
          <span>Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a></span>
        </div>
        <div class="mdui-col-xs-6 mdui-text-left">
          <span>Theme: <a href="https://github.com/kb1000fx/Meadow" rel="noopener" target="_blank">Meadow</a></span>
        </div>
      
    </div>
    <div class="mdui-row">
      
        <div class="mdui-col-xs-6 mdui-text-right">
          <span id="busuanzi_container_site_uv" style="display: none;"> <span class="iconfont icon-user"></span>总访客量 <span id="busuanzi_value_site_uv"></span></span>
        </div>
        <div class="mdui-col-xs-6 mdui-text-left">
          <span id="busuanzi_container_site_pv" style="display: none;"> <span class="iconfont icon-eye"></span>总访问量 <span id="busuanzi_value_site_pv"></span></span>
        </div>
      
    </div>
 </div>
</footer>
  
  <button id="gotop" class="mdui-fab mdui-fab-fixed mdui-fab-hide mdui-ripple mdui-color-teal" style="z-index:100;"><i class="iconfont icon-arrowup"></i></button>
  
  

    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




    <script src="https://cdn.jsdelivr.net/npm/mermaid@8.4.8/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({
        startOnLoad: true,
        theme: "default"
    });</script>




<script src="/js/mdui.min.js"></script>
<script src="/js/meadow.js"></script>

</body>
</html >